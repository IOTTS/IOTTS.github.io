<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>4~20ma信号采集电路</title>
    <url>/2020/04/03/4-20ma%E4%BF%A1%E5%8F%B7%E9%87%87%E9%9B%86%E7%94%B5%E8%B7%AF/</url>
    <content><![CDATA[<p>​    一般仪器仪表的信号电流都为4-20mA，指最小电流为4mA,最大电流为20mA 。传输信号时候，要考虑到导线上也有电阻，如果用电压传输则会在导线的产生一定的压降，那接收端的信号就会产生一定的误差了。所以使用电流信号作为变送器的标准传输。</p>
<p>那么为什么选择4-20mA而不是0-20mA，有如下几点原因：<br><a id="more"></a> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 电流信号的抗干扰能力更好，传输距离较远。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 接<span class="number">150</span>Ω采样电阻，很容易得到<span class="number">0.6</span><span class="number">-3</span>V信号。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 电流小可以直接使用采样电阻，功耗小，简化了采样电路</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 用来检测线路开路的，如果<span class="number">0</span>是最小，那么开路故障就检测不到了。</span><br></pre></td></tr></table></figure>
<p>简单仿真了一个4-20mA转换为0.6V-3V的转换电路。</p>
<p><img src="4ma.png" alt="1"></p>
<p>图一：4mA输入<br> <img src="10ma.png" alt="2"></p>
<p>图二：10mA输入<br> <img src="20ma.png" alt="3"></p>
<p>图三：20mA输入</p>
<p>​    那么我们实际如何来采集4-20mA的电流，首先我们可以把电流信号转换为电压信号，然后经过单片机的12位ADC转换，结果是把0~VCC的值转换成了0~4096。如果VCC是3V，我们可以再利用等比公式，把0~4095转换成0~3V的电压值，最后把电压转换为电流值。这就是我们所采集的最终电流了。</p>
]]></content>
      <categories>
        <category>电路设计相关</category>
        <category>传感器电路设计</category>
      </categories>
      <tags>
        <tag>PCB</tag>
        <tag>电路设计</tag>
      </tags>
  </entry>
  <entry>
    <title>AD画原理图库时将一个元件拆分为多部分</title>
    <url>/2018/04/17/AD%E7%94%BB%E5%8E%9F%E7%90%86%E5%9B%BE%E5%BA%93%E6%97%B6%E5%B0%86%E4%B8%80%E4%B8%AA%E5%85%83%E4%BB%B6%E6%8B%86%E5%88%86%E4%B8%BA%E5%A4%9A%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<h1 id="AD画原理图库时将一个元件拆分为多部分"><a href="#AD画原理图库时将一个元件拆分为多部分" class="headerlink" title="AD画原理图库时将一个元件拆分为多部分"></a>AD画原理图库时将一个元件拆分为多部分</h1><p>画好第一部分后，在窗口左侧的SCHLibrary 选中该器件名称</p>
<p><img src="1.png" alt="1"></p>
<p>然后点菜单栏 <code>Tool - New Part</code></p>
<p><img src="2.png" alt="2"></p>
<p>就可看到器件名称前多了一个“+”号，点开“+”号，可见器件分成了两个部分：Part A、Part B；</p>
<p><img src="3.png" alt="3"></p>
<p>将Part A中画好的部件复制到Part B中，修改引脚号即可。同样的方法增加组件C、D。</p>
]]></content>
      <categories>
        <category>PCB相关</category>
        <category>Altium Designer</category>
        <category>Altium Designer小技巧</category>
      </categories>
      <tags>
        <tag>PCB</tag>
        <tag>Altium Designer</tag>
      </tags>
  </entry>
  <entry>
    <title>ASCII码对照表</title>
    <url>/2019/11/30/ASCII%E7%A0%81%E5%AF%B9%E7%85%A7%E8%A1%A8/</url>
    <content><![CDATA[<p>ASCII ((American Standard Code for Information Interchange): 美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。它是最通用的信息交换标准，并等同于国际标准ISO/IEC 646。ASCII第一次以规范标准的类型发表是在1967年，最后一次更新则是在1986年，到目前为止共定义了128个字符。<br><a id="more"></a></p>
<h3 id="ASCII控制字符"><a href="#ASCII控制字符" class="headerlink" title="ASCII控制字符"></a>ASCII控制字符</h3><div class="table-container">
<table>
<thead>
<tr>
<th>二进制</th>
<th>十进制</th>
<th>十六进制</th>
<th>缩写</th>
<th>可以显示的表示法</th>
<th>名称/意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0000 0000</td>
<td>0</td>
<td>00</td>
<td>NUL</td>
<td>␀</td>
<td>空字符（Null）</td>
</tr>
<tr>
<td>0000 0001</td>
<td>1</td>
<td>01</td>
<td>SOH</td>
<td>␁</td>
<td>标题开始</td>
</tr>
<tr>
<td>0000 0010</td>
<td>2</td>
<td>02</td>
<td>STX</td>
<td>␂</td>
<td>本文开始</td>
</tr>
<tr>
<td>0000 0011</td>
<td>3</td>
<td>03</td>
<td>ETX</td>
<td>␃</td>
<td>本文结束</td>
</tr>
<tr>
<td>0000 0100</td>
<td>4</td>
<td>04</td>
<td>EOT</td>
<td>␄</td>
<td>传输结束</td>
</tr>
<tr>
<td>0000 0101</td>
<td>5</td>
<td>05</td>
<td>ENQ</td>
<td>␅</td>
<td>请求</td>
</tr>
<tr>
<td>0000 0110</td>
<td>6</td>
<td>06</td>
<td>ACK</td>
<td>␆</td>
<td>确认回应</td>
</tr>
<tr>
<td>0000 0111</td>
<td>7</td>
<td>07</td>
<td>BEL</td>
<td>␇</td>
<td>响铃</td>
</tr>
<tr>
<td>0000 1000</td>
<td>8</td>
<td>08</td>
<td>BS</td>
<td>␈</td>
<td>退格</td>
</tr>
<tr>
<td>0000 1001</td>
<td>9</td>
<td>09</td>
<td>HT</td>
<td>␉</td>
<td>水平定位符号</td>
</tr>
<tr>
<td>0000 1010</td>
<td>10</td>
<td>0A</td>
<td>LF</td>
<td>␊</td>
<td>换行键</td>
</tr>
<tr>
<td>0000 1011</td>
<td>11</td>
<td>0B</td>
<td>VT</td>
<td>␋</td>
<td>垂直定位符号</td>
</tr>
<tr>
<td>0000 1100</td>
<td>12</td>
<td>0C</td>
<td>FF</td>
<td>␌</td>
<td>换页键</td>
</tr>
<tr>
<td>0000 1101</td>
<td>13</td>
<td>0D</td>
<td>CR</td>
<td>␍</td>
<td>归位键</td>
</tr>
<tr>
<td>0000 1110</td>
<td>14</td>
<td>0E</td>
<td>SO</td>
<td>␎</td>
<td>取消变换（Shift out）</td>
</tr>
<tr>
<td>0000 1111</td>
<td>15</td>
<td>0F</td>
<td>SI</td>
<td>␏</td>
<td>启用变换（Shift in）</td>
</tr>
<tr>
<td>0001 0000</td>
<td>16</td>
<td>10</td>
<td>DLE</td>
<td>␐</td>
<td>跳出数据通讯</td>
</tr>
<tr>
<td>0001 0001</td>
<td>17</td>
<td>11</td>
<td>DC1</td>
<td>␑</td>
<td>设备控制一（XON 启用软件速度控制）</td>
</tr>
<tr>
<td>0001 0010</td>
<td>18</td>
<td>12</td>
<td>DC2</td>
<td>␒</td>
<td>设备控制二</td>
</tr>
<tr>
<td>0001 0011</td>
<td>19</td>
<td>13</td>
<td>DC3</td>
<td>␓</td>
<td>设备控制三（XOFF 停用软件速度控制）</td>
</tr>
<tr>
<td>0001 0100</td>
<td>20</td>
<td>14</td>
<td>DC4</td>
<td>␔</td>
<td>设备控制四</td>
</tr>
<tr>
<td>0001 0101</td>
<td>21</td>
<td>15</td>
<td>NAK</td>
<td>␕</td>
<td>确认失败回应</td>
</tr>
<tr>
<td>0001 0110</td>
<td>22</td>
<td>16</td>
<td>SYN</td>
<td>␖</td>
<td>同步用暂停</td>
</tr>
<tr>
<td>0001 0111</td>
<td>23</td>
<td>17</td>
<td>ETB</td>
<td>␗</td>
<td>区块传输结束</td>
</tr>
<tr>
<td>0001 1000</td>
<td>24</td>
<td>18</td>
<td>CAN</td>
<td>␘</td>
<td>取消</td>
</tr>
<tr>
<td>0001 1001</td>
<td>25</td>
<td>19</td>
<td>EM</td>
<td>␙</td>
<td>连接介质中断</td>
</tr>
<tr>
<td>0001 1010</td>
<td>26</td>
<td>1A</td>
<td>SUB</td>
<td>␚</td>
<td>替换</td>
</tr>
<tr>
<td>0001 1011</td>
<td>27</td>
<td>1B</td>
<td>ESC</td>
<td>␛</td>
<td>跳出</td>
</tr>
<tr>
<td>0001 1100</td>
<td>28</td>
<td>1C</td>
<td>FS</td>
<td>␜</td>
<td>文件分割符</td>
</tr>
<tr>
<td>0001 1101</td>
<td>29</td>
<td>1D</td>
<td>GS</td>
<td>␝</td>
<td>组群分隔符</td>
</tr>
<tr>
<td>0001 1110</td>
<td>30</td>
<td>1E</td>
<td>RS</td>
<td>␞</td>
<td>记录分隔符</td>
</tr>
<tr>
<td>0001 1111</td>
<td>31</td>
<td>1F</td>
<td>US</td>
<td>␟</td>
<td>单元分隔符</td>
</tr>
<tr>
<td>0111 1111</td>
<td>127</td>
<td>7F</td>
<td>DEL</td>
<td>␡</td>
<td>删除</td>
</tr>
</tbody>
</table>
</div>
<h3 id="ASCII可显示字符"><a href="#ASCII可显示字符" class="headerlink" title="ASCII可显示字符"></a>ASCII可显示字符</h3><div class="table-container">
<table>
<thead>
<tr>
<th>二进制</th>
<th>十进制</th>
<th>十六进制</th>
<th>图形</th>
</tr>
</thead>
<tbody>
<tr>
<td>0010 0000</td>
<td>32</td>
<td>20</td>
<td>（空格）(␠)</td>
</tr>
<tr>
<td>0010 0001</td>
<td>33</td>
<td>21</td>
<td>!</td>
</tr>
<tr>
<td>0010 0010</td>
<td>34</td>
<td>22</td>
<td>“</td>
</tr>
<tr>
<td>0010 0011</td>
<td>35</td>
<td>23</td>
<td>#</td>
</tr>
<tr>
<td>0010 0100</td>
<td>36</td>
<td>24</td>
<td>$</td>
</tr>
<tr>
<td>0010 0101</td>
<td>37</td>
<td>25</td>
<td>%</td>
</tr>
<tr>
<td>0010 0110</td>
<td>38</td>
<td>26</td>
<td>&amp;</td>
</tr>
<tr>
<td>0010 0111</td>
<td>39</td>
<td>27</td>
<td>‘</td>
</tr>
<tr>
<td>0010 1000</td>
<td>40</td>
<td>28</td>
<td>(</td>
</tr>
<tr>
<td>0010 1001</td>
<td>41</td>
<td>29</td>
<td>)</td>
</tr>
<tr>
<td>0010 1010</td>
<td>42</td>
<td>2A</td>
<td>*</td>
</tr>
<tr>
<td>0010 1011</td>
<td>43</td>
<td>2B</td>
<td>+</td>
</tr>
<tr>
<td>0010 1100</td>
<td>44</td>
<td>2C</td>
<td>,</td>
</tr>
<tr>
<td>0010 1101</td>
<td>45</td>
<td>2D</td>
<td>-</td>
</tr>
<tr>
<td>0010 1110</td>
<td>46</td>
<td>2E</td>
<td>.</td>
</tr>
<tr>
<td>0010 1111</td>
<td>47</td>
<td>2F</td>
<td>/</td>
</tr>
<tr>
<td>0011 0000</td>
<td>48</td>
<td>30</td>
<td>0</td>
</tr>
<tr>
<td>0011 0001</td>
<td>49</td>
<td>31</td>
<td>1</td>
</tr>
<tr>
<td>0011 0010</td>
<td>50</td>
<td>32</td>
<td>2</td>
</tr>
<tr>
<td>0011 0011</td>
<td>51</td>
<td>33</td>
<td>3</td>
</tr>
<tr>
<td>0011 0100</td>
<td>52</td>
<td>34</td>
<td>4</td>
</tr>
<tr>
<td>0011 0101</td>
<td>53</td>
<td>35</td>
<td>5</td>
</tr>
<tr>
<td>0011 0110</td>
<td>54</td>
<td>36</td>
<td>6</td>
</tr>
<tr>
<td>0011 0111</td>
<td>55</td>
<td>37</td>
<td>7</td>
</tr>
<tr>
<td>0011 1000</td>
<td>56</td>
<td>38</td>
<td>8</td>
</tr>
<tr>
<td>0011 1001</td>
<td>57</td>
<td>39</td>
<td>9</td>
</tr>
<tr>
<td>0011 1010</td>
<td>58</td>
<td>3A</td>
<td>:</td>
</tr>
<tr>
<td>0011 1011</td>
<td>59</td>
<td>3B</td>
<td>;</td>
</tr>
<tr>
<td>0011 1100</td>
<td>60</td>
<td>3C</td>
<td>&lt;</td>
</tr>
<tr>
<td>0011 1101</td>
<td>61</td>
<td>3D</td>
<td>=</td>
</tr>
<tr>
<td>0011 1110</td>
<td>62</td>
<td>3E</td>
<td>&gt;</td>
</tr>
<tr>
<td>0011 1111</td>
<td>63</td>
<td>3F</td>
<td>?</td>
</tr>
<tr>
<td>0100 0000</td>
<td>64</td>
<td>40</td>
<td>@</td>
</tr>
<tr>
<td>0100 0001</td>
<td>65</td>
<td>41</td>
<td>A</td>
</tr>
<tr>
<td>0100 0010</td>
<td>66</td>
<td>42</td>
<td>B</td>
</tr>
<tr>
<td>0100 0011</td>
<td>67</td>
<td>43</td>
<td>C</td>
</tr>
<tr>
<td>0100 0100</td>
<td>68</td>
<td>44</td>
<td>D</td>
</tr>
<tr>
<td>0100 0101</td>
<td>69</td>
<td>45</td>
<td>E</td>
</tr>
<tr>
<td>0100 0110</td>
<td>70</td>
<td>46</td>
<td>F</td>
</tr>
<tr>
<td>0100 0111</td>
<td>71</td>
<td>47</td>
<td>G</td>
</tr>
<tr>
<td>0100 1000</td>
<td>72</td>
<td>48</td>
<td>H</td>
</tr>
<tr>
<td>0100 1001</td>
<td>73</td>
<td>49</td>
<td>I</td>
</tr>
<tr>
<td>0100 1010</td>
<td>74</td>
<td>4A</td>
<td>J</td>
</tr>
<tr>
<td>0100 1011</td>
<td>75</td>
<td>4B</td>
<td>K</td>
</tr>
<tr>
<td>0100 1100</td>
<td>76</td>
<td>4C</td>
<td>L</td>
</tr>
<tr>
<td>0100 1101</td>
<td>77</td>
<td>4D</td>
<td>M</td>
</tr>
<tr>
<td>0100 1110</td>
<td>78</td>
<td>4E</td>
<td>N</td>
</tr>
<tr>
<td>0100 1111</td>
<td>79</td>
<td>4F</td>
<td>O</td>
</tr>
<tr>
<td>0101 0000</td>
<td>80</td>
<td>50</td>
<td>P</td>
</tr>
<tr>
<td>0101 0001</td>
<td>81</td>
<td>51</td>
<td>Q</td>
</tr>
<tr>
<td>0101 0010</td>
<td>82</td>
<td>52</td>
<td>R</td>
</tr>
<tr>
<td>0101 0011</td>
<td>83</td>
<td>53</td>
<td>S</td>
</tr>
<tr>
<td>0101 0100</td>
<td>84</td>
<td>54</td>
<td>T</td>
</tr>
<tr>
<td>0101 0101</td>
<td>85</td>
<td>55</td>
<td>U</td>
</tr>
<tr>
<td>0101 0110</td>
<td>86</td>
<td>56</td>
<td>V</td>
</tr>
<tr>
<td>0101 0111</td>
<td>87</td>
<td>57</td>
<td>W</td>
</tr>
<tr>
<td>0101 1000</td>
<td>88</td>
<td>58</td>
<td>X</td>
</tr>
<tr>
<td>0101 1001</td>
<td>89</td>
<td>59</td>
<td>Y</td>
</tr>
<tr>
<td>0101 1010</td>
<td>90</td>
<td>5A</td>
<td>Z</td>
</tr>
<tr>
<td>0101 1011</td>
<td>91</td>
<td>5B</td>
<td>[</td>
</tr>
<tr>
<td>0101 1100</td>
<td>92</td>
<td>5C</td>
<td>\</td>
</tr>
<tr>
<td>0101 1101</td>
<td>93</td>
<td>5D</td>
<td>]</td>
</tr>
<tr>
<td>0101 1110</td>
<td>94</td>
<td>5E</td>
<td>^</td>
</tr>
<tr>
<td>0101 1111</td>
<td>95</td>
<td>5F</td>
<td>_</td>
</tr>
<tr>
<td>0110 0000</td>
<td>96</td>
<td>60</td>
<td>`</td>
</tr>
<tr>
<td>0110 0001</td>
<td>97</td>
<td>61</td>
<td>a</td>
</tr>
<tr>
<td>0110 0010</td>
<td>98</td>
<td>62</td>
<td>b</td>
</tr>
<tr>
<td>0110 0011</td>
<td>99</td>
<td>63</td>
<td>c</td>
</tr>
<tr>
<td>0110 0100</td>
<td>100</td>
<td>64</td>
<td>d</td>
</tr>
<tr>
<td>0110 0101</td>
<td>101</td>
<td>65</td>
<td>e</td>
</tr>
<tr>
<td>0110 0110</td>
<td>102</td>
<td>66</td>
<td>f</td>
</tr>
<tr>
<td>0110 0111</td>
<td>103</td>
<td>67</td>
<td>g</td>
</tr>
<tr>
<td>0110 1000</td>
<td>104</td>
<td>68</td>
<td>h</td>
</tr>
<tr>
<td>0110 1001</td>
<td>105</td>
<td>69</td>
<td>i</td>
</tr>
<tr>
<td>0110 1010</td>
<td>106</td>
<td>6A</td>
<td>j</td>
</tr>
<tr>
<td>0110 1011</td>
<td>107</td>
<td>6B</td>
<td>k</td>
</tr>
<tr>
<td>0110 1100</td>
<td>108</td>
<td>6C</td>
<td>l</td>
</tr>
<tr>
<td>0110 1101</td>
<td>109</td>
<td>6D</td>
<td>m</td>
</tr>
<tr>
<td>0110 1110</td>
<td>110</td>
<td>6E</td>
<td>n</td>
</tr>
<tr>
<td>0110 1111</td>
<td>111</td>
<td>6F</td>
<td>o</td>
</tr>
<tr>
<td>0111 0000</td>
<td>112</td>
<td>70</td>
<td>p</td>
</tr>
<tr>
<td>0111 0001</td>
<td>113</td>
<td>71</td>
<td>q</td>
</tr>
<tr>
<td>0111 0010</td>
<td>114</td>
<td>72</td>
<td>r</td>
</tr>
<tr>
<td>0111 0011</td>
<td>115</td>
<td>73</td>
<td>s</td>
</tr>
<tr>
<td>0111 0100</td>
<td>116</td>
<td>74</td>
<td>t</td>
</tr>
<tr>
<td>0111 0101</td>
<td>117</td>
<td>75</td>
<td>u</td>
</tr>
<tr>
<td>0111 0110</td>
<td>118</td>
<td>76</td>
<td>v</td>
</tr>
<tr>
<td>0111 0111</td>
<td>119</td>
<td>77</td>
<td>w</td>
</tr>
<tr>
<td>0111 1000</td>
<td>120</td>
<td>78</td>
<td>x</td>
</tr>
<tr>
<td>0111 1001</td>
<td>121</td>
<td>79</td>
<td>y</td>
</tr>
<tr>
<td>0111 1010</td>
<td>122</td>
<td>7A</td>
<td>z</td>
</tr>
<tr>
<td>0111 1011</td>
<td>123</td>
<td>7B</td>
<td>{</td>
</tr>
<tr>
<td>0111 1100</td>
<td>124</td>
<td>7C</td>
<td>\</td>
<td></td>
</tr>
<tr>
<td>0111 1101</td>
<td>125</td>
<td>7D</td>
<td>}</td>
</tr>
<tr>
<td>0111 1110</td>
<td>126</td>
<td>7E</td>
<td>~</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>常用资料</category>
      </categories>
      <tags>
        <tag>ASCII</tag>
        <tag>常用资料</tag>
      </tags>
  </entry>
  <entry>
    <title>ATX电源接口线序定义</title>
    <url>/2020/04/03/ATX%E7%94%B5%E6%BA%90%E6%8E%A5%E5%8F%A3%E7%BA%BF%E5%BA%8F%E5%AE%9A%E4%B9%89/</url>
    <content><![CDATA[<p>ATX电源简介</p>
<p>　　ATX电源作用是把交流220V的电源转换为计算机内部使用的直流5V，12V的电源。</p>
<p>　　ATX电源的特点：与AT电源相比，ATX电源增加了“+3.3V、+5VSB、PS－ON</p>
<p>　　其中“+3.3V”输出主要是供内存用，而“+5VSB”、“PS－ON”输出则体现了ATX电源的特点。<br><a id="more"></a><br>ATX电源最主要的特点就是：它不采用传统的市电开关来控制电源是否工作，而是采用“+5VSB、PS－ON”的组合来实现电源的开启和关闭，只要控制“PS－ON”信号电平的变化，就能控制电源的开启和关闭。“PS－ON”小于1V伏时开启电源，大于4.5伏时关闭电源。和AT电源不一样，ATX电源除了在线路上作了一些改进，其中最重要的区别是，关机时ATX电源本身并没有彻底断电，而是维持了一个比较微弱的电流。同时它利用这一电流增加了一个电源管理功能，称为Stand-By。它可以让操作系统直接对电源进行管理。通过此功能，用户就可以直接通过操作系统实现软关机，而且还可以实现网络化的电源管理。如在电脑关闭时，可以通过网络发出信号到电脑的Modem上，然后监控电路就会发出一个ATX电源所特有的+5VSB激活电压，来打开电源启动电脑，从而实现远程开机。</p>
<p>下面是ATX接口的详细线序图：</p>
<h2 id="24-pin-ATX12V-2-x"><a href="#24-pin-ATX12V-2-x" class="headerlink" title="24-pin ATX12V 2.x"></a>24-pin ATX12V 2.x</h2><p><img src="24p.png" alt="24p"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>Color</strong></th>
<th><strong>Signal</strong></th>
<th><strong>Pin</strong></th>
<th></th>
<th><strong>Pin</strong></th>
<th><strong>Signal</strong></th>
<th><strong>Color</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Orange</td>
<td>+3.3 V</td>
<td><strong>1</strong></td>
<td></td>
<td><strong>13</strong></td>
<td>+3.3 V</td>
<td>Orange</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>+3.3 V sense</td>
<td>Brown</td>
</tr>
<tr>
<td>Orange</td>
<td>+3.3 V</td>
<td><strong>2</strong></td>
<td></td>
<td><strong>14</strong></td>
<td>-12 V</td>
<td>Blue</td>
</tr>
<tr>
<td>Black</td>
<td>Ground</td>
<td><strong>3</strong></td>
<td></td>
<td><strong>15</strong></td>
<td>Ground</td>
<td>Black</td>
</tr>
<tr>
<td>Red</td>
<td>+5 V</td>
<td><strong>4</strong></td>
<td></td>
<td><strong>16</strong></td>
<td>Power on</td>
<td>Green</td>
</tr>
<tr>
<td>Black</td>
<td>Ground</td>
<td><strong>5</strong></td>
<td></td>
<td><strong>17</strong></td>
<td>Ground</td>
<td>Black</td>
</tr>
<tr>
<td>Red</td>
<td>+5 V</td>
<td><strong>6</strong></td>
<td></td>
<td><strong>18</strong></td>
<td>Ground</td>
<td>Black</td>
</tr>
<tr>
<td>Black</td>
<td>Ground</td>
<td><strong>7</strong></td>
<td></td>
<td><strong>19</strong></td>
<td>Ground</td>
<td>Black</td>
</tr>
<tr>
<td>Grey</td>
<td>Power good</td>
<td><strong>8</strong></td>
<td></td>
<td><strong>20</strong></td>
<td>-5V</td>
<td>White</td>
</tr>
<tr>
<td>Purple</td>
<td>+5 V standby</td>
<td><strong>9</strong></td>
<td></td>
<td><strong>21</strong></td>
<td>+5 V</td>
<td>Red</td>
</tr>
<tr>
<td>Yellow</td>
<td>+12 V</td>
<td><strong>10</strong></td>
<td></td>
<td><strong>22</strong></td>
<td>+5 V</td>
<td>Red</td>
</tr>
<tr>
<td>Yellow</td>
<td>+12 V</td>
<td><strong>11</strong></td>
<td></td>
<td><strong>23</strong></td>
<td>+5 V</td>
<td>Red</td>
</tr>
<tr>
<td>Orange</td>
<td>+3.3 V</td>
<td><strong>12</strong></td>
<td></td>
<td><strong>24</strong></td>
<td>Ground</td>
<td>Black</td>
</tr>
</tbody>
</table>
</div>
<p>20-pin ATX connector omits the last four pin: 11, 12, 23, 24)</p>
<p>Pins 8, 13, and 16 are control signals:</p>
<ul>
<li>“Power On” is pulled up to +5V by the PSU, and must be driven low to turn on the PSU.</li>
<li>“Power good” is low when other outputs have not yet reached, or are about to leave, correct voltages.</li>
<li>“+3.3 V sense” line is for remote sensing of the voltage drop in the power supply wiring (should be connected to the +3.3 V on the motherboard)</li>
</ul>
<p>“+5 V standby” supplies power even when the rest of the supply lines are off.</p>
<p>Pin 20 (-5V, white) is absent in current power supplies; it was optional in ATX and ATX12V ver. 1.2, and deleted as of ver. 1.3.</p>
<h2 id="ATX-Aux-Power-Cable"><a href="#ATX-Aux-Power-Cable" class="headerlink" title="ATX Aux Power Cable"></a>ATX Aux Power Cable</h2><p><img src="aux_1.png" alt="aux"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>Pin</strong></th>
<th><strong>Color</strong></th>
<th><strong>Function</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>Black</td>
<td>Ground</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>Black</td>
<td>Ground</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>Black</td>
<td>Ground</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td>Orange</td>
<td>+3.3 V</td>
</tr>
<tr>
<td><strong>5</strong></td>
<td>Orange</td>
<td>+3.3 V</td>
</tr>
<tr>
<td><strong>6</strong></td>
<td>Red</td>
<td>+5 V</td>
</tr>
</tbody>
</table>
</div>
<h2 id="ATX-4pin-12V-Power-Cable"><a href="#ATX-4pin-12V-Power-Cable" class="headerlink" title="ATX 4pin +12V Power Cable"></a>ATX 4pin +12V Power Cable</h2><p><img src="4.png" alt="4"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>Color</strong></th>
<th><strong>Function</strong></th>
<th><strong>Pin</strong></th>
<th></th>
<th><strong>Pin</strong></th>
<th><strong>Function</strong></th>
<th><strong>Color</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Black</td>
<td>Ground</td>
<td><strong>1</strong></td>
<td></td>
<td><strong>3</strong></td>
<td>+12 V</td>
<td>Yellow</td>
</tr>
<tr>
<td>Black</td>
<td>Ground</td>
<td><strong>2</strong></td>
<td></td>
<td><strong>4</strong></td>
<td>+12 V</td>
<td>Yellow</td>
</tr>
</tbody>
</table>
</div>
<h2 id="ATX-8pin-EPS-12V-Power-Cable"><a href="#ATX-8pin-EPS-12V-Power-Cable" class="headerlink" title="ATX 8pin EPS +12V Power Cable"></a>ATX 8pin EPS +12V Power Cable</h2><p><img src="8.png" alt="8"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>Color</strong></th>
<th><strong>Function</strong></th>
<th><strong>Pin</strong></th>
<th></th>
<th><strong>Pin</strong></th>
<th><strong>Function</strong></th>
<th><strong>Color</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Black</td>
<td>Ground</td>
<td><strong>1</strong></td>
<td></td>
<td><strong>5</strong></td>
<td>+12 V</td>
<td>Yellow</td>
</tr>
<tr>
<td>Black</td>
<td>Ground</td>
<td><strong>2</strong></td>
<td></td>
<td><strong>6</strong></td>
<td>+12 V</td>
<td>Yellow</td>
</tr>
<tr>
<td>Black</td>
<td>Ground</td>
<td><strong>3</strong></td>
<td></td>
<td><strong>7</strong></td>
<td>+12 V</td>
<td>Yellow</td>
</tr>
<tr>
<td>Black</td>
<td>Ground</td>
<td><strong>4</strong></td>
<td></td>
<td><strong>8</strong></td>
<td>+12 V</td>
<td>Yellow</td>
</tr>
</tbody>
</table>
</div>
<p>你可以把一个8pin的EPS线缆插到一个4pin 12V的主板上。<br>你也可以把一个4pin 12V的电源线插到一个8pin EPS主板连接器上，但是不能保证它能正常工作。</p>
<h2 id="6-8pin-PCI-Express-Power-Cable"><a href="#6-8pin-PCI-Express-Power-Cable" class="headerlink" title="6/8pin PCI Express Power Cable"></a>6/8pin PCI Express Power Cable</h2><p><img src="6.png" alt="6"><img src="8_1.png" alt="8_1"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>Color</strong></th>
<th><strong>Function</strong></th>
<th><strong>Pin</strong></th>
<th></th>
<th><strong>Pin</strong></th>
<th><strong>Function</strong></th>
<th><strong>Color</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Yellow</td>
<td>+12 V</td>
<td><strong>1</strong></td>
<td></td>
<td><strong>5</strong></td>
<td>Ground</td>
<td>Black</td>
</tr>
<tr>
<td>Yellow</td>
<td>+12 V</td>
<td><strong>2</strong></td>
<td></td>
<td><strong>6</strong></td>
<td>Ground</td>
<td>Black</td>
</tr>
<tr>
<td>Yellow</td>
<td>+12 V</td>
<td><strong>3</strong></td>
<td></td>
<td><strong>7</strong></td>
<td>Ground</td>
<td>Black</td>
</tr>
<tr>
<td>Black</td>
<td>Ground</td>
<td><strong>4</strong></td>
<td></td>
<td><strong>8</strong></td>
<td>Ground</td>
<td>Black</td>
</tr>
</tbody>
</table>
</div>
<p>6p 引脚连接器最大输出功率:75w<br>8p 引脚连接器最大输出功率:150 W</p>
<h2 id="ATX-Tolerance"><a href="#ATX-Tolerance" class="headerlink" title="ATX Tolerance"></a>ATX Tolerance</h2><div class="table-container">
<table>
<thead>
<tr>
<th><strong>Volt</strong></th>
<th><strong>Tolerance</strong></th>
<th><strong>Range</strong></th>
<th><strong>Ripple max</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>+5 VDC</td>
<td>±5% (±0.25   V)</td>
<td>+4.75 V to +5.25 V</td>
<td>50 mV</td>
</tr>
<tr>
<td>-5 VDC</td>
<td>±10% (±0.50   V)</td>
<td>-4.50 V to -5.50 V</td>
<td>50 mV</td>
</tr>
<tr>
<td>+12 VDC</td>
<td>±5% (±0.60   V)</td>
<td>+11.40 V to +12.60 V</td>
<td>120 mV</td>
</tr>
<tr>
<td>-12 VDC</td>
<td>±10% (±1.2   V)</td>
<td>-10.8 V to -13.2 V</td>
<td>120 mV</td>
</tr>
<tr>
<td>+3.3 VDC</td>
<td>±5% (±0.165   V)</td>
<td>+3.135 V to +3.465 V</td>
<td>50 mV</td>
</tr>
<tr>
<td>+5 VSB</td>
<td>±5% (±0.25   V)</td>
<td>+4.75 V to +5.25 V</td>
<td>50 mV</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>常用资料</category>
      </categories>
      <tags>
        <tag>常用资料</tag>
      </tags>
  </entry>
  <entry>
    <title>Allegro修改shape网络</title>
    <url>/2018/05/13/Allegro%E4%BF%AE%E6%94%B9shape%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h6 id="Allegro修改shape网络节点"><a href="#Allegro修改shape网络节点" class="headerlink" title="Allegro修改shape网络节点"></a>Allegro修改shape网络节点</h6><p>使用Allegro时修改shape的网络节点方法：</p>
<p>①选择shape-&gt;Select Shape or Void/Cavity</p>
<p>   <img src="fig1" alt="img"></p>
<p>②选择要修改的shape</p>
<p>③点击（…）修改网络节点的名字</p>
<p>   <img src="fig2" alt="img"></p>
<p>④修改完成</p>
]]></content>
      <categories>
        <category>PCB相关</category>
        <category>Cadence</category>
        <category>Allegro小技巧</category>
      </categories>
      <tags>
        <tag>PCB</tag>
        <tag>Allegro</tag>
      </tags>
  </entry>
  <entry>
    <title>Allegro相同模块布局克隆</title>
    <url>/2018/06/19/Allegro%E7%9B%B8%E5%90%8C%E6%A8%A1%E5%9D%97%E5%B8%83%E5%B1%80%E5%85%8B%E9%9A%86/</url>
    <content><![CDATA[<h1 id="Allegro16-6-相同模块布局克隆"><a href="#Allegro16-6-相同模块布局克隆" class="headerlink" title="Allegro16.6  相同模块布局克隆"></a>Allegro16.6  相同模块布局克隆</h1><h3 id="1-布局好其中一个模块，如下图"><a href="#1-布局好其中一个模块，如下图" class="headerlink" title="1:布局好其中一个模块，如下图"></a>1:布局好其中一个模块，如下图</h3><p><img src="1.png" alt="1"></p>
<h3 id="2-将另一个模块的所有器件选中-右键，application-mode-gt-placement-Edit"><a href="#2-将另一个模块的所有器件选中-右键，application-mode-gt-placement-Edit" class="headerlink" title="2:将另一个模块的所有器件选中,右键，application mode -&gt; placement Edit"></a>2:将另一个模块的所有器件选中,右键，application mode -&gt; placement Edit</h3><p><img src="2.png" alt="2"></p>
<h3 id="3-选择之前画好的器件-右键-选择place-replicate-create"><a href="#3-选择之前画好的器件-右键-选择place-replicate-create" class="headerlink" title="3:选择之前画好的器件,右键,选择place replicate create"></a>3:选择之前画好的器件,右键,选择place replicate create</h3><p><img src="3.png" alt="3"></p>
<p>4:再次右键,选择 Done</p>
<p><img src="4.png" alt="4"></p>
<h3 id="5-选中布局好的元件，弹出以下对话框，输入任意名字保存，这里输入2-mdd"><a href="#5-选中布局好的元件，弹出以下对话框，输入任意名字保存，这里输入2-mdd" class="headerlink" title="5:选中布局好的元件，弹出以下对话框，输入任意名字保存，这里输入2.mdd"></a>5:选中布局好的元件，弹出以下对话框，输入任意名字保存，这里输入2.mdd</h3><p><img src="5.png" alt="5"></p>
<h3 id="6-选中所有需要布局的元件，右键，选择place-relicate-apply-gt-2"><a href="#6-选中所有需要布局的元件，右键，选择place-relicate-apply-gt-2" class="headerlink" title="6:选中所有需要布局的元件，右键，选择place relicate apply -&gt; 2"></a>6:选中所有需要布局的元件，右键，选择place relicate apply -&gt; 2</h3><p><img src="6.png" alt="6"></p>
<h3 id="7-这样就好了"><a href="#7-这样就好了" class="headerlink" title="7:这样就好了"></a>7:这样就好了</h3><p><img src="7.png" alt="7"></p>
]]></content>
      <categories>
        <category>PCB相关</category>
        <category>Cadence</category>
        <category>Allegro小技巧</category>
      </categories>
      <tags>
        <tag>PCB</tag>
        <tag>Allegro</tag>
      </tags>
  </entry>
  <entry>
    <title>Ethernet EIA/TIA-568A/B</title>
    <url>/2020/04/04/Ethernet-EIA-TIA-568A-B/</url>
    <content><![CDATA[<h2 id="Ethernet-EIA-TIA-568A-B"><a href="#Ethernet-EIA-TIA-568A-B" class="headerlink" title="Ethernet EIA/TIA-568A/B"></a>Ethernet EIA/TIA-568A/B</h2><p><img src="A1.png" alt="A1"><img src="B1.png" alt="B1"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>pin</th>
<th>Pair</th>
<th><strong>Pair</strong></th>
<th>Signal</th>
<th>Signal</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><strong>T568A</strong></td>
<td><strong>T568B</strong></td>
<td><strong>10/100Base-T</strong></td>
<td><strong>1000Base-T</strong></td>
<td><strong>Wire</strong></td>
<td><strong>T568A</strong></td>
<td><strong>T568B</strong></td>
</tr>
<tr>
<td>1</td>
<td>3</td>
<td>2</td>
<td>TX+</td>
<td>BI_DA+</td>
<td>+/tip</td>
<td>绿白<img src="GW.png" alt="GW.png"></td>
<td>橙白<img src="YW.png" alt="YW.png"></td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>2</td>
<td>TX-</td>
<td>BI_DA-</td>
<td>-/ring</td>
<td>绿<img src="G.png" alt="G.png"></td>
<td>橙<img src="Y.png" alt="Y.png"></td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>3</td>
<td>RX+</td>
<td>BI_DB+</td>
<td>+/tip</td>
<td>橙白<img src="YW.png" alt="YW.png"></td>
<td>绿白<img src="GW.png" alt="GW.png"></td>
</tr>
<tr>
<td>4</td>
<td>1</td>
<td>1</td>
<td></td>
<td>BI_DC+</td>
<td>-/ring</td>
<td>蓝<img src="B.png" alt="B.png"></td>
<td>蓝<img src="B.png" alt="B.png"></td>
</tr>
<tr>
<td>5</td>
<td>1</td>
<td>1</td>
<td></td>
<td>BI_DC-</td>
<td>+/tip</td>
<td>蓝白<img src="BW.png" alt="BW.png"></td>
<td>蓝白<img src="BW.png" alt="BW.png"></td>
</tr>
<tr>
<td>6</td>
<td>2</td>
<td>3</td>
<td>RX-</td>
<td>BI_DB-</td>
<td>-/ring</td>
<td>橙<img src="Y.png" alt="Y.png"></td>
<td>绿<img src="G.png" alt="G.png"></td>
</tr>
<tr>
<td>7</td>
<td>4</td>
<td>4</td>
<td></td>
<td>BI_DD+</td>
<td>+/tip</td>
<td>棕白<img src="BRW.png" alt="BRW.png"></td>
<td>棕白<img src="BRW.png" alt="BRW.png"></td>
</tr>
<tr>
<td>8</td>
<td>4</td>
<td>4</td>
<td></td>
<td>BI_DD-</td>
<td>-/ring</td>
<td>棕<img src="BR.png" alt="BR.png"></td>
<td>棕<img src="BR.png" alt="BR.png"></td>
</tr>
</tbody>
</table>
</div>
<h2 id="Direct-Connection-EIA-TIA-568A"><a href="#Direct-Connection-EIA-TIA-568A" class="headerlink" title="Direct Connection EIA/TIA-568A"></a>Direct Connection EIA/TIA-568A</h2><p><img src="A1.png" alt="A1.png"><img src="A2.png" alt="A2.png"></p>
<h2 id="Direct-Connection-EIA-TIA-568B"><a href="#Direct-Connection-EIA-TIA-568B" class="headerlink" title="Direct Connection EIA/TIA-568B"></a>Direct Connection EIA/TIA-568B</h2><p><img src="A1.png" alt="B1.png"><img src="A2.png" alt="B2.png"></p>
<h2 id="Cross-over-cable-pinouts"><a href="#Cross-over-cable-pinouts" class="headerlink" title="Cross-over cable pinouts"></a>Cross-over cable pinouts</h2><h3 id="Cross-over-cable-EIA-TIA-568A-B-10Base-T-100Base-TX"><a href="#Cross-over-cable-EIA-TIA-568A-B-10Base-T-100Base-TX" class="headerlink" title="Cross-over cable EIA/TIA-568A/B (10Base-T, 100Base-TX)"></a>Cross-over cable EIA/TIA-568A/B (10Base-T, 100Base-TX)</h3><p><img src="B1.png" alt="B1.png">   <img src="A2.png" alt="A2.png"></p>
]]></content>
  </entry>
  <entry>
    <title>Hexo创建新页面</title>
    <url>/2018/01/07/Hexo%E5%88%9B%E5%BB%BA%E6%96%B0%E9%A1%B5%E9%9D%A2/</url>
    <content><![CDATA[<p>命令行键入：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page about</span><br></pre></td></tr></table></figure></p>
<p>会在source/about中生成index.html。这个就叫做页面，不在文章列表显示，可以通过<a href="http://localhost/about浏览。" target="_blank" rel="noopener">http://localhost/about浏览。</a><br>页面支持文章的大部分属性，除了分类和标签。</p>
]]></content>
      <categories>
        <category>Hexo教程</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo删除文章</title>
    <url>/2018/01/07/Hexo%E5%88%A0%E9%99%A4%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>首先将要删除的文章删除，然后把db.json删除掉 ，再执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure></p>
<p>执行上述命令会请空public文件夹下所有文件<br>然后再<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure></p>
<p>重新生成</p>
]]></content>
      <categories>
        <category>Hexo教程</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo教程之MathJax公式渲染问题</title>
    <url>/2018/01/08/Hexo%E6%95%99%E7%A8%8B%E4%B9%8BMathJax%E5%85%AC%E5%BC%8F%E6%B8%B2%E6%9F%93%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>今天在写一篇博客的时候，遇到使用MathJax公式下标出现问题，然后在网上找到解决办法</p>
<h1 id="出现问题的原因"><a href="#出现问题的原因" class="headerlink" title="出现问题的原因"></a>出现问题的原因</h1><p>hexo默认使用hexo-renderer-marked引擎去渲染网页，它会把利用Markdown语法写的文本去转换为相应的html标签。在利用Markdown写MathJax公式的时候，经常会用到下划线<code>_</code>表示下标，但是下划线<code>_</code>会被hexo的默认引擎hexo-renderer-marked渲染成html中的<code>&lt;em&gt;</code>标签，表示斜体，这样一来，我们写的MathJax公式就被错误渲染了，也就没办法正确显示出来。</p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>从上面的分析，我们可以知道问题或许出在hexo的渲染引擎上，如果渲染引擎不把公式中的一些特殊字符渲染成html标签，也就避免了这个问题。当然已经有人意识到了这个问题，并且对原先的渲染引擎进行了改进，生成了新的<code>hexo-renderer-kramed</code>引擎，这里是它的Github页面，所以我们只需要卸载默认引擎，并安装这个新的渲染引擎即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure>
<p>当我把渲染引擎更换之后，发现大部分公式都正确渲染了，而从网上其他人的叙述中，也同样提到了这个问题，即是行间公式都没有问题，但是个别行内公式还会出现渲染出错，从网上找到了一个方法，解决了这一问题。<br>定位到你的博客根目录，找到../node_modules/kramed/lib/rules/inline.js文件，<br>进行部分修改：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//escape: /^\\([\\`*&#123;&#125;\[\]()<span class="comment">#$+\-.!_&gt;])/,      第11行，将其修改为</span></span><br><span class="line">escape: /^\\([`*\[\]()<span class="comment">#$+\-.!_&gt;])/,</span></span><br><span class="line">//em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,    第20行，将其修改为</span><br><span class="line">em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br></pre></td></tr></table></figure></p>
<p>它取消了该渲染引擎对 <strong>\,{,}</strong> 的转义，然后再<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure></p>
<p>重新部署，即可解决问题。</p>
<p>另外需要注意一点，对于需要用到MathJax公式的文章，要在Front-matter中打开MathJax开关，例如：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">date: 2017/8/3 18:20:00</span><br><span class="line">tags: hexo</span><br><span class="line">mathjax: <span class="literal">true</span></span><br><span class="line">title: hexo博客MathJax公式渲染</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p>
<h1 id="MathJax公式语法"><a href="#MathJax公式语法" class="headerlink" title="MathJax公式语法"></a>MathJax公式语法</h1><p><a href="lshort-zh-cn.pdf">LaTeX语法</a><br>下面呢，我整理总结了一番比较常用的MathJax公式语法，同时也可以用来测试一下渲染效果。</p>
<h2 id="gt-添加公式的方法"><a href="#gt-添加公式的方法" class="headerlink" title="&gt;添加公式的方法"></a>&gt;添加公式的方法</h2><h3 id="1-行内公式"><a href="#1-行内公式" class="headerlink" title="1.行内公式"></a>1.行内公式</h3><pre><code>$行内公式$
</code></pre><h3 id="2-行间公式"><a href="#2-行间公式" class="headerlink" title="2.行间公式"></a>2.行间公式</h3><pre><code>$$行间公式$$
</code></pre><h2 id="gt-常用的MathJax公式语法"><a href="#gt-常用的MathJax公式语法" class="headerlink" title="&gt;常用的MathJax公式语法"></a>&gt;常用的MathJax公式语法</h2><div class="table-container">
<table>
<thead>
<tr>
<th>符号</th>
<th style="text-align:center">释义</th>
<th style="text-align:left">测试用例</th>
<th style="text-align:left">最终效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>^\{}</td>
<td style="text-align:center">上标</td>
<td style="text-align:left">x^{y^z}=(1+e^x)^{-2xy^w}</td>
<td style="text-align:left">$x^{y^z}=(1+e^x)^{-2xy^w}$</td>
</tr>
<tr>
<td>_\{}</td>
<td style="text-align:center">下标</td>
<td style="text-align:left">CO_2</td>
<td style="text-align:left">$CO_2$</td>
</tr>
<tr>
<td>\frac{分子}{分母} or 分子 \over 分母</td>
<td style="text-align:center">分数</td>
<td style="text-align:left">f(x,y,z)=3y^2z(3+\frac{7x+5}{1+y^2})</td>
<td style="text-align:left">$f(x,y,z)=3y^2z(3+\frac{7x+5}{1+y^2})$</td>
</tr>
<tr>
<td>\sqrt[根指数，省略时为2]{被开方数}</td>
<td style="text-align:center">开方</td>
<td style="text-align:left">\sqrt{2}、\sqrt[3]{9}</td>
<td style="text-align:left">$\sqrt{2}$ $\sqrt[3]{9}$</td>
</tr>
<tr>
<td>\ldots</td>
<td style="text-align:center">与文本底线对齐的省略号</td>
<td style="text-align:left">x_1x_2{\ldots}x_n</td>
<td style="text-align:left">$x_1x_2{\ldots}x_n$</td>
</tr>
<tr>
<td>\cdots</td>
<td style="text-align:center">与文本中线对齐的省略号</td>
<td style="text-align:left">x_1x_2{\cdots}x_n</td>
<td style="text-align:left">$x_1x_2{\cdots}x_n$</td>
</tr>
<tr>
<td>\int_积分下限^积分上限(被积表达式)</td>
<td style="text-align:center">积分</td>
<td style="text-align:left">\int_1^n{x^2}dx</td>
<td style="text-align:left">$\int_1^n{x^2}dx$</td>
</tr>
<tr>
<td>\sum_{下标表达式}^{上标表达式} {累加表达式}</td>
<td style="text-align:center">累加</td>
<td style="text-align:left">\sum_{i=1}^n \frac{1}{i^2}</td>
<td style="text-align:left">$\sum_{i=1}^n \frac{1}{i^2}$</td>
</tr>
<tr>
<td>\, or ; or \quad or \qquad</td>
<td style="text-align:center">不同宽度的空格</td>
<td style="text-align:left">a , b \mid a ; b \mid a \quad b \mid a</td>
<td style="text-align:left">$\qquad b    a,b∣a;b∣ab∣aba,b∣a;b∣ab∣ab$</td>
</tr>
<tr>
<td>\color{颜色}{文字}</td>
<td style="text-align:center">更改文字颜色</td>
<td style="text-align:left">\color{red}{红色}</td>
<td style="text-align:left">$\color{red}{红色}$</td>
</tr>
</tbody>
</table>
</div>
<p>上面的一些基本语法使用了行内公式， 渲染效果没有问题，下面再利用行间公式写一些较为复杂的公式。</p>
<h3 id="分段函数"><a href="#分段函数" class="headerlink" title="分段函数"></a>分段函数</h3><p>分段函数格式为<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">f(x)=\begin&#123;cases&#125;语句1\\语句2\\...\end&#123;cases&#125;</span><br></pre></td></tr></table></figure></p>
<p>\text{文字}中仍可以使用$公式$去插入其他公式，所以可以将其结合分段函数一起使用。</p>
<p>实例：<br>md文本<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> $$ </span><br><span class="line">f(n)=\begin&#123;cases&#125;</span><br><span class="line">n/2, &amp; \text&#123;如果$ x&lt;=2 $&#125;\\</span><br><span class="line">3n+1, &amp; \text&#123;如果$ x&gt;2 $&#125;</span><br><span class="line">\end&#123;cases&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure></p>
<p>最终效果:</p>
<script type="math/tex; mode=display">
f(n)=\begin{cases}
n/2, & \text{如果$ x<=2 $}\\
3n+1, & \text{如果$ x>2 $}
\end{cases}</script><h3 id="大括号和小括号"><a href="#大括号和小括号" class="headerlink" title="大括号和小括号"></a>大括号和小括号</h3><p>()、[]、{}表示的即是符号本身，使用\{\}来表示{}。但是如果要显示大号的括号时，需要使用\left和\right命令。</p>
<p>实例：</p>
<p>正常括号<br>md文本<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> $$</span><br><span class="line">f([\frac&#123;1+\&#123;x,y\&#125;&#125;&#123;(\frac&#123;x&#125;&#123;y&#125;+\frac&#123;y&#125;&#123;x&#125;)(u+1)&#125;+a]^&#123;3\2&#125;)</span><br><span class="line">$$</span><br></pre></td></tr></table></figure></p>
<p>最终效果</p>
<script type="math/tex; mode=display">
f([\frac{1+\{x,y\}}{(\frac{x}{y}+\frac{y}{x})(u+1)}+a]^{3\2})</script><p>大括号<br>md文本<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">    $$</span><br><span class="line">f\left(</span><br><span class="line">    \left[</span><br><span class="line">        \frac&#123;</span><br><span class="line">            1+\left\&#123;x,y\right\&#125;</span><br><span class="line">        &#125;&#123;</span><br><span class="line">        \left(</span><br><span class="line">            \frac&#123;x&#125;&#123;y&#125;+\frac&#123;y&#125;&#123;x&#125;</span><br><span class="line">        \right)</span><br><span class="line">        \left(u+1\right)</span><br><span class="line">        &#125;+a</span><br><span class="line">    \right]^&#123;3\2&#125;</span><br><span class="line">\right)</span><br><span class="line">$$</span><br></pre></td></tr></table></figure></p>
<p>最终效果</p>
<script type="math/tex; mode=display">
f\left(
    \left[
        \frac{
            1+\left\{x,y\right\}
        }{
        \left(
            \frac{x}{y}+\frac{y}{x}
        \right)
        \left(u+1\right)
        }+a
    \right]^{3\2}
\right)</script><h3 id="添加删除线"><a href="#添加删除线" class="headerlink" title="添加删除线"></a>添加删除线</h3><p>使用删除线功能必须使用行间公式，删除线分为片段删除线和整段删除线，样式比较多，在这里我只列举一种比较常用的水平删除线，它属于整段删除线的一种。</p>
<p>整段删除线使用<code>\require{enclose}</code>来显示，声明整段删除线后，使用<code>\enclose{删除线效果}{字符}</code>来实现删除线效果，而水平删除线效果用关键字horizontalstrike。</p>
<p>实例：</p>
<p>md文本<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\require&#123;enclose&#125;\begin&#123;array&#125;&#123;&#125;</span><br><span class="line">\enclose&#123;horizontalstrike&#125;&#123;x+y&#125;\\</span><br><span class="line">\enclose&#123;horizontalstrike&#125;&#123;x*y&#125;\\</span><br><span class="line">\end&#123;array&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure></p>
<p>最终效果</p>
<script type="math/tex; mode=display">
\require{enclose}\begin{array}{}
\enclose{horizontalstrike}{x+y}\\
\enclose{horizontalstrike}{x*y}\\
\end{array}</script><h3 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h3><p><code>\begin{align}</code>用于开头，<code>\end{align}</code>用于结尾，对齐的位置用<code>&amp;</code>开始，用<code>\\</code>结束<br>输入：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;align&#125;</span><br><span class="line">f(x) &amp;=a+b+a\\</span><br><span class="line">&amp; = 2a+b</span><br><span class="line">\end&#123;align&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure></p>
<p>输出： </p>
<script type="math/tex; mode=display">
\begin{align}
f(x) &=a+b+a\\
& = 2a+b
\end{align}</script>]]></content>
      <categories>
        <category>Hexo教程</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo新建文章</title>
    <url>/2019/09/30/Hexo%E6%96%B0%E5%BB%BA%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>新建一篇博客，在cmd执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new post “博客名”</span><br></pre></td></tr></table></figure>
<p>这时候在文件夹_posts目录下将会看到已经创建的文件<br>使用编辑器编好文章，那么就可以使用命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Hexo教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>MQTT代理之Mosquitto-centos环境下搭建</title>
    <url>/2020/03/29/MQTT%E4%BB%A3%E7%90%86%E4%B9%8BMosquitto-centos%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>Mosquitto是一个实现了MQTT3.1协议的代理服务器，由MQTT协议创始人之一的Andy Stanford-Clark开发，它为我们提供了非常棒的轻量级数据交换的解决方案。本文的主旨在于记录Mosquitto服务的安装和使用，以备日后查阅。</p>
<p><strong>获取&amp;安装</strong> </p>
<p>在Linux系统上安装Mosquitto，本人建议大家使用源码安装模式，最新的源码可从 <a href="http://mosquitto.org/files/source/" target="_blank" rel="noopener">http://mosquitto.org/files/source/</a> 地址中获取。解压之后，我们可以在源码目录里面找到主要的配置文件config.mk，其中包含了所有Mosquitto的安装选项，详细的参数说明如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 是否支持tcpd/libwrap功能.</span><br><span class="line">WITH_WRAP:=yes</span><br><span class="line"># 是否开启SSL/TLS支持</span><br><span class="line">WITH_TLS:=yes</span><br><span class="line"># 是否开启TLS/PSK支持</span><br><span class="line">WITH_TLS_PSK:=yes</span><br><span class="line"># Comment out to disable client client threading support.</span><br><span class="line">WITH_THREADING:=yes</span><br><span class="line"># 是否使用严格的协议版本（老版本兼容会有点问题）</span><br><span class="line">WITH_STRICT_PROTOCOL:=yes</span><br><span class="line"># 是否开启桥接模式</span><br><span class="line">WITH_BRIDGE:=yes</span><br><span class="line"># 是否开启持久化功能</span><br><span class="line">WITH_PERSISTENCE:=yes</span><br><span class="line"># 是否监控运行状态</span><br><span class="line">WITH_MEMORY_TRACKING:=yes</span><br></pre></td></tr></table></figure>
<p>由于是测试环境，所以关闭SSL/TLS</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 是否开启SSL/TLS支持</span><br><span class="line">#WITH_TLS:=yes</span><br><span class="line"># 是否开启TLS/PSK支持</span><br><span class="line">#WITH_TLS_PSK:=yes</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>物联网相关</category>
        <category>服务器端相关</category>
      </categories>
      <tags>
        <tag>物联网</tag>
        <tag>服务器操作</tag>
        <tag>数据采集</tag>
        <tag>linux</tag>
        <tag>MQTT</tag>
      </tags>
  </entry>
  <entry>
    <title>MQTT代理之mosquitto-配置SSL/TLS</title>
    <url>/2020/03/30/MQTT%E4%BB%A3%E7%90%86%E4%B9%8Bmosquitto-%E9%85%8D%E7%BD%AESSL-TLS/</url>
    <content><![CDATA[<p>在服务器电脑上面创建myCA文件夹, 如在/home/qa/ 文件夹下使用命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir myCA</span><br></pre></td></tr></table></figure>
<p>然后执行以下命令，我们将创建并使用其他用户没有权限访问的目录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo chmod 700 </span><br><span class="line">cd myCA</span><br></pre></td></tr></table></figure>
<p>进入myCA文件夹，然后执行以下命令下载生成证书用的脚本。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https://github.com/owntracks/tools/raw/master/TLS/generate-CA.sh</span><br></pre></td></tr></table></figure>
<p>下载完之后，在myCA文件夹下面执行命令</p>
<p>注：在生产环境中使用此实例之前，你应该定制the generate-CA.sh脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash ./generate-CA.sh</span><br></pre></td></tr></table></figure>
<p>generate-CA.sh会产生3个文件：ca.crt，ca.key，ca.csr分别为: 证书（.CRT），钥匙（.KEY），请求（.csr文件），这三个文件是给服务器使用的</p>
<p>在myCA文件夹下面执行命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash ./generate-CA.sh client myclient</span><br></pre></td></tr></table></figure></p>
<p>其中myclient是给客户端生成证书的名称，可随意更改。执行完上述命令后，会新生成几个文件。</p>
<p>客户端需要使用的是ca.crt/myclient.crt/myclient.key这三个文件。</p>
<p>经过上述步骤之后，生成了服务器使用的ca.crt/localhost.crt/localhost.key文件和客户端使用的</p>
<p>ca.crt/myclient.crt/myclient.key这几个文件，其中ca.crt是同一个文件。</p>
<p>配置mosquitto.conf文件。该文件在mosquitto-1.4.11安装文件夹里面，打开该文件，修改成如下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">port 8883   </span><br><span class="line">protocol mqtt    </span><br><span class="line">cafile /home/myCA/ubuntu/ca.crt    </span><br><span class="line">certfile /home/myCA/ubuntu/localhost.crt    </span><br><span class="line">keyfile /home/myCA/ubuntu/localhost.key</span><br><span class="line">require_certificate true</span><br><span class="line">use_identity_as_username true</span><br></pre></td></tr></table></figure>
<p>修改完配置文件之后，执行启动命令mosquitto -c /home/qa/mosquitto-1.4.11/mosquitto.conf -v　　</p>
<p> 根据自己的mosquitto-conf文件所在的位置修改上述命令中的参数，然后服务器就以SSL/TSL的方式开始启动。</p>
<p>  此时客户端使用上述过程产生的客户端证书连接该服务器，即可进行通信。</p>
]]></content>
      <categories>
        <category>物联网相关</category>
        <category>服务器端相关</category>
      </categories>
      <tags>
        <tag>物联网</tag>
        <tag>服务器操作</tag>
        <tag>数据采集</tag>
        <tag>linux</tag>
        <tag>MQTT</tag>
      </tags>
  </entry>
  <entry>
    <title>MQTT客户端设计之ESP8266</title>
    <url>/2018/01/12/MQTT%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AE%BE%E8%AE%A1%E4%B9%8BESP8266/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>MQTT是IBM开发的一个即时通讯协议，面向M2M和物联网的连接，采用轻量级发布和订阅消息传输机制，并且有可能成为物联网的重要组成部分。</p>
<p>ESP8266是一款物美价廉的Wi-Fi芯片，集成Tensilica L106 钻石系列的32 位处理器和片上SRAM，多达17 个GPIO口，并拥有IIC、IIS、UART、PWM、IR遥控等片上资源。</p>
<p>ESP8266还提供官方的软件开发开发包（SDK），目前最新版本是「ESP8266 NONOS SDK V2.2.0」。</p>
<p>这篇文章主要讲解如何使用ESP8266作为MQTT客户端，并连上在本地电脑搭建的MQTT服务器。</p>
<h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><p>首先简单说明一下博主的开发环境：</p>
<ul>
<li>ESP8266开发环境：<a href="https://pan.baidu.com/s/1skRvR1j#list/path=%2F%E5%AE%89%E4%BF%A1%E5%8F%AFESP%E7%B3%BB%E5%88%97%E6%96%B0IDE" target="_blank" rel="noopener">ESP8266 IDE 2.0</a></li>
<li>ESP8266 SDK版本：<a href="https://github.com/espressif/ESP8266_NONOS_SDK/releases/tag/v2.2.0" target="_blank" rel="noopener">ESP8266 NONOS SDK V2.2.0</a></li>
<li>MQTT服务器：Apollo 1.7.1（本地搭建）</li>
<li>操作系统：64位 Win10系统</li>
<li>ESP8266开发板：NodeMCU（4MB Flash）</li>
</ul>
<h1 id="导入工程"><a href="#导入工程" class="headerlink" title="导入工程"></a>导入工程</h1><p>如果读者和博主使用的开发环境一样，那么步骤1~4就好理解了，不是的话直接看图片和步骤5：</p>
<ol>
<li>在IDE环境中通过「File」-&gt;「Import」；</li>
<li>弹窗中选择「C/C++」-&gt;「Existing Code as Makefile project」；</li>
<li>下一步「Browse…」，编译器选择「Cygwin GCC」；</li>
<li>之后导入的工程目录如上图，其中给「dirver_lib」文件下面的Makeflie添加bak后缀或删除掉，免得编译通不过。</li>
<li>从「example」文件夹中拷贝<strong>esp_mqtt_proj</strong>文件夹到主目录，点击编译按钮，如果成功就完成这一步骤了。</li>
</ol>
<p><img src="20161108213930131.png" alt="img"></p>
<p>工程目录</p>
<p>工程目录图</p>
<h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><p><img src="20161108214816252.png" alt="img"></p>
<p>mqtt例程目录</p>
<p>user_main.c</p>
<p>mqtt_config.h</p>
<p>其中user_main.c不用说了，玩过ESP8266的朋友都知道这是放主代码的地方，其中<strong>user_init</strong>函数是SDK提供开发者放置初始化代码的地方。下面主要分析mqtt_config.h。</p>
<p><code>mqtt_config.h</code>代码清单</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#ifndef __MQTT_CONFIG_H__</span></span><br><span class="line"><span class="comment">#define __MQTT_CONFIG_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define CFG_HOLDER  0x00FF55A4  /* Change this value to load default configurations */</span></span><br><span class="line"><span class="comment">#define CFG_LOCATION    0x79    /* Please don't change or if you know what you doing */</span></span><br><span class="line"><span class="comment">#define MQTT_SSL_ENABLE</span></span><br><span class="line"></span><br><span class="line">/*DEFAULT CONFIGURATIONS*/</span><br><span class="line"></span><br><span class="line"><span class="comment">#define MQTT_HOST           "192.168.1.100" //or "mqtt.yourdomain.com"</span></span><br><span class="line"><span class="comment">#define MQTT_PORT           1883</span></span><br><span class="line"><span class="comment">#define MQTT_BUF_SIZE       1024</span></span><br><span class="line"><span class="comment">#define MQTT_KEEPALIVE      120  /*second*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define MQTT_CLIENT_ID      "DVES_%08X"</span></span><br><span class="line"><span class="comment">#define MQTT_USER           "DVES_USER"</span></span><br><span class="line"><span class="comment">#define MQTT_PASS           "DVES_PASS"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define STA_SSID "DVES_HOME"</span></span><br><span class="line"><span class="comment">#define STA_PASS "yourpassword"</span></span><br><span class="line"><span class="comment">#define STA_TYPE AUTH_WPA2_PSK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define MQTT_RECONNECT_TIMEOUT  5   /*second*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define DEFAULT_SECURITY    0</span></span><br><span class="line"><span class="comment">#define QUEUE_BUFFER_SIZE               2048</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define PROTOCOL_NAMEv31    /*MQTT version 3.1 compatible with Mosquitto v0.15*/</span></span><br><span class="line">//PROTOCOL_NAMEv311         /*MQTT version 3.11 compatible with https://eclipse.org/paho/clients/testing/*/</span><br><span class="line"></span><br><span class="line"><span class="comment">#endif // __MQTT_CONFIG_H__</span></span><br></pre></td></tr></table></figure>
<p>在这个文件中，有几个宏定义可能需要修改的</p>
<ul>
<li>MQTT_HOST，MQTT服务器地址</li>
<li>MQTT_PORT，MQTT服务器端口</li>
<li>MQTT_USER，MQTT服务器用户名</li>
<li>MQTT_PASS，MQTT服务器密码</li>
<li>STA_SSID，WI-FI帐号</li>
<li>STA_PASS，WI-FI密码</li>
</ul>
<p>还有一个最重要的宏定义——<strong>CFG_HOLDER</strong>，因为这个MQTT示例在ESP8266运行过一次后会把这些信息保存到FLASH中，如果要继续修改这些信息，记得要修改CFG_HOLDER这个宏定义，改成另一个数值即可。</p>
<p>CFG_HOLDER作的用是：在<code>CFG_Load</code>函数中，如果发现从FLASH读取出来的<code>CFG_HOLDER</code>数值和宏定义的不一样，则会更新这些信息，并保存到FLASH中。不修改<code>CFG_HOLDER</code>的话可能会发觉明明用户名和密码都正确但是就是连接不上去。</p>
<h1 id="修改代码及测试"><a href="#修改代码及测试" class="headerlink" title="修改代码及测试"></a>修改代码及测试</h1><h2 id="修改代码"><a href="#修改代码" class="headerlink" title="修改代码"></a>修改代码</h2><p>根据上面分析，下面我们就可以修改示例代码：</p>
<ol>
<li>把<strong>STA_SSID</strong>和<strong>STA_PASS</strong>修改为自己的WiFI名和密码；</li>
<li>修改<strong>MQTT_USER</strong>和<strong>MQTT_PASS</strong>为对应的MQTT服务器的用户名和密码，Apollo服务器默认是<strong>admin</strong>和<strong>password</strong>；</li>
<li>修改<strong>MQTT_HOST</strong>和<strong>MQTT_PORT</strong>为MQTT服务器IP和PORT，目前是使用本地的MQTT服务器，所以是修改为自己电脑的IP和<strong>61613</strong>端口，PORT是整型值；</li>
<li>根据MQTT服务器的协议不同，可能需要使用MQTT v3.1.1版本，所以把<strong>PROTOCOL_NAMEv31</strong>注释掉，使用<strong>PROTOCOL_NAMEv311</strong>。源码的PROTOCOL_NAMEv311前面没有#define，自己加上就行。</li>
<li>最后，修改<strong>CFG_HOLDER</strong>，以让这些配置生效，直接给原来CFG_HOLDER定义的数值加1即可。</li>
</ol>
<p><img src="20161120151611152.png" alt="img"></p>
<p>修改示例配置</p>
<h2 id="编译下载"><a href="#编译下载" class="headerlink" title="编译下载"></a>编译下载</h2><p>编译，查看<strong>Console</strong>窗口，如果输出</p>
<p><img src="20161120152602774.png" alt="img"></p>
<p>编译信息</p>
<p>那说明代码已经编译成功。另外要注意，ESP8266 SDK v2.0以后版本生成的<strong>eagle.irom0text.bin</strong>烧写起始地址是<strong>0x10000</strong>，而之前的版本烧写地址是0x40000；<strong>eagle.flash.bin</strong>还是<strong>0x00000</strong>。由于博主使用的是4MB Flash的ESP8266，所以也建议读者先确定手头的ESP8266是不是<strong>4MB Flash</strong>（即32Mbit Flash，注意单位！4MB=32Mbit，Flash一般是以bit计算！）</p>
<p>另外如果<strong>Problems</strong>窗口报<strong>Errors</strong>的，只要<strong>Console</strong>窗口编译通过，就可以不用管。</p>
<p>下载配置参考图片：</p>
<p><img src="20161202104437633.png" alt="img"></p>
<p>下载配置</p>
<p>提醒：blank.bin和default.bin烧写一次就行，另外也要留意不同的Flash大小，blank.bin和default.bin烧写地址也不同。</p>
<h2 id="上电测试"><a href="#上电测试" class="headerlink" title="上电测试"></a>上电测试</h2><p>如果前面一切顺利，打开串口，设置波特率为<strong>115200</strong>，上电后前面的乱码不用管，之后串口打印信息如下，省略了一部分信息：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; load ...</span><br><span class="line">&gt; default configuration</span><br><span class="line">&gt; MQTT_InitConnection</span><br><span class="line">&gt; MQTT_InitClient</span><br><span class="line"></span><br><span class="line">WIFI_INIT</span><br><span class="line"></span><br><span class="line">&gt; ……（省略）</span><br><span class="line"></span><br><span class="line">&gt; connected with **[你的WiFi名]**, channel 6</span><br><span class="line">&gt; dhcp client start...</span><br><span class="line">&gt; STATION_IDLE</span><br><span class="line">&gt; STATION_IDLE</span><br><span class="line">&gt; ip:**[WiFi分配给ESP8266的IP]**,mask:255.255.255.0,gw:**[WiFi网关IP]**</span><br><span class="line">&gt; TCP: Connect to ip **[MQTT服务器IP:PORT]**</span><br><span class="line">&gt; MQTT: Connected to broker **[MQTT服务器IP:PORT]**</span><br><span class="line">&gt; MQTT: Sending, <span class="built_in">type</span>: 1, id: 0000</span><br><span class="line">&gt; TCP: Sent</span><br><span class="line">&gt; TCP: data received 4 bytes</span><br><span class="line">&gt; MQTT: Connected to **[MQTT服务器IP:PORT]**</span><br><span class="line">&gt; MQTT: Connected</span><br><span class="line">&gt; MQTT: queue subscribe, topic<span class="string">"/mqtt/topic/0"</span>, id: 1</span><br><span class="line">&gt; MQTT: queue subscribe, topic<span class="string">"/mqtt/topic/1"</span>, id: 2</span><br><span class="line">&gt; MQTT: queue subscribe, topic<span class="string">"/mqtt/topic/2"</span>, id: 3</span><br><span class="line">&gt; MQTT: queuing publish, length: 23, queue size(66/2048)</span><br><span class="line">&gt; MQTT: queuing publish, length: 25, queue size(91/2048)</span><br><span class="line">&gt; MQTT: queuing publish, length: 25, queue size(118/2048)</span><br><span class="line">&gt; ……</span><br></pre></td></tr></table></figure></p>
<p>其中加粗带方括号的字段根据测试环境不同而不同。</p>
<p>同时看源码和串口信息可知，ESP8266向MQTT服务器订阅了三个主题，假设使用的是本地搭建的MQTT服务器，那么查看MQTT服务器后台就可以看到：</p>
<p><img src="20161120150133169.png" alt="img"></p>
<p>ESP8266MQTT示例代码订阅</p>
<p>同时在后台的<strong>Connects</strong>页面也可以看到ESP8266的链接：</p>
<p><img src="20161120150235107.png" alt="img"></p>
<p>ESP8266后台链接</p>
<p>MQTT本地服务器搭建教程Windows版链接在后面。</p>
<p>另外博主已经用ESP8266的MQTT连接上了OneNET云，连接该云需要<strong>注释掉</strong>下面这条语句，在<code>user_init</code>函数下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MQTT_InitLWT(&amp;mqttClient, <span class="string">"/lwt"</span>, <span class="string">"offline"</span>, 0, 0);</span><br></pre></td></tr></table></figure>
<p>原因是OneNET不支持，否则连接不上。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul>
<li>【MQTT服务器】<ul>
<li>下载地址：<a href="https://link.jianshu.com/?t=http://activemq.apache.org/apollo/download.html" target="_blank" rel="noopener">http://activemq.apache.org/apollo/download.html</a></li>
</ul>
</li>
<li>【ESP8266资料】ESP8266官网资源链接：<a href="https://link.jianshu.com/?t=http://espressif.com/zh-hans/products/hardware/esp8266ex/resources" target="_blank" rel="noopener">http://espressif.com/zh-hans/products/hardware/esp8266ex/resources</a></li>
</ul>
<hr>
]]></content>
      <categories>
        <category>物联网相关</category>
        <category>终端相关</category>
      </categories>
      <tags>
        <tag>物联网</tag>
        <tag>MQTT</tag>
        <tag>ESP8266</tag>
      </tags>
  </entry>
  <entry>
    <title>MSP430教程之创建一个CCS工程</title>
    <url>/2018/01/13/MSP430%E6%95%99%E7%A8%8B%E4%B9%8B%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AACCS%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<p>前几天花了4.3美元在TI官网买了一开MSP430FR2433 LaunchPad™ Development Kit<br>(MSPEXP430FR2433)，今天花一点时间来个简单的入门。板子很简单见下图<br> <img src="TIM截图20180113204831.png" alt="TIM截图20180113204831.png"></p>
<p>开发板自带一个调试工具和串口调试工具，性价比还是挺高的。<br>开发板的资源见下图：</p>
<p><img src="TIM截图20180113205502.png" alt="TIM截图20180113205502.png"></p>
<p>首先我们先来一个简单的点灯例程，接下来从<code>新建工程----编写点灯程序----效果演示</code>顺序开始介绍</p>
<h2 id="创建一个CCS工程"><a href="#创建一个CCS工程" class="headerlink" title="创建一个CCS工程"></a>创建一个CCS工程</h2><p>CCS其实就是eclipse安装了TI的一些开发插件，CCS的安装教程就不提了比较简单，从TI官网下载CCS，选择单片机的型号，接下来基本上是<code>下一步</code>就行了。接下来主要讲如何新建工程</p>
<p><code>File &gt; New &gt; CCS Project</code><br>具体配置如下：</p>
<ul>
<li>Target:MSP430FR2433</li>
</ul>
<ul>
<li>Project name:Hello_Led</li>
</ul>
<ul>
<li>Location:随自己的意愿</li>
</ul>
<ul>
<li><p>Project templates and examples : Empty Project(with main.c)</p>
<p><img src="TIM截图20180113193424.png" alt="FIG2"></p>
</li>
</ul>
<h2 id="开始编写自己的程序"><a href="#开始编写自己的程序" class="headerlink" title="开始编写自己的程序"></a>开始编写自己的程序</h2><p>上面我们创建好了MSP430的工程，具体如下：<br> <img src="TIM截图20180113194545.png" alt="fig3"><br>创建工程后系统已经添加好了msp430的头文件<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;msp430.h&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>当然也可以自己根据具体型号添加头文件，我用的是MSP430FR2433,所以我们可以改成<code>#include &lt;msp430fr2433.h&gt;</code>这个头文件包含了 MSP430FR2433 的寄存器定义和内置函数。<br>main函数部分，以下是闪灯的程序，也是CCS自带的示例代码<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int main(void) &#123;</span><br><span class="line">    WDTCTL = WDTPW | WDTHOLD;	    // Stop watchdog timer</span><br><span class="line">    PM5CTL0 &amp;= ~LOCKLPM5;           // Disable the GPIO power-on default high-impedance mode</span><br><span class="line">    P1DIR |= BIT0;					// Set P1.0 to output direction</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(;;) &#123;</span><br><span class="line">		volatile unsigned int i;	// volatile to prevent optimization</span><br><span class="line"></span><br><span class="line">		P1OUT ^= 0x01;				// Toggle P1.0 using exclusive-OR</span><br><span class="line"></span><br><span class="line">		i = 10000;					// SW Delay</span><br><span class="line">		<span class="keyword">do</span> i--;</span><br><span class="line">		<span class="keyword">while</span>(i != 0);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">P1DIR |= BIT0;</span><br></pre></td></tr></table></figure>
<p>这一行中,我们将 P1.0 引脚设置为输出(P1.0 与开发板上 Led1 相连)。在 MSP430 中,P1DIR 是一个控制 Port1 引脚方 向的八位寄存器。如果你把某一位配置为 0,则它作输入用,反之 是输出。BIT0 是一个系统定义的常量,即 0x0001（详见<code>&lt;msp430fr2433.h&gt;</code>）。</p>
<p>如果一切顺利的话,现在我们可以把我们的程序下载到单片机运行了。</p>
<h2 id="将程序下载到单片机"><a href="#将程序下载到单片机" class="headerlink" title="将程序下载到单片机"></a>将程序下载到单片机</h2><p> <img src="TIM截图20180113203355.png" alt="TIM截图20180113203355">编译按钮</p>
<p> <img src="TIM截图20180113203408.png" alt="TIM截图20180113203408">Debug 按钮,编译通过之后,我们按这个按钮会下载程序并进入 DEBUG 模式</p>
<p> <img src="TIM截图20180113203554.png" alt="TIM截图20180113203554">红色按钮终止 DEBUG 模式</p>
<p>LED 程序已经下载到单片机中,如果你观察到红色的 LED 灯会随着按键亮灭,那么恭喜你,你已经完成了第一 个 MSP430的项目。</p>
<center>
<iframe height="498" width="510" src="http://player.youku.com/embed/XMzMxNTg1NjM2MA==" frameborder="0" 'allowfullscreen'></iframe>
</center>]]></content>
      <categories>
        <category>MSP430相关</category>
        <category>MSP430教程</category>
      </categories>
      <tags>
        <tag>单片机</tag>
        <tag>MSP430</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown插入视频,插入gif</title>
    <url>/2018/01/13/MarkDown%E6%8F%92%E5%85%A5%E8%A7%86%E9%A2%91-%E6%8F%92%E5%85%A5gif/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">插入视频代码：</span><br><span class="line"></span><br><span class="line">&lt;iframe height=498 width=510 src=&quot;http://player.youku.com/embed/XNjcyMDU4Njg0&quot;&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">插入gif代码：</span><br><span class="line"></span><br><span class="line">&lt;iframe height=500 width=500 src=&quot;http://ww4.sinaimg.cn/mw690/e75a115bgw1f3rrbzv1m8g209v0diqv7.gif&quot;&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>Markdown教程</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL忘记root密码解决方法</title>
    <url>/2018/01/09/MySQL%E5%BF%98%E8%AE%B0root%E5%AF%86%E7%A0%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p><a href="http://www.cnblogs.com/sbaicl/articles/3132010.html" target="_blank" rel="noopener">原文链接</a><br>1．首先确认服务器出于安全的状态，也就是没有人能够任意地连接MySQL数据库。<br>因为在重新设置MySQL的root密码的期间，MySQL数据库完全出于没有密码保护的<br>状态下，其他的用户也可以任意地登录和修改MySQL的信息。可以采用将MySQL对<br>外的端口封闭，并且停止Apache以及所有的用户进程的方法实现服务器的准安全<br>状态。最安全的状态是到服务器的Console上面操作，并且拔掉网线。</p>
<p>2．修改MySQL的登录设置：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim /etc/my.cnf</span></span><br></pre></td></tr></table></figure></p>
<p>在<code>[mysqld]</code>的段中加上一句：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">skip-grant-tables</span><br></pre></td></tr></table></figure></p>
<p>例如：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mysqld] </span><br><span class="line">datadir=/var/lib/mysql </span><br><span class="line">socket=/var/lib/mysql/mysql.sock </span><br><span class="line">skip-grant-tables</span><br></pre></td></tr></table></figure></p>
<p>保存并且退出vi。</p>
<p>3．重新启动mysqld<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># service mysqld restart </span></span><br><span class="line">Stopping MySQL: [ OK ] </span><br><span class="line">Starting MySQL: [ OK ]</span><br></pre></td></tr></table></figure></p>
<p>4．登录并修改MySQL的root密码<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mysql </span></span><br><span class="line">Welcome to the MySQL monitor. Commands end with ; or \g. </span><br><span class="line">Your MySQL connection id is 3 to server version: 3.23.56 </span><br><span class="line">Type <span class="string">'help;'</span> or <span class="string">'\h'</span> <span class="keyword">for</span> <span class="built_in">help</span>. Type <span class="string">'\c'</span> to clear the buffer. </span><br><span class="line">mysql&gt; USE mysql ; </span><br><span class="line">Database changed </span><br><span class="line">mysql&gt; UPDATE user SET Password = password ( <span class="string">'new-password'</span> ) WHERE User = <span class="string">'root'</span> ; </span><br><span class="line">Query OK, 0 rows affected (0.00 sec) </span><br><span class="line">Rows matched: 2 Changed: 0 Warnings: 0 </span><br><span class="line">mysql&gt; flush privileges ; </span><br><span class="line">Query OK, 0 rows affected (0.01 sec) </span><br><span class="line">mysql&gt; quit</span><br></pre></td></tr></table></figure></p>
<p>5．将MySQL的登录设置修改回来<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim /etc/my.cnf</span></span><br></pre></td></tr></table></figure></p>
<p>将刚才在<code>[mysqld]</code>的段中加上的<code>skip-grant-tables</code>删除<br>保存并且退出vim</p>
<p>6．重新启动mysqld<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># service mysqld restart </span></span><br><span class="line">Stopping MySQL: [ OK ] </span><br><span class="line">Starting MySQL: [ OK ]</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>MySql教程</category>
      </categories>
      <tags>
        <tag>MySql教程</tag>
        <tag>MySql相关问题</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenELEC中文设置教程</title>
    <url>/2019/10/01/OpenELEC%E4%B8%AD%E6%96%87%E8%AE%BE%E7%BD%AE%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>XBMC / OpenELEC 在安装后大家是不是和小编一样，发现没有中文? 可是要怎么设置成中文呢？接下来就为大家说明：</p>
<p>1.鼠标移动到 SYSTEM然后点击 Settings</p>
<p>Tips:也可以直接点击SYSTEM默认进入Settings</p>
<p>2.点击Appearance</p>
<p>3.点击左侧的International，在右侧的Language中选择Chinese (Simple)<br><a id="more"></a><br>这时界面会出现很多个“□”，</p>
<p>4.点击左侧第一项□□(皮肤)，然后在右边第四项选择□□Arial□□</p>
<p>稍等1秒中，系统会自动变成中文</p>
<p>再次返回到主界面下，此时已经完全变成简体中文的UI了</p>
]]></content>
      <categories>
        <category>ELEC</category>
      </categories>
      <tags>
        <tag>XBMC</tag>
      </tags>
  </entry>
  <entry>
    <title>[OrangePi]为OrangePi-PC编译Armbian系统</title>
    <url>/2018/01/20/OrangePi-%E4%B8%BAOrangePi-PC%E7%BC%96%E8%AF%91Armbian%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="Orangepi-PC"><a href="#Orangepi-PC" class="headerlink" title="Orangepi PC"></a>Orangepi PC</h3><p>香橙派平板是一款开源的单板电脑，新一代的arm开发板,它可以运行Android4.4、Ubuntu、Debian等操作系统,兼容树莓派。香橙派平板使用全志H3系统级芯片，同时拥有1GB DDR3 内存，官方网站：<a href="http://www.orangepi.cn/orangepipc/index_cn.html" target="_blank" rel="noopener">http://www.orangepi.cn/orangepipc/index_cn.html</a></p>
<p><img src="orangepipc_info_cn.jpg" alt="orangepipc_info_cn"></p>
<p> <img src="无标题2.png" alt="无标题2"><br>Orangepi PC是基于全志H3的开源开发板，全志H3主要用于机顶盒产品，具体参数：</p>
<p> <img src="20160730144810d6.jpg" alt="20160730144810d6"></p>
<p> <img src="无标题.png" alt="无标题"></p>
<p> <img src="无标题1.png" alt="无标题1"></p>
<h3 id="Armbian系统"><a href="#Armbian系统" class="headerlink" title="Armbian系统"></a>Armbian系统</h3><p>Armbian是轻量级的Debian系统和为ARM开发板专门发行并重新编译的Ubuntu系统。关于armbian系统具体介绍可以查看网站<a href="https://www.armbian.com/" target="_blank" rel="noopener">https://www.armbian.com/</a></p>
<p><strong>主要特点：</strong></p>
<ul>
<li>Armbian使用重新编译的Debian Wheezy，Jessie或Ubuntu，它们可靠性极佳。</li>
<li>安装映像降低到实际的数据大小。</li>
<li>root密码是1234。第一次登陆时你会被提示更改密码并创建登录用户。</li>
<li>第一次启动需要较长时间（可能长达几分钟）比正常启动（20S）要慢。因为它需要更新软件包列表，获取SSH密钥和扩展系统以适应你的SD卡分区，而且它可能会自动重新启动一次。</li>
<li>可以切换内核以适应其它系统。[1] </li>
<li>桌面环境可以升级准备。</li>
<li>NAND，SATA，eMMC和USB安装包含脚本（NAND SATA安装）。</li>
<li>串行控制台启用。</li>
<li>启用自动安全更新下载的系统。升级也可以通过apt-get等方法。</li>
</ul>
<p><strong>支持的芯片</strong></p>
<p>全志 A10, A20, A31, H3, A64<br>Amlogic S805<br>Amlogic S905<br>Actionsemi S500<br>飞思卡尔/ NXP iMx6<br>Marvell Armada A380<br>三星Exynos 5422<br>RK3288</p>
<p><strong>支持的ARM板</strong></p>
<p>Beelink X2,<br>Orange Pi PC plus, Orange Pi Plus 2E, Orange Pi Lite, Orange Pi 2,Orange Pi One, Orange Pi PC, Orange Pi Plus 1 &amp; 2,<br>Orange Pi A20,Orange Pi mini A20,Orange Pi A31S,<br>Roseapple Pi,<br>NanoPi M1,<br>pcDuino2, pcDuino3, pcDuino3 nano,<br>Odroid C0/C1/C1+, Odroid C2,Odroid XU4,<br>Banana Pi M2+,Banana Pi, Banana Pi M2,Banana Pi PRO,Banana Pi Plus A20,<br>Hummingboard,Hummingboard 2,<br>Clearfog,<br>Lemaker Guitar,<br>Udoo Neo,<br>Cubieboard 1, Cubieboard 2,<br>Lamobo R1,<br>Olimex Lime A10, Olimex Micro, Olimex Lime 2, Olimex Lime 1,<br>Udoo quad,<br>Cubox-i,<br>Cubietruck</p>
<h2 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h2><ul>
<li>Ubuntu 16.04 LTS 64位</li>
<li>orangepi pc开发板</li>
</ul>
<h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><p>源码下载地址：<a href="https://github.com/armbian/build" target="_blank" rel="noopener">https://github.com/armbian/build</a></p>
<p>编译系统过程还是比较简单的</p>
<p>(1) 搭建开发环境</p>
<p>编译环境我用的是虚拟机安装的Ubuntu 16.04 64位的系统，新建虚拟机时硬盘空间要足够大，否则编译过程会被中断。我为Ubuntu分配了100G空间,当然物理硬盘占用不会达到100G，主要是为以后编译其他系统留点空间</p>
<p>官方提供的编译环境说明</p>
<p>Supported build environments:</p>
<ul>
<li>Ubuntu Xenial 16.04 x64 guest inside a VirtualBox or other virtualization software,</li>
<li>Ubuntu Xenial 16.04 x64 guest managed by Vagrant. This uses Virtualbox (as above) but does so in an easily repeatable way. Please check the Armbian with Vagrant README for a quick start HOWTO,</li>
<li>Ubuntu Xenial 16.04 x64 inside a Docker, systemd-nspawn or other container environment (example). Building full OS images inside containers may not work, so this option is mostly for the kernel compilation,</li>
<li>Ubuntu Xenial 16.04 x64 running natively on a dedicated PC or a server (not recommended unless you build kernel only, for full OS images always use virtualization as outlined above),</li>
<li>20GB disk space or more and 2GB RAM or more available for the VM, container or native OS,</li>
<li>superuser rights (configured sudo or root access).</li>
</ul>
<p>(2) 开始编译<br>这里要注意的是网络得通畅，编译过程中会下载一下工具和源码包，一般编译下来没什么问题。我们先编译内核再编译整个系统，编译时使用root用户或者sudo</p>
<p>Execution<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get -y install git</span><br><span class="line">git clone https://github.com/armbian/build</span><br><span class="line">cd build</span><br><span class="line">./compile.sh</span><br></pre></td></tr></table></figure></p>
<p>Make sure that full path to the build script does not contain spaces.<br>检查所有路径不包含空格<br>You will be prompted with a selection menu for a build option, a board name, a kernel branch and an OS release. Please check the documentation for advanced options and additional customization.<br>编译过程中会有编译选项选择，板子的名称，内核和系统版本。请查看高级选项和额外定制的文档。<br>Build process uses caching for the compilation and the debootstrap process, so consecutive runs with similar settings will be much faster.</p>
<p><strong>具体步骤：</strong></p>
<p>(1)首先安装git,Ctrl+Alt+T打开终端输入下面的命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get -y install git</span><br></pre></td></tr></table></figure>
<p> 检查git版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>
<p><img src="2018-01-20 21-40-09屏幕截图.png" alt="2018-01-20 21-40-09屏幕截图"></p>
<p>(2)下载源码，在终端中输入下面的命令</p>
<p>源码可以放在自己习惯的文件夹下，下面是我的<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/iotts/</span><br><span class="line">mkdir armbian</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/armbian/build</span><br></pre></td></tr></table></figure></p>
<p>(3)开始编译，在终端中输入下面的命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">./compile.sh</span><br></pre></td></tr></table></figure>
<p><img src="2018-01-20 21-31-30屏幕截图.png" alt="2018-01-20 21-31-30屏幕截图"></p>
<p> <img src="2018-01-20 21-32-37屏幕截图.png" alt="2018-01-20 21-32-37屏幕截图"></p>
<p> 安装编译工具完成后会进入配置编译配置界面<img src="2018-01-20 21-51-53屏幕截图.png" alt="2018-01-20 21-51-53屏幕截图"></p>
<p><img src="2018-01-20 21-52-04屏幕截图.png" alt="2018-01-20 21-52-04屏幕截图"></p>
<p><img src="2018-01-20 21-52-24屏幕截图.png" alt="2018-01-20 21-52-24屏幕截图"> </p>
<p>我们选择第二项</p>
<p><img src="2018-01-20 21-52-51屏幕截图.png" alt="2018-01-20 21-52-51屏幕截图"></p>
<p>确定以后就开始编译内核了，编译整个系统的步骤基本类似，选择下图中的第二项</p>
<p><img src="2018-01-20 21-51-53屏幕截图.png" alt="2018-01-20 21-51-53屏幕截图"></p>
<p>来一张编译完成的图，电脑有点慢编译时间有点长</p>
<p><img src="2018-01-20 16-18-17屏幕截图.png" alt="2018-01-20 16-18-17屏幕截图"></p>
<p>以上就是自编译armbian系统的具体步骤</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>OrangePi PC</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>OrangePi PC</tag>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32F103x教程之ADC</title>
    <url>/2018/01/07/STM32F103x%E6%95%99%E7%A8%8B%E4%B9%8BADC/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>STM32相关</category>
        <category>STM32F1教程</category>
      </categories>
  </entry>
  <entry>
    <title>STM32F103x教程之DAC</title>
    <url>/2018/01/07/STM32F103x%E6%95%99%E7%A8%8B%E4%B9%8BDAC/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>STM32相关</category>
        <category>STM32F1教程</category>
      </categories>
  </entry>
  <entry>
    <title>STM32F103x教程之定时器</title>
    <url>/2018/01/07/STM32F103x%E6%95%99%E7%A8%8B%E4%B9%8B%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>STM32相关</category>
        <category>STM32F1教程</category>
      </categories>
  </entry>
  <entry>
    <title>STM32F103x教程之工程模板</title>
    <url>/2018/01/06/STM32F103x%E6%95%99%E7%A8%8B%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>STM32相关</category>
        <category>STM32F1教程</category>
      </categories>
  </entry>
  <entry>
    <title>STM32F103x教程之按键操作</title>
    <url>/2018/01/06/STM32F103x%E6%95%99%E7%A8%8B%E4%B9%8B%E6%8C%89%E9%94%AE%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>STM32相关</category>
        <category>STM32F1教程</category>
      </categories>
      <tags>
        <tag>stm32 按键基本操作</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32F103x教程之点亮LED</title>
    <url>/2018/01/06/STM32F103x%E6%95%99%E7%A8%8B%E4%B9%8B%E7%82%B9%E4%BA%AELED/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>STM32相关</category>
        <category>STM32F1教程</category>
      </categories>
  </entry>
  <entry>
    <title>STM32F103x教程之软件安装</title>
    <url>/2018/01/06/STM32F103x%E6%95%99%E7%A8%8B%E4%B9%8B%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>STM32相关</category>
        <category>STM32F1教程</category>
      </categories>
  </entry>
  <entry>
    <title>STM32FXX之Lua解释器移植</title>
    <url>/2019/09/30/STM32FXX%E4%B9%8BLua%E8%A7%A3%E9%87%8A%E5%99%A8%E7%A7%BB%E6%A4%8D/</url>
    <content><![CDATA[<p>将Lua解释器移植到STM32</p>
<p>最近在一个在做一个PLC项目，对于PLC需要根据不同场景实现不同的功能，因此为了保持系统的稳定性决定做一个脚本配置的方案。开始的时候自己写了一个脚本解析程序，系统运行不错，就是脚本有点长，易读性比较差，今天突然想到Lua,决定把Lua移植到STM32上去，网上查了一下相关资料，说实话，关于STM32Lua的工程应用还是比较少的，决定自己移植一下<br><a id="more"></a><br>前期准备<br>Lua源码包：<br>目前最新版本是5.3.4 ，下载链接：<a href="http://www.lua.org/ftp/lua-5.3.4.tar.gz" target="_blank" rel="noopener">http://www.lua.org/ftp/lua-5.3.4.tar.gz</a><br>Stm32f103工程模板：<br>我已经做好的工程模板，主要有一个LED驱动，串口驱动<br>下载连接：</p>
<p>开始移植<br>我用的KEIL 5.17，板子用的STM32f103板子</p>
<p>1.Lua源码解压会得到一个src文件夹，把src下的源码添加到STM32的工程里，设置好包含路径，注意lua.c 和 luac.c 这两个文件是不包含的（它们包含PC上Lua解释器和编译器的main函数）,将这两个文件删除。</p>
<p><img src="fig3.png" alt="fig3.png"></p>
<p><img src="fig4.png" alt="fig4.png"></p>
<p>2.Lua硬件要求<br>l RAM &gt;= 7.5Kb，建议16KB以上<br>l ROM &gt;= 65kb，建议128kb以上<br>改动堆栈大小：堆最小为5.5kb，栈最小是1.5kb。在启动文件里把堆(Heap_Size)设置的足够大，我设置的0x00008000(32KB)是没问题的，其实要不了这么多。建议把栈设置的大一点（1KB足够）</p>
<p><img src="fig1.png" alt="fig1.png"></p>
<p>把MicroLib的勾打上了，如下图：</p>
<p><img src="fig2.png" alt="fig2.png"></p>
<p>然后我写了一个简单的函数来实现解释器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* 测试的Lua代码字符串 */</span><br><span class="line">const char lua_test[] = &#123; </span><br><span class="line">    &quot;print(\&quot;Hello,I am lua!\\n--this is newline printf\&quot;)\n&quot;</span><br><span class="line">    &quot;function foo()\n&quot;</span><br><span class="line">    &quot;  local i = 0\n&quot;</span><br><span class="line">    &quot;  local sum = 1\n&quot;</span><br><span class="line">    &quot;  while i &lt;= 10 do\n&quot;</span><br><span class="line">    &quot;    sum = sum * 2\n&quot;</span><br><span class="line">    &quot;    i = i + 1\n&quot;</span><br><span class="line">    &quot;  end\n&quot;</span><br><span class="line">    &quot;return sum\n&quot;</span><br><span class="line">    &quot;end\n&quot;</span><br><span class="line">    &quot;print(\&quot;sum =\&quot;, foo())\n&quot;</span><br><span class="line">    &quot;print(\&quot;and sum = 2^11 =\&quot;, 2 ^ 11)\n&quot;</span><br><span class="line">    &quot;print(\&quot;exp(200) =\&quot;, math.exp(200))\n&quot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* 运行Lua */</span><br><span class="line">static int do_file_script(void)</span><br><span class="line">&#123;</span><br><span class="line">    lua_State *L;</span><br><span class="line"></span><br><span class="line">    L = luaL_newstate(); /* 建立Lua运行环境 */</span><br><span class="line">    luaL_openlibs(L);</span><br><span class="line">    luaopen_base(L);</span><br><span class="line">    luaL_dostring(L, lua_test); /* 运行Lua脚本 */</span><br><span class="line">    lua_close(L);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;stm32_config.h&quot;</span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;lua.h&quot;</span><br><span class="line">#include &quot;lauxlib.h&quot;</span><br><span class="line">#include &quot;lualib.h&quot;</span><br><span class="line">#include &quot;stdlib.h&quot;</span><br><span class="line">#include &quot;bsp_led.h&quot;</span><br><span class="line">#include &quot;time.h&quot;</span><br><span class="line">#include &quot;usart.h&quot;</span><br><span class="line"> /**********************************************************</span><br><span class="line"> * 函数名 : main</span><br><span class="line"> * 输入   ：none</span><br><span class="line"> * 输出   ：none </span><br><span class="line"> * 功能   ：</span><br><span class="line"> **********************************************************/</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	delay_init(72);</span><br><span class="line">	LED_Init();</span><br><span class="line">	USARTx_Init(115200);</span><br><span class="line">	</span><br><span class="line">	do_file_script();</span><br><span class="line"></span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">//		GPIO_SetBits(GPIOE,GPIO_Pin_5);</span><br><span class="line">//		delay_ms(200);</span><br><span class="line">//    GPIO_ResetBits(GPIOE,GPIO_Pin_5);</span><br><span class="line">//		delay_ms(200);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译之后报错说time(), exit(), system()这三个标准库函数没有定义，我们需要自己定义<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* 定义MicroLib没有的函数 */</span><br><span class="line">time_t time(time_t * time)</span><br><span class="line">&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void exit(int status)</span><br><span class="line">&#123;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int system(const char * string)</span><br><span class="line">&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>好，现在终于可以运行了，</p>
]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>单片机</tag>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>TMP35构成的4--20mA温度变送器电路图</title>
    <url>/2019/12/19/TMP35%E6%9E%84%E6%88%90%E7%9A%844-20mA%E6%B8%A9%E5%BA%A6%E5%8F%98%E9%80%81%E5%99%A8%E7%94%B5%E8%B7%AF%E5%9B%BE/</url>
    <content><![CDATA[<p>　　由TMP35构成的4～20mA温度变送器电路如图所示。该电路可将TMP35输出的电压信号变换成4～20mA的标准电流信号，供自动化仪表使用，进行工业温度控制。<br><a id="more"></a><br>这里是以4mA作为零刻度值，20mA为满刻度值。REF193为3V基准电压源，OP193为运算放大器。RP1、RP2分别为校准满刻度和零点的电位器，二者可独立调节，互不影响。VD1采用肖特基二极管，它能防止OP193开环电压的升高。电源电压可取+9～+18V。变送器的输出电流表达式为:</p>
<p><img src="20191031114218280.jpg" alt="img"></p>
<p><img src="20191031114218486.jpg" alt="TMP35构成的4～20mA温度变送器电路图"></p>
]]></content>
      <categories>
        <category>电路设计相关</category>
        <category>传感器电路设计</category>
      </categories>
      <tags>
        <tag>PCB</tag>
        <tag>电路设计</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu下搭建MQTT服务器</title>
    <url>/2018/01/11/Ubuntu%E4%B8%8B%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现在物联网这么火，当然不能落伍，MQTT极有可能成为物联网应用最广的协议，因此需要一个MQTT测试环境就很有必要了</p>
<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>系统：            Ubuntu 16.04.3 LTS</p>
<p>代理服务器 ：Apache-Apollo-1.7.1</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="1-安装Java环境"><a href="#1-安装Java环境" class="headerlink" title="1. 安装Java环境"></a>1. 安装Java环境</h3><p>由于搭建Apollo环境变量需要有JAVA_HOME，这个时候需要安装JDK,具体安装参考《<a href="../Ubuntu安装JDK1-8-0并配置环境变量">Ubuntu安装JDK1.8.0并配置环境变量</a>》</p>
<h3 id="2-Apache-Apollo-1-7-1下载及解压"><a href="#2-Apache-Apollo-1-7-1下载及解压" class="headerlink" title="2. Apache-Apollo-1.7.1下载及解压"></a>2. Apache-Apollo-1.7.1下载及解压</h3><p>首先是下载Apache-Apollo，下载页面：<a href="http://www.apache.org/dyn/closer.cgi?path=activemq/activemq-apollo/1.7.1/apache-apollo-1.7.1-unix-distro.tar.gz" target="_blank" rel="noopener">http://www.apache.org/dyn/closer.cgi?path=activemq/activemq-apollo/1.7.1/apache-apollo-1.7.1-unix-distro.tar.gz</a></p>
<p>或者输入下面命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iotts@jacklu:~$ <span class="built_in">cd</span> /home/iotts/</span><br><span class="line">iotts@jacklu:~$ mkdir apache-apollo</span><br><span class="line">wget http://mirror.bit.edu.cn/apache/activemq/activemq-apollo/1.7.1/apache-apollo-1.7.1-unix-distro.tar.gz</span><br></pre></td></tr></table></figure>
<p>解压源码包：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf apache-apollo-1.7.1-unix-distro.tar.gz</span><br></pre></td></tr></table></figure></p>
<p>配置</p>
<p>进入apache-apollo-1.7.1/bin目录<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> apache-apollo-1.7.1/bin/</span><br></pre></td></tr></table></figure></p>
<p>输入<code>./apollo</code>可以查看帮助<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iotts@jacklu:~/apache-apollo/apache-apollo-1.7.1/bin$ ./apollo</span><br><span class="line">usage: apollo [--<span class="built_in">log</span> &lt;log_level&gt;] &lt;<span class="built_in">command</span>&gt; [&lt;args&gt;]</span><br><span class="line"></span><br><span class="line">The most commonly used apollo commands are:</span><br><span class="line">    create           creates a new broker instance</span><br><span class="line">    disk-benchmark   Benchmarks your disk<span class="string">'s speed</span></span><br><span class="line"><span class="string">    help             Display help information</span></span><br><span class="line"><span class="string">    version          Displays the broker version</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">See '</span>apollo <span class="built_in">help</span> &lt;<span class="built_in">command</span>&gt;<span class="string">' for more information on a specific command.</span></span><br></pre></td></tr></table></figure></p>
<h2 id="创建MQTT服务器"><a href="#创建MQTT服务器" class="headerlink" title="创建MQTT服务器"></a>创建MQTT服务器</h2><p>创建一个Broker示例：./apollo create iotts_broker。执行后就会在bin目录下创建 iotts_broker文件夹。(MQTT服务器都是叫Broker)<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iotts@jacklu:~/apache-apollo/apache-apollo-1.7.1/bin$ ./apollo create iotts_broker</span><br><span class="line">Creating apollo instance at: iotts_broker</span><br><span class="line">Generating ssl keystore...</span><br><span class="line"></span><br><span class="line">You can now start the broker by executing:  </span><br><span class="line"></span><br><span class="line">   <span class="string">"/home/iotts/apache-apollo/apache-apollo-1.7.1/bin/iotts_broker/bin/apollo-broker"</span> run</span><br><span class="line"></span><br><span class="line">Or you can setup the broker as system service and run it <span class="keyword">in</span> the background:</span><br><span class="line"></span><br><span class="line">   sudo ln -s <span class="string">"/home/iotts/apache-apollo/apache-apollo-1.7.1/bin/iotts_broker/bin/apollo-broker-service"</span> /etc/init.d/</span><br><span class="line">   /etc/init.d/apollo-broker-service start</span><br></pre></td></tr></table></figure></p>
<p>后面会有提示怎么启动服务器，以及创建一个service。</p>
<p>启动Apollo ：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iotts@jacklu:~/apache-apollo/apache-apollo-1.7.1/bin$ iotts_broker/bin/apollo-broker run</span><br><span class="line"></span><br><span class="line">    _____                .__  .__</span><br><span class="line">   /  _  \ ______   ____ |  | |  |   ____</span><br><span class="line">  /  /_\  \\____ \ /  _ \|  | |  |  /  _ \</span><br><span class="line"> /    |    \  |_&gt; &gt;  &lt;_&gt; )  |_|  |_(  &lt;_&gt; )</span><br><span class="line"> \____|__  /   __/ \____/|____/____/\____/</span><br><span class="line">         \/|__|  Apache Apollo (1.7.1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Loading configuration file <span class="string">'/home/iotts/apache-apollo/apache-apollo-1.7.1/bin/iotts_broker/etc/apollo.xml'</span>.</span><br><span class="line">INFO  | OS     : Linux 4.10.0-42-generic (Ubuntu 16.04.3 LTS)</span><br><span class="line">INFO  | JVM    : Java HotSpot(TM) Server VM 1.8.0_151 (Oracle Corporation)</span><br><span class="line">INFO  | Apollo : 1.7.1 (at: /home/iotts/apache-apollo/apache-apollo-1.7.1)</span><br><span class="line">INFO  | OS is restricting the open file <span class="built_in">limit</span> to: 100000</span><br><span class="line">INFO  | Accepting connections at: tcp://0.0.0.0:61613</span><br><span class="line">INFO  | Accepting connections at: tls://0.0.0.0:61614</span><br><span class="line">INFO  | Starting store: leveldb store at /home/iotts/apache-apollo/apache-apollo-1.7.1/bin/iotts_broker/data</span><br><span class="line">INFO  | Accepting connections at: ws://0.0.0.0:61623/</span><br><span class="line">INFO  | Accepting connections at: wss://0.0.0.0:61624/</span><br><span class="line">INFO  | virtual host startup is waiting on store startup</span><br><span class="line">INFO  | virtual host startup is no longer waiting.  It waited a total of 1 seconds.</span><br><span class="line">INFO  | broker startup is waiting on start jetty webserver</span><br><span class="line">INFO  | Administration interface available at: https://127.0.0.1:61681/</span><br><span class="line">INFO  | Administration interface available at: http://127.0.0.1:61680/</span><br><span class="line">INFO  | broker startup is no longer waiting.  It waited a total of 7 seconds.</span><br></pre></td></tr></table></figure></p>
<p>查看打印信息即可知道MQTT要连接的端口和管理页面端口。</p>
<p>然后打开浏览器上，输入 <a href="http://127.0.0.1:61680/" target="_blank" rel="noopener">http://127.0.0.1:61680/</a> 或 <a href="https://127.0.0.1:61681/" target="_blank" rel="noopener">https://127.0.0.1:61681/</a><br>即可进入 Apollo Console 窗口。<br><img src="微信截图_20180111233348.png" alt="微信截图_20180111233348.png"></p>
<p>默认的登录id和密码是 admin 和 password<br><img src="微信截图_20180111233514.png" alt="微信截图_20180111233514.png"></p>
]]></content>
      <categories>
        <category>物联网相关</category>
        <category>服务器端相关</category>
      </categories>
      <tags>
        <tag>物联网</tag>
        <tag>服务器操作</tag>
        <tag>数据采集</tag>
        <tag>linux</tag>
        <tag>MQTT</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu安装JDK1.8.0并配置环境变量</title>
    <url>/2018/01/11/Ubuntu%E5%AE%89%E8%A3%85JDK1-8-0%E5%B9%B6%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>虚拟机 Ubuntu 16.04.3 LTS</p>
<h2 id="JDK安装"><a href="#JDK安装" class="headerlink" title="JDK安装"></a>JDK安装</h2><p>通过终端在<code>/usr/local</code>目录下新建<code>java</code>文件夹，命令行：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mkdir /usr/<span class="built_in">local</span>/java</span><br></pre></td></tr></table></figure></p>
<p>然后进入java目录，命令行：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/java</span><br></pre></td></tr></table></figure></p>
<p>到官网下载jdk：<br><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p>
<p>注意操作系统位数的选择，我的Ubuntu系统为32位的所以直接输入下面命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://download.oracle.com/otn-pub/java/jdk/8u151-b12/e758a0de34e24606bca991d704f6dcbf/jdk-8u151-linux-i586.tar.gz</span><br></pre></td></tr></table></figure></p>
<p>解压源码包</p>
<p>解压压缩包，命令行：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo tar xvf jdk-8u151-linux-i586.tar.gz</span><br></pre></td></tr></table></figure></p>
<p>然后可以把压缩包删除，命令行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo rm jdk-8u151-linux-i586.tar.gz</span><br></pre></td></tr></table></figure>
<h2 id="设置JDK环境变量"><a href="#设置JDK环境变量" class="headerlink" title="设置JDK环境变量"></a>设置JDK环境变量</h2><p>这里采用全局设置方法，它是是所有用户的共用的环境变量<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sudo</span> gedit ~/.bashrc</span><br></pre></td></tr></table></figure></p>
<p>命令行下可以输入<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi ~/.bashrc</span><br></pre></td></tr></table></figure></p>
<p>在.bashrc文件末尾输入<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/<span class="built_in">local</span>/java/jdk1.8.0_151  </span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$&#123;JAVA_HOME&#125;</span>/jre  </span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$&#123;JAVA_HOME&#125;</span>/lib:<span class="variable">$&#123;JRE_HOME&#125;</span>/lib  </span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;JAVA_HOME&#125;</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure></p>
<p>$\color{red}{注意：}$在添加环境变量时中，等号两侧不要加入空格，不然会出现“不是有效的标识符”，因为<code>source /etc/profile</code> 时不能识别多余到空格，会理解为是路径一部分。然后保存。<br>命令行下输入以下命令生效<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure></p>
<h2 id="检验是否安装成功"><a href="#检验是否安装成功" class="headerlink" title="检验是否安装成功"></a>检验是否安装成功</h2><p>重启终端，然后在终端输入如下命令<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure></p>
<p>看看是否安装成功，成功则显示如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iotts@jacklu:~$ java -version</span><br><span class="line">java version <span class="string">"1.8.0_151"</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_151-b12)</span><br><span class="line">Java HotSpot(TM) Client VM (build 25.151-b12, mixed mode)</span><br><span class="line">iotts@jacklu:~$</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>java环境变量配置</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>WINDOWS命令行关闭本地占用的端口</title>
    <url>/2020/04/02/WINDOWS%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%85%B3%E9%97%AD%E6%9C%AC%E5%9C%B0%E5%8D%A0%E7%94%A8%E7%9A%84%E7%AB%AF%E5%8F%A3/</url>
    <content><![CDATA[<p>1.查找对应的端口占用的进程：netstat  -aon|findstr  “8080”    ，找到占用8080端口对应的程序的PID号；<br><a id="more"></a><br><img src="1.png" alt="1.png"></p>
<p>2.根据PID号找到对应的程序：tasklist|findstr “PID号”    ，找到对应的程序名；</p>
<p><img src="2.png" alt="2.png"></p>
<p>3.结束该进程：taskkill /f /t /im ApplicationWebServer.exe；或者taskkill /pid 7644 /F。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows下搭建MQTT服务器</title>
    <url>/2019/10/01/Windows%E4%B8%8B%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在项目中要使用MQTT协议，需要搭建一个MQTT服务器来进行调试，在网络上找了一天，找到的大多数都是MQTT客户端，最后发现这篇博客写的教程可以使用，特此记录。</p>
<h2 id="寻找过程"><a href="#寻找过程" class="headerlink" title="寻找过程"></a>寻找过程</h2><p>在寻找MQTT服务器的过程中，我发现的Mosquitto是一款「An Open Source MQTT v3.1/v3.1.1 Broker」——开源的MQTT代理服务器，其下也有Windows的安装包。<br><a id="more"></a><br><img src="20160929175146631.png" alt="mosquitto"></p>
<p>但是我使用的是Win10 64位系统，这两个都下载安装后不是报错就是缺少dll文件，不能使用。</p>
<p>最后参考了前面博客说的，搭建了Apollo服务器，这里使用的Apollo 1.7.1。</p>
<p>官网：<a href="http://activemq.apache.org/index.html" target="_blank" rel="noopener">http://activemq.apache.org/index.html</a><br>下载地址：<a href="http://activemq.apache.org/apollo/download.html" target="_blank" rel="noopener">http://activemq.apache.org/apollo/download.html</a><br>快速开始教程：<a href="http://activemq.apache.org/apollo/documentation/getting-started.html" target="_blank" rel="noopener">http://activemq.apache.org/apollo/documentation/getting-started.html</a></p>
<h2 id="搭建MQTT服务器"><a href="#搭建MQTT服务器" class="headerlink" title="搭建MQTT服务器"></a>搭建MQTT服务器</h2><p>使用Apollo搭建MQTT服务器步骤：</p>
<p>下载Apollo服务器并解压，在CMD环境运行其工作目录下的<strong>…\bin\apollo.cmd</strong>，命令后面带上参数<strong>create mybroker</strong>，创建服务器实例。这里需要Java环境，系统环境变量下要有JAVA_HOME。<br>创建实例之后会在bin目录下生成mybroker文件夹，其中<strong>…\etc\apollo.xml</strong>文件下是配置服务器信息的文件，<strong>…\etc\users.properties</strong> 文件包含连接MQTT服务器时用到的用户名和密码，初始默认帐号是admin，密码password；<br>进入<strong>…\mybroker\bin </strong>目录，在CMD输入命令<strong>apollo-broker.cmd run</strong>，可以使用TAB键自动补全，运行后输出信息如下：</p>
<p><img src="20161120143250439.png" alt="MQTT服务运行信息"><br>其中我们要留意的：</p>
<p>MQTT服务器TCP连接端口：tcp://0.0.0.0:61613</p>
<p>后台Web管理页面：<a href="https://127.0.0.1:61681/或http://127.0.0.1:61680/" target="_blank" rel="noopener">https://127.0.0.1:61681/或http://127.0.0.1:61680/</a></p>
<p>登录服务器后，如果MQTT服务器有客户端连接，后台会显示如下</p>
<p><img src="20160929213931331.png" alt="后台"></p>
<h2 id="Python的MQTT客户端"><a href="#Python的MQTT客户端" class="headerlink" title="Python的MQTT客户端"></a>Python的MQTT客户端</h2><p>在Python环境下有MQTT客户端包——paho-mqtt。</p>
<h3 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install paho-mqtt1</span><br></pre></td></tr></table></figure>
<h3 id="客户端代码清单"><a href="#客户端代码清单" class="headerlink" title="客户端代码清单"></a>客户端代码清单</h3><p>下面是MQTT客户端代码清单<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import paho.mqtt.client as mqtt</span><br><span class="line"></span><br><span class="line">def on_connect(client, userdata, flags, rc):</span><br><span class="line">    print(&quot;Connected with result code &quot;+str(rc))</span><br><span class="line"></span><br><span class="line">    client.subscribe(&quot;lettuce&quot;)</span><br><span class="line"></span><br><span class="line">def on_message(client, userdata, msg):</span><br><span class="line">    print(msg.topic+&quot; &quot;+str(msg.payload))</span><br><span class="line"></span><br><span class="line">client = mqtt.Client()</span><br><span class="line">client.username_pw_set(&quot;admin&quot;, &quot;password&quot;) # 必须设置，否则会返回「Connected with result code 4」</span><br><span class="line">client.on_connect = on_connect</span><br><span class="line">client.on_message = on_message</span><br><span class="line"></span><br><span class="line">HOST = &quot;127.0.0.1&quot;</span><br><span class="line"></span><br><span class="line">client.connect(HOST, 61613, 60)</span><br><span class="line">client.loop_forever()</span><br></pre></td></tr></table></figure></p>
<h3 id="发布消息代码"><a href="#发布消息代码" class="headerlink" title="发布消息代码"></a>发布消息代码</h3><p>下面是往MQTT服务器发布消息的代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import paho.mqtt.publish as publish</span><br><span class="line"></span><br><span class="line">HOST = &quot;127.0.0.1&quot;</span><br><span class="line"></span><br><span class="line">publish.single(&quot;lettuce&quot;, &quot;payload&quot;, hostname=HOST, port=61613,</span><br><span class="line">               auth=&#123;&apos;username&apos;: &quot;admin&quot;, &apos;password&apos;:&quot;password&quot;&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>物联网相关</category>
        <category>服务器端相关</category>
      </categories>
      <tags>
        <tag>MQTT</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言教程之函数返回字符串的四种方法</title>
    <url>/2019/10/25/c%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>在讨论着四种方法之前，首先要对函数有一个简单的认识，无论是在形实结合时，还是在return语句返回时，都有一个拷贝的过程。你传进来的参数是个值，自然函数在工作之前要把这个值拷贝一份供自己使用，你传进来的是个地址，函数也就会拷贝该地址供自己使用。同样return返回时，如果返回一个值，函数会将该值拷贝一份以提供给主调函数使用，返回的是一个指针（也就是地址），自然拷贝的就是一个地址，供主调函数使用。</p>
<a id="more"></a>
<p>先给出一个错误的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">char * retstring();</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char * name2;</span><br><span class="line">    name2 = retstring();</span><br><span class="line">    printf(&quot;%s\n&quot;,name2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char * retstring()</span><br><span class="line">&#123;</span><br><span class="line">    char name[10]; </span><br><span class="line">    strcpy(name,&quot;汉青&quot;);</span><br><span class="line">    return name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译一下代码，会发现提示一个警告，大概意思就是说返回了一个局部变量的地址。这个程序的输出结果是不确定的，因为我们都知道，局部变量的生存期是就在块内部，这里也就是在函数retstring()的内部，在main函数中，name的内存空间已经被回收。</p>
<p>所以不能返回一个自动变量的字符串。。。</p>
<p>下面给出四种返回字符串的方法：</p>
<p>1、 将字符串指针作为函数参数传入，并返回该指针。</p>
<p>2、 使用malloc函数动态分配内存，注意在主调函数中释放。</p>
<p>3、 返回一个静态局部变量。</p>
<p>4、 使用全局变量。</p>
<p>下面是详细解释：</p>
<h3 id="方法一：将字符串指针作为函数参数传入，并返回该指针。"><a href="#方法一：将字符串指针作为函数参数传入，并返回该指针。" class="headerlink" title="方法一：将字符串指针作为函数参数传入，并返回该指针。"></a>方法一：将字符串指针作为函数参数传入，并返回该指针。</h3><p>典型的strcpy()函数应该就是采用的这种方法，第一个参数为指向目的字符串的指针,返回值也为这个指针。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char* strcpy(char* des,const char* source)</span><br><span class="line">　</span><br><span class="line">&#123;</span><br><span class="line">　</span><br><span class="line"> char* r=des;</span><br><span class="line"></span><br><span class="line">  assert((des != NULL) &amp;&amp; (source != NULL));</span><br><span class="line"></span><br><span class="line">　while((*r++ = *source++)!=&apos;\0&apos;);</span><br><span class="line"></span><br><span class="line">　return des;</span><br><span class="line">　</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法二：使用malloc函数动态分配"><a href="#方法二：使用malloc函数动态分配" class="headerlink" title="方法二：使用malloc函数动态分配"></a>方法二：使用malloc函数动态分配</h3><p>注意:注意:<br>要在主调函数中将其释放，因为malloc动态分配的内存位于堆区，而堆区的内存是要程序员自己释放的。</p>
<p>一个例子如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">char * retstring();</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char * name2;</span><br><span class="line">    name2 = retstring();</span><br><span class="line">    printf(&quot;%s\n&quot;,name2);</span><br><span class="line">    //记住一定要用free释放，否则会造成内存泄露</span><br><span class="line">    free(name2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char * retstring()</span><br><span class="line">&#123;</span><br><span class="line">    char * name;</span><br><span class="line">    name = (char *)malloc(10); </span><br><span class="line">    strcpy(name,&quot;张汉青&quot;);</span><br><span class="line">    return name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法三：返回一个静态局部变量。"><a href="#方法三：返回一个静态局部变量。" class="headerlink" title="方法三：返回一个静态局部变量。"></a>方法三：返回一个静态局部变量。</h3><p>一个例子如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">char * retstring();</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char * name2;</span><br><span class="line">    name2 = retstring();</span><br><span class="line">    printf(&quot;%s\n&quot;,name2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char * retstring()</span><br><span class="line">&#123;</span><br><span class="line">    static char name[10];</span><br><span class="line">    strcpy(name,&quot;张汉青&quot;);</span><br><span class="line">    return name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法有一个问题： 由于采用了静态局部变量（位于静态区，程序结束时由系统进行释放），这就导致，如果多次调用这个函数，下一次调用会将上一次调用的结果覆盖掉。</p>
<p>C语言中的库函数，tmpnam()函数、getenv()函数等应该都是采用的这种方法，这也就是为什么，使用这样的函数的时候应该立即将返回结果拷贝一份的原因。</p>
<h3 id="方法四：-使用全局变量。"><a href="#方法四：-使用全局变量。" class="headerlink" title="方法四： 使用全局变量。"></a>方法四： 使用全局变量。</h3><p>一个例子如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char   g_s[100]; </span><br><span class="line">char*   fun() </span><br><span class="line">&#123; </span><br><span class="line">        strcpy(g_s,   &quot;abc &quot;); </span><br><span class="line">        return   g_s; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言教程之回调函数实现</title>
    <url>/2019/10/01/c%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @file c语言实现回调函数</span><br><span class="line"> * @detial 在java等更高级的语言中往往已经给我们封装好了回调函数的调用方式，直接用就可以了。</span><br><span class="line"> * 而C语言中并没有这种直接可以操作的回调方式，我们用函数指针来实现回调原理。</span><br><span class="line"> */</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">// 将函数名作为指针的格式为：int (*ptr)(char *p) 即：返回值(指针名)(参数列表)</span><br><span class="line">typedef int (*callbackfun)(char *str); // 回调函数的名称为 callback，参数是char *p</span><br><span class="line"></span><br><span class="line">// functionA的格式符合 callback 的格式，因此可以看作是一个 callback类型</span><br><span class="line">int functionA(char *str)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;回调 functionA(char *str) 函数:%s!\n&quot;, str);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// functionB的格式符合 callback 的格式，因此也可以看作是一个 callback类型</span><br><span class="line">int functionB(char *str)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;回调 functionB(char *str) 函数:%s!\n&quot;, str);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 调用回调函数，方式一：通过命名方式</span><br><span class="line">int test1(callbackfun p_callback, char *str)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;test1:\n不调用回调函数打印:%s!\n&quot;, str);</span><br><span class="line">    p_callback(str);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用回调函数，方式二：直接通过函数指针</span><br><span class="line">int test2(int (*ptr)(), char *str)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;test2:\n不调用回调函数打印:%s!\n&quot;, str);</span><br><span class="line">    (*ptr)(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char *str = &quot;hello world!&quot;;</span><br><span class="line"></span><br><span class="line">    test1(functionA, str);</span><br><span class="line">    test1(functionB, str);</span><br><span class="line">    test2(functionA, str);</span><br><span class="line">    test2(functionB, str);</span><br><span class="line">    </span><br><span class="line">    printf(&quot;test3:\n&quot;);</span><br><span class="line">    callbackfun test3 = functionB;</span><br><span class="line">    test3(str);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IOTTS@IOTTS:/mnt/e/GCC_TEST$ ./callback</span><br><span class="line">test1:</span><br><span class="line">不调用回调函数打印:hello world!!</span><br><span class="line">回调 functionA(char *str) 函数:hello world!!</span><br><span class="line">test1:</span><br><span class="line">不调用回调函数打印:hello world!!</span><br><span class="line">回调 functionB(char *str) 函数:hello world!!</span><br><span class="line">test2:</span><br><span class="line">不调用回调函数打印:hello world!!</span><br><span class="line">回调 functionA(char *str) 函数:hello world!!</span><br><span class="line">test2:</span><br><span class="line">不调用回调函数打印:hello world!!</span><br><span class="line">回调 functionB(char *str) 函数:hello world!!</span><br><span class="line">test3:</span><br><span class="line">回调 functionB(char *str) 函数:hello world!!</span><br></pre></td></tr></table></figure>
<p>另一个例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">typedef void (*callback)(char *);</span><br><span class="line">void repeat(callback function, char *para)</span><br><span class="line">&#123;</span><br><span class="line">    function(para);</span><br><span class="line">&#125;</span><br><span class="line">void hello(char* a)</span><br><span class="line">&#123;</span><br><span class="line">     printf(&quot;Hello %s\n&quot;,(const char *)a);</span><br><span class="line">&#125;</span><br><span class="line">void count(char *num)</span><br><span class="line">&#123;</span><br><span class="line">     int i;</span><br><span class="line">     for(i=1;i&lt;(int)num;i++)</span><br><span class="line">          printf(&quot;%d&quot;,i);</span><br><span class="line">     putchar(&apos;\n&apos;);</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">     repeat(hello,&quot;jack lu&quot;);</span><br><span class="line">     repeat(count, (char *)4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iotts@jacklu:~$ ./a.out </span><br><span class="line">Hello jack lu</span><br><span class="line">123</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 新建一篇文章给它添加分类和标签</title>
    <url>/2019/09/30/hexo-%E6%96%B0%E5%BB%BA%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E7%BB%99%E5%AE%83%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%92%8C%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<p>新建一篇文章</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;Hexo教程&quot;</span><br></pre></td></tr></table></figure>
<p>通过vim编辑器或者其他编辑器打开：添加tags和categories</p>
<p>修改如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: title #文章标题</span><br><span class="line">date: 2016-06-01 23:47:44 #文章生成时间</span><br><span class="line">categories: &quot;Hexo教程&quot; #文章分类目录 可以省略</span><br><span class="line">tags: #文章标签 可以省略</span><br><span class="line">     - 标签1</span><br><span class="line">     - 标签2</span><br><span class="line"> description: #对本页的描述 可以省略</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Hexo教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo中完美插入本地图片</title>
    <url>/2018/01/07/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<h1 id="Hexo配置文件的设置"><a href="#Hexo配置文件的设置" class="headerlink" title="Hexo配置文件的设置"></a>Hexo配置文件的设置</h1><p>确保你的Hexo的配置文件<strong>_config.yml</strong>里面有个这个选项配置，并将其置为true</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">post_asset_folder: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>这个功能实际上是Hexo官方文档中提到的资源文件夹功能，它的作用在于当你使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">"hexo中完美插入本地图片"</span></span><br></pre></td></tr></table></figure>
<p>生成一篇新文章时，会在 <strong>\source \_posts</strong> 目录下生成一个 hexo中完美插入本地图片(文章名).md 文件外，附带生成一个与 文章名 同名的文件夹，可以用它来存放这篇文章的所有资源，比如图片，附件等</p>
<h1 id="安装hexo-asset-image插件"><a href="#安装hexo-asset-image插件" class="headerlink" title="安装hexo-asset-image插件"></a>安装hexo-asset-image插件</h1><p>需要安装一个图片路径转换的插件， 进入博客  /根目录 使用如下命令安装插件<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure></p>
<p>插件安装完以后，会生成<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\blog\node_modules\hexo-asset-image</span><br></pre></td></tr></table></figure></p>
<h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>首先要把需要插入的图片放到<strong>“hexo中完美插入本地图片”</strong>这个资源文件夹下，然后进行路径引用，这是上面插入图片时的实际引用代码<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">![2018-01-07 16-39-28屏幕截图.png](2018-01-07 16-39-28屏幕截图.png)</span><br></pre></td></tr></table></figure></p>
<p>实际效果<br>  <img src="2018-01-07 16-39-28屏幕截图.png" alt="2018-01-07 16-39-28屏幕截图.png"></p>
]]></content>
      <categories>
        <category>Hexo教程</category>
      </categories>
      <tags>
        <tag>Hexo教程</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下的命名规则</title>
    <url>/2019/10/24/linux%E4%B8%8B%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<p>Linux下建议的命名规则如下。</p>
<p>（1）变量名必须有一定的意义，并且意义准确。例如有一个变量用于保存图书的数目，可以命名为number_of_book或者num_of_book。不建议使用i，因为它没有意义。也不建议使用number或book，因为意义不准确。</p>
<p>（2）不建议大小写混用。如定义一个计数变量，int nCount；这在Windows中是一个很好的变量名，其中nCount的首字母n用来说明这个变量的类型是int。但在Linux下不建议大小写混合使用，一般标识符只由小写字母，数字和下划线构成。<br><a id="more"></a><br>（3）在失去意义的情况下，尽量使用较短的变量名。例如有一个变量，用于暂时存储一个计数值，把变量命名为tmp_count显然要比this_is_a_temperary_counter好。</p>
<p>（4）不采用匈牙利命名法表示变量的类型。如int nCount；n用于说明变量的类型，在Linux中不建议这样命名变量。</p>
<p>（5）函数名应该以动词开头，因为函数是一组具有特定功能的语句块。比如一个函数，它用于取得外部输入的数值，则可以命名为get_input_number。</p>
<p>（6）尽量避免使用全局变量。</p>
<p>1、避免使用不易理解的数字，用有意义的标识来替代（枚举和常量）</p>
<p>比如：</p>
<p><img src="25498312_1345797279nPdQ.png" alt="image"></p>
<p>2、在界面层中尽量使用异常处理try语句，不要将系统级别的错误直接暴露给用户，而更应该的是把系统抛出的错误信息记录到LOG日志文件中去，告诉用户友好的提示信息</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>编程规范</tag>
      </tags>
  </entry>
  <entry>
    <title>linux命令之netstat</title>
    <url>/2018/05/13/linux%E5%91%BD%E4%BB%A4%E4%B9%8Bnetstat/</url>
    <content><![CDATA[<h2 id="netstat命令各个参数说明如下："><a href="#netstat命令各个参数说明如下：" class="headerlink" title="netstat命令各个参数说明如下："></a>netstat命令各个参数说明如下：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">　　-t : 指明显示TCP端口</span><br><span class="line"></span><br><span class="line">　　-u : 指明显示UDP端口</span><br><span class="line"></span><br><span class="line">　　-l : 仅显示监听套接字(所谓套接字就是使应用程序能够读写与收发通讯协议(protocol)与资料的程序)</span><br><span class="line"></span><br><span class="line">　　-p : 显示进程标识符和程序名称，每一个套接字/端口都属于一个程序。</span><br><span class="line"></span><br><span class="line">　　-n : 不进行DNS轮询，显示IP(可以加速操作)</span><br></pre></td></tr></table></figure>
<p><strong>即可显示当前服务器上所有端口及进程服务，于grep结合可查看某个具体端口及服务情况··</strong></p>
<p><strong>netstat -ntlp   //查看当前所有tcp端口·</strong></p>
<p><strong>netstat -ntulp |grep 80   //查看所有80端口使用情况·</strong></p>
<p><strong>netstat -an | grep 3306   //查看所有3306端口使用情况·</strong></p>
<p><strong>查看一台服务器上面哪些服务及端口</strong></p>
<p><strong>netstat  -lanp</strong></p>
<p><strong>查看一个服务有几个端口。比如要查看mysqld</strong></p>
<p><strong>ps -ef |grep mysqld</strong></p>
<p><strong>查看某一端口的连接数量,比如3306端口</strong></p>
<p><strong>netstat -pnt |grep :3306 |wc</strong></p>
<p><strong>查看某一端口的连接客户端IP 比如3306端口</strong></p>
<p><strong>netstat -anp |grep 3306</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -an 查看网络端口 </span><br><span class="line"></span><br><span class="line">lsof -i :port，使用lsof -i :port就能看见所指定端口运行的程序，同时还有当前连接。 </span><br><span class="line"></span><br><span class="line">nmap 端口扫描</span><br><span class="line">netstat -nupl  (UDP类型的端口)</span><br><span class="line">netstat -ntpl  (TCP类型的端口)</span><br><span class="line">netstat -anp 显示系统端口使用情况</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
        <category>linux命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
        <tag>netstat命令</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>linux命令之ubuntu查看系统信息</title>
    <url>/2018/01/09/linux%E5%91%BD%E4%BB%A4%E4%B9%8Bubuntu%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<p>要查看Ubuntu操作系统的位数是32位还是64位，可以通过以下命令来查看：</p>
<h1 id="查看long的位数，返回32或64"><a href="#查看long的位数，返回32或64" class="headerlink" title="查看long的位数，返回32或64"></a>查看long的位数，返回32或64</h1><p>可以在终端terminal下输入命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">getconf LONG_BIT</span><br></pre></td></tr></table></figure></p>
<p>输出结果<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">32</span><br></pre></td></tr></table></figure></p>
<p><img src="2018-01-16 20-46-51屏幕截图.png" alt="2018-01-16 20-46-51屏幕截图.png"><br>也可以输入：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uname -a</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Linux jacklu 4.13.0-26-generic <span class="comment">#29~16.04.2-Ubuntu SMP Tue Jan 9 21:38:24 UTC 2018 i686 i686 i686 GNU/Linux</span></span><br></pre></td></tr></table></figure></p>
<p><img src="2018-01-16 20-47-17屏幕截图.png" alt="2018-01-16 20-47-17屏幕截图.png"></p>
<h1 id="查看Ubuntu版本："><a href="#查看Ubuntu版本：" class="headerlink" title="查看Ubuntu版本："></a>查看Ubuntu版本：</h1><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>在终端中执行下列指令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /etc/issue</span><br></pre></td></tr></table></figure></p>
<p>可以查看当前正在运行的 Ubuntu 的版本号。其输出结果类似下面的内容：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Ubuntu 16.04.3 LTS \n \l</span><br></pre></td></tr></table></figure></p>
<p><img src="2018-01-16 20-48-47屏幕截图.png" alt="2018-01-16 20-48-47屏幕截图.png"></p>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>使用 lsb_release 命令也可以查看 Ubuntu 的版本号，与方法一相比，内容更为详细。执行指令如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo lsb_release -a</span><br></pre></td></tr></table></figure></p>
<p>将输出结果：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID:	Ubuntu</span><br><span class="line">Description:	Ubuntu 16.04.3 LTS</span><br><span class="line">Release:	16.04</span><br><span class="line">Codename:	xenial</span><br></pre></td></tr></table></figure></p>
<p><img src="2018-01-16 20-48-27屏幕截图.png" alt="2018-01-16 20-48-27屏幕截图.png"></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>linux命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
        <tag>查看系统信息</tag>
      </tags>
  </entry>
  <entry>
    <title>linux命令之关机命令</title>
    <url>/2018/01/09/linux%E5%91%BD%E4%BB%A4%E4%B9%8B%E5%85%B3%E6%9C%BA%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>ubuntu关机和重启命令</p>
<p>linux下常用的关机命令有：shutdown、halt、poweroff、init；重启命令有：reboot。下面本文就主要介绍一些常用的关机命令以及各种关机命令之间的区别和具体用法。<br><a id="more"></a></p>
<h1 id="关机命令："><a href="#关机命令：" class="headerlink" title="关机命令："></a>关机命令：</h1><p>1、halt                             立刻关机<br>2、poweroff                    立刻关机<br>3、shutdown -h now     立刻关机(root用户使用)<br>4、shutdown -h 10       10分钟后自动关机 如果是通过shutdown命令设置关机的话，可以用<code>shutdown -c</code>命令取消重启</p>
<h1 id="重启命令："><a href="#重启命令：" class="headerlink" title="重启命令："></a>重启命令：</h1><p>1、reboot<br>2、shutdown -r now           立刻重启(root用户使用)<br>3、shutdown -r 10              过10分钟自动重启(root用户使用)<br>4、shutdown -r 20:35         在时间为20:35时候重启(root用户使用) 如果是通过shutdown命令设置重启的话，可以用<code>shutdown -c</code>命令取消重启</p>
<p>下面我们来看看linux的这些具体的关机命令之间的区别和各自的用法</p>
<h3 id="1-shutdown-安全的关机命令"><a href="#1-shutdown-安全的关机命令" class="headerlink" title="1.shutdown 安全的关机命令"></a>1.shutdown 安全的关机命令</h3><p>对于shutdown命令，它是大家都推荐的一个安全的命令，通过参数-h或-r的配合来完成关机或重启。不过在linux系统中只有拥有root权限才可以使用这个命令。所以，虽然大家都推荐用这个命令，但是这个命令用起来真的不太方便：想要用这个命令吗？先去获得root权限吧。shutdown执行关机，是送信号给init，要求它改变运行级别，以此来关机。关机或重启实际上是运行级别的调整，所以我们也可以用init直接调整运行级别来进行关机或重启。使用这个命令时，机器立即关机或重启。它也需要root权限。</p>
<p>那么为什么说shutdown命令是安全地将系统关机呢？</p>
<p>实际中有些用户会使用直接断掉电源的方式来关闭linux，这是十分危险的。因为linux与windows不同，其后台运行着许多进程，所以强制关机可能会导致进程的数据丢失使系统处于不稳定的状态。甚至在有的系统中会损坏硬件设备。而在系统关机前使用shutdown命令，系统管理员会通知所有登录的用户系统将要关闭。并且login指令会被冻结，即新的用户不能再登录。直接关机或者延迟一定的时间才关机都是可能的，还有可能是重启。这是由所有进程〔process〕都会收到系统所送达的信号〔signal〕决定的。</p>
<p>shutdown执行它的工作是送信号〔signal〕给init程序，要求它改变 runlevel。runlevel 0 被用来停机〔halt〕，runlevel 6 是用来重新激活〔reboot〕系统，而 runlevel 1则是被用来让系统进入管理工作可以进行的状态，这是预设的。假定没有-h也没有-r参数给shutdown。要想了解在停机〔halt〕或者重新开机〔reboot〕过程中做了哪些动作？你可以在这个文件/etc/inittab里看到这些runlevels相关的资料。</p>
<p>shutdown 参数说明:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">   --<span class="built_in">help</span>      Show this <span class="built_in">help</span></span><br><span class="line">-H --halt      Halt the machine</span><br><span class="line">-P --poweroff  Power-off the machine</span><br><span class="line">-r --reboot    Reboot the machine</span><br><span class="line">-h             Equivalent to --poweroff, overridden by --halt</span><br><span class="line">-k             Don<span class="string">'t halt/power-off/reboot, just send warnings</span></span><br><span class="line"><span class="string">   --no-wall   Don'</span>t send wall message before halt/power-off/reboot</span><br><span class="line">-c             Cancel a pending shutdown</span><br></pre></td></tr></table></figure></p>
<p>[-t] 在改变到其它runlevel之前，告诉init多久以后关机。 </p>
<p>[-r] 重启计算器。</p>
<p>[-k] 并不真正关机，只是送警告信号给每位登录者〔login〕。 </p>
<p>[-h] 关机后关闭电源〔halt〕。 </p>
<p>[-n] 不用init而是自己来关机。不鼓励使用这个选项，而且该选项所产生的后果往往不总是你所预期得到的。 </p>
<p>[-c] cancel current process取消目前正在执行的关机程序。所以这个选项当然没有时间参数，但是可以输入一个用来解释的讯息，而这信息将会送到每位使用者。 </p>
<p>[-f] 在重启计算器〔reboot〕时忽略fsck。 </p>
<p>[-F] 在重启计算器〔reboot〕时强迫fsck。 </p>
<p>[-time] 设定关机〔shutdown〕前的时间。 　　 　　<br>2.halt 最简单的关机命令</p>
<p>用halt命令来关机时，实际调用的是shutdown -h。halt 执行时将杀死应用进程，执行sync系统调用文件系统写操作完成后就会停止内核。</p>
<h3 id="2-halt-参数说明"><a href="#2-halt-参数说明" class="headerlink" title="2.halt 参数说明:"></a>2.halt 参数说明:</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iotts@jacklu:~/HEXO_test$ halt --<span class="built_in">help</span></span><br><span class="line">halt [OPTIONS...]</span><br><span class="line"></span><br><span class="line">Halt the system.</span><br><span class="line"></span><br><span class="line">     --<span class="built_in">help</span>      Show this <span class="built_in">help</span></span><br><span class="line">     --halt      Halt the machine</span><br><span class="line">  -p --poweroff  Switch off the machine</span><br><span class="line">     --reboot    Reboot the machine</span><br><span class="line">  -f --force     Force immediate halt/power-off/reboot</span><br><span class="line">  -w --wtmp-only Don<span class="string">'t halt/power-off/reboot, just write wtmp record</span></span><br><span class="line"><span class="string">  -d --no-wtmp   Don'</span>t write wtmp record</span><br><span class="line">     --no-wall   Don<span class="string">'t send wall message before halt/power-off/reboot</span></span><br></pre></td></tr></table></figure>
<p>[-n] 防止sync系统调用，它用在用fsck修补根分区之后，以阻止内核用老版本的超级块〔superblock〕覆盖修补过的超级块。</p>
<p>[-w] 并不是真正的重启或关机，只是写wtmp〔/var/log/wtmp〕纪录。 </p>
<p>[-d] 不写wtmp纪录〔已包含在选项[-n]中〕。 </p>
<p>[-f] 没有调用shutdown而强制关机或重启。 </p>
<p>[-i] 关机〔或重启〕前关掉所有的网络接口。 </p>
<p>[-p] 该选项为缺省选项。就是关机时调用poweroff。</p>
<h3 id="3-poweroff-常用的关机命令"><a href="#3-poweroff-常用的关机命令" class="headerlink" title="3.poweroff 常用的关机命令"></a>3.poweroff 常用的关机命令</h3><p>对于poweroff，网上说它是halt命令的链接，基本用法和 halt 差不多，这里就不多说了。</p>
<h3 id="4-init"><a href="#4-init" class="headerlink" title="4.init"></a>4.init</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iotts@jacklu:~/HEXO_test$ init --<span class="built_in">help</span></span><br><span class="line">init [OPTIONS...] &#123;COMMAND&#125;</span><br><span class="line"></span><br><span class="line">Send control commands to the init daemon.</span><br><span class="line"></span><br><span class="line">     --<span class="built_in">help</span>      Show this <span class="built_in">help</span></span><br><span class="line">     --no-wall   Don<span class="string">'t send wall message before halt/power-off/reboot</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Commands:</span></span><br><span class="line"><span class="string">  0              Power-off the machine</span></span><br><span class="line"><span class="string">  6              Reboot the machine</span></span><br><span class="line"><span class="string">  2, 3, 4, 5     Start runlevelX.target unit</span></span><br><span class="line"><span class="string">  1, s, S        Enter rescue mode</span></span><br><span class="line"><span class="string">  q, Q           Reload init daemon configuration</span></span><br><span class="line"><span class="string">  u, U           Reexecute init daemon</span></span><br></pre></td></tr></table></figure>
<p>init是所有进程的祖先，他是Linux系统操作中不可缺少的程序之一。它的进程号始终为1，所以发送TERM信号给init会终止所有的用户进程，守护进程等。shutdown 就是使用这种机制。init定义了8个运行级别(runlevel)，init 0为关机，init 1为重启。</p>
<h3 id="5-reboot-重启命令"><a href="#5-reboot-重启命令" class="headerlink" title="5.reboot 重启命令"></a>5.reboot 重启命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iotts@jacklu:~/HEXO_test$ reboot --<span class="built_in">help</span></span><br><span class="line">reboot [OPTIONS...] [ARG]</span><br><span class="line"></span><br><span class="line">Reboot the system.</span><br><span class="line"></span><br><span class="line">     --<span class="built_in">help</span>      Show this <span class="built_in">help</span></span><br><span class="line">     --halt      Halt the machine</span><br><span class="line">  -p --poweroff  Switch off the machine</span><br><span class="line">     --reboot    Reboot the machine</span><br><span class="line">  -f --force     Force immediate halt/power-off/reboot</span><br><span class="line">  -w --wtmp-only Don<span class="string">'t halt/power-off/reboot, just write wtmp record</span></span><br><span class="line"><span class="string">  -d --no-wtmp   Don'</span>t write wtmp record</span><br><span class="line">     --no-wall   Don<span class="string">'t send wall message before halt/power-off/reboot</span></span><br></pre></td></tr></table></figure>
<p>reboot的工作过程差不多跟halt一样。不过它是引发主机重启，而halt是关机。它的参数与halt相差不多。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>linux命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
        <tag>基础</tag>
        <tag>关机重启</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs-快速搭建mqtt服务器</title>
    <url>/2019/11/15/nodejs-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAmqtt%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>前言：<br>实现MQTT服务器及客户端的方法有很多种，今天我们学习一下怎么使用nodejs实现mqtt协议，这里我们主要使用两个工具mosca和mqtt.js<br>首先需要了解一下mosca和mqtt.js的关系，下面这张图能清晰的解释如何通过mqtt协议进行交互通信</p>
<p><img src="mqtt.png" alt="mqtt.png"></p>
<h2 id="1-下载nodejs"><a href="#1-下载nodejs" class="headerlink" title="1.下载nodejs"></a>1.下载nodejs</h2><p>下载地址：<a href="http://nodejs.cn/download/" target="_blank" rel="noopener">http://nodejs.cn/download/</a><br>根据需要下载合适的自己平台的软件<br>这里我下载的是windows的64位msi，下载好直接安装就行了，直接下一步直到完成。</p>
<h2 id="2-安装mqtt-js模块"><a href="#2-安装mqtt-js模块" class="headerlink" title="2.安装mqtt.js模块"></a>2.安装mqtt.js模块</h2><p>这一步非常简单，在你心仪的那个文件夹下打开cmd窗口然后输入<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install mqtt --save命令即可。</span><br></pre></td></tr></table></figure></p>
<p>安装好会出现如下图红圈内的文件夹及文件</p>
<a id="more"></a>
<p>创建一个客户端进行测试<br>在刚刚安装mqtt.js文件夹下创建一个mqtt-test.js文件，然后键入以下代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var mqtt = require(&apos;mqtt&apos;)</span><br><span class="line">var client  = mqtt.connect(&apos;mqtt://test.mosquitto.org&apos;)</span><br><span class="line"></span><br><span class="line">client.on(&apos;connect&apos;, function () &#123;</span><br><span class="line">  client.subscribe(&apos;presence&apos;)</span><br><span class="line">  client.publish(&apos;presence&apos;, &apos;Hello mqtt&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">client.on(&apos;message&apos;, function (topic, message) &#123;</span><br><span class="line">  // message is Buffer</span><br><span class="line">  console.log(message.toString())</span><br><span class="line">  client.end()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>然后在此文件夹下打开cmd输入node mqtt-test.js就会出现如下图所示结果</p>
<p>测试结果.png<br>这样就说明你的mqtt模块就建立好了，但这仅限于客户端的使用为了使我们更方便的使用我们将在本地搭建一个服务器</p>
<h2 id="3-安装mosca"><a href="#3-安装mosca" class="headerlink" title="3.安装mosca"></a>3.安装mosca</h2><p>下面来说说如何建立服务端<br>安装mosca（和上面安装mqtt.js一样）<br>打开cmd然后输入<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install mosca --save</span><br></pre></td></tr></table></figure></p>
<p>创建mqtt-server.js文件<br>代码如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var mosca = require(&apos;mosca&apos;);</span><br><span class="line"></span><br><span class="line">var ascoltatore = &#123;</span><br><span class="line">  //using ascoltatore</span><br><span class="line">  //type: &apos;mongo&apos;,</span><br><span class="line">  //url: &apos;mongodb://localhost:27017/mqtt&apos;,</span><br><span class="line">  //pubsubCollection: &apos;ascoltatori&apos;,</span><br><span class="line">  //mongo: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var settings = &#123;</span><br><span class="line">  port: 1883,</span><br><span class="line">  http: &#123;</span><br><span class="line">    port: 3000,</span><br><span class="line">    bundle: true,</span><br><span class="line">    static: &apos;./&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var server = new mosca.Server(settings);</span><br><span class="line"></span><br><span class="line">server.on(&apos;clientConnected&apos;, function(client) &#123;</span><br><span class="line">    console.log(&apos;client connected&apos;, client.id);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// fired when a message is received</span><br><span class="line">server.on(&apos;published&apos;, function(packet, client) &#123;</span><br><span class="line">  console.log(&apos;Published&apos;, packet.payload);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.on(&apos;ready&apos;, setup);</span><br><span class="line"></span><br><span class="line">// fired when the mqtt server is ready</span><br><span class="line">function setup() &#123;</span><br><span class="line">  console.log(&apos;Mosca server is up and running&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后在此文件夹下打开cmd 输入node mqtt-server.js<br>若显示下图所示，则说明本地mqtt服务端搭建完成</p>
<p>服务端的搭建.png<br>链接自己的mqtt服务端<br>将mqtt-test.js中的mqtt://test.mosquitto.org改为mqtt://127.0.0.1即可<br>然后打开两个终端<br>一个是运行服务端的<br>另一个运行客户端<br>首先运行服务端，然后在运行客户端，若出现下图所示</p>
<p>客户端.png</p>
<p>服务端.png</p>
<p>mosca html客户端代码</p>
<p>1、生成browserMqtt.js ，拷贝出来，放到和index.html目录下面<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd node_modules/mqtt</span><br><span class="line">npm install .</span><br><span class="line"> webpack mqtt.js ./browserMqtt.js --output-library mqtt</span><br></pre></td></tr></table></figure></p>
<p>2、创建index.html</p>
<ul>
<li>注意：html客户端的地址是ws://localhost:3000，这个ws开头表示是websocket的地址，端口号是3000，不是</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;script src=&quot;./browserMqtt.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        console.log(&apos;hello 0 &apos;);</span><br><span class="line">      var client = mqtt.connect(&quot;ws://10.8.5.79:3000&quot;);</span><br><span class="line">      console.log(&apos;hello 1&apos;);</span><br><span class="line">      client.subscribe(&quot;mqtt/demo&quot;);</span><br><span class="line">      console.log(&apos;hello 12&apos;);</span><br><span class="line">      client.on(&quot;message&quot;, function(topic, payload) &#123;</span><br><span class="line">        alert([topic, payload].join(&quot;: &quot;));</span><br><span class="line">        client.end();</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      client.publish(&quot;mqtt/demo&quot;, &quot;hello world!&quot;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>附：参考链接<br>mqtt.js<br>mosca</p>
]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>MQTT</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs-设置国内源</title>
    <url>/2019/11/15/nodejs-%E8%AE%BE%E7%BD%AE%E5%9B%BD%E5%86%85%E6%BA%90/</url>
    <content><![CDATA[<p>npm 是node.js 环境下的包管理器,非常强大智能.</p>
<p>为什么要换源? npm 官方站点 <a href="http://www.npmjs.org/" target="_blank" rel="noopener">http://www.npmjs.org/</a> 并没有被墙,但是下载第三方依赖包的速度让人着急啊!</p>
<p>幸运的是,国内有几个镜像站点可以供我们使用<br><a id="more"></a><br><a href="http://www.cnpmjs.org/" target="_blank" rel="noopener">http://www.cnpmjs.org/</a><br><a href="http://registry.npm.taobao.org" target="_blank" rel="noopener">http://registry.npm.taobao.org</a></p>
<p>速度非常快,镜像站会实时更新,为我们节省了好多时间.如何给本机换源呢?</p>
<p>(1)通过 config 配置指向国内镜像源<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config set registry http://registry.npm.taobao.org //配置指向源</span><br><span class="line">npm info express  //下载安装第三方包</span><br></pre></td></tr></table></figure></p>
<p>(2)通过 npm 命令指定下载源<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm --registry http://registry.cnpmjs.org info express</span><br></pre></td></tr></table></figure></p>
<p>(3)在配置文件 ~/.npmrc 文件写入源地址<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nano ~/.npmrc   //打开配置文件</span><br><span class="line">registry =https://registry.npm.taobao.org   //写入配置文件</span><br></pre></td></tr></table></figure></p>
<p>推荐使用最后一种方法,前面2钟方法都是临时改变包下载源.</p>
<p>如果你不想使用国内镜像站点,只需要将 写入 ~/.npmrc 的配置内容删除即可.</p>
]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>开源NAS操作系统</title>
    <url>/2020/03/27/%E5%BC%80%E6%BA%90NAS%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>   作为一个程序员，资料备份经常会用到NAS服务器，也就是文件服务器，NAS除了能够办公使用外，还可以作为家庭媒体中心，我们可以存储一些电影，游戏。商用比较有名的有群晖，大家可能都听说过，很好用，但是机器的价格有点偏贵，为了克服这点网上也有用户用普通PC制作黑群晖的教程，今天给大家介绍几款免费开源的NAS系统，首先声明，本文是在网上收集的资料，实际使用难免会有一些不同的地方，仅供参考</p>
<a id="more"></a>
<ol>
<li>FreeNAS®，目前最受欢迎的开源免费 NAS 操作系统之一，基于以安全和稳定著称的 FreeBSD 系统开发，由 ixsystems 公司的技术团队维护。我自己装过这个，使用确实很方便，硬件要求还可以<br>项目地址：<a href="http://www.freenas.org" target="_blank" rel="noopener">http://www.freenas.org</a></li>
<li>NAS4Free，基于 FreeNAS 0.7 开发的一个分支，由原 FreeNAS 系统开发者发起创建。许多恋旧的朋友忠实的跟随，安装要求没有 FreeNAS 高，版本更新也很及时。<br>项目地址：<a href="http://www.nas4free.org" target="_blank" rel="noopener">http://www.nas4free.org</a></li>
<li>OpenMediaVault，由原 FreeNAS 核心开发成员 Volker Theile 发起的基于 Debian Linux 的开源 NAS 操作系统，主要面向家庭用户和小型办公环境，最近发布了针对树莓派的安装包，值得关注。<br>项目地址：<a href="http://www.openmediavault.org" target="_blank" rel="noopener">http://www.openmediavault.org</a></li>
<li>Openfiler，另一款基于浏览器管理的开源 NAS 操作系统，许多人说他好用，因为它基于 rPath Linux 开发。2013年以后，这款 NAS 系统的开源版本再没有更新。<br>项目地址：<a href="http://www.openfiler.com" target="_blank" rel="noopener">http://www.openfiler.com</a></li>
<li>NexentaStor，基于 OpenSolaris 开发，与 FreeNAS 一样采用强大的 ZFS 文件系统。该系统由 Nexenta Systems 公司技术团队维护，同时提供社区开原版和商业付费版本，社区开原版有 18TB 的存储容量限制，有人说 NexentaStor 比 OpenFiler 好用。<br>项目地址：<a href="http://www.nexentastor.org" target="_blank" rel="noopener">http://www.nexentastor.org</a></li>
<li>RockStor，一款基于 Linux 的开源 NAS 系统，采用企业级文件系统 BTRFS，提供 SMB/CIFS、NFS 以及 SFTP 常见的共享方式。第一个 ISO 镜像发布于 2014-10-02，可见这套 NAS 系统初出茅庐，暂无简体中文支持。不过官网文档已经备齐，保持关注，可能有一番作为。<br>项目地址：<a href="http://rockstor.com" target="_blank" rel="noopener">http://rockstor.com</a></li>
<li>EasyNAS，另一款非常年轻的 NAS 系统，与 RockStor 很像，同样采用企业级文件系统 BTRFS，但官方网站和文档会略逊一筹，第一个 ISO 镜像发布于 2014-05-10。<br>项目地址：<a href="http://www.easynas.org" target="_blank" rel="noopener">http://www.easynas.org</a></li>
<li>NASLite-2，是少数基于 Linux 的商用 NAS 操作系统，由 Server Elements 公司出品，需要支付29.95 美元才能下载 ISO 镜像文件。<br>项目地址：<a href="http://www.serverelements.com/?target=NASLite-2" target="_blank" rel="noopener">http://www.serverelements.com/?target=NASLite-2</a></li>
<li>NanoNAS，同样出自 Server Elements 公司，它是 NASLite-2 的精简版，需支付 9.95 美元才可以下载 ISO 镜像文件。<br>项目地址：<a href="http://www.serverelements.com/?target=NanoNAS" target="_blank" rel="noopener">http://www.serverelements.com/?target=NanoNAS</a></li>
<li>CryptoNAS，以前叫做CryptoBox，是一个专注于磁盘加密的项目，提供基于 Linux 的 LiveCD，整合了 NAS 服务器加密功能，此外，也提供了安装包，可直接安装到现有 Linux 服务器上，为磁盘加密提供友好的浏览器管理界面。<br>项目地址：<a href="http://cryptonas.senselab.org" target="_blank" rel="noopener">http://cryptonas.senselab.org</a></li>
<li>Webmin，它不是 NAS 操作系统，但可以实现基本的 samba 共享功能，webmin 是目前功能最强大的基于浏览器的 Unix 系统管理工具。可以安装在几乎所有的类 Unix 操作系统上面。特别适合刚入门的用户管理 Linux 服务器。<br>项目地址：<a href="http://www.webmin.cn" target="_blank" rel="noopener">http://www.webmin.cn</a></li>
<li>GlusterFS，由 Z RESEARCH 公司负责开发，最近非常活跃。 文档也比较齐全，不难上手。GlusterFS 通过 Infiniband RDMA 或 TCP/IP 协议将多台廉价的 x86 主机，通过网络互联成一个并行的网络文件系统。据说 Gluster 已被 RedHat 收购，求证实。<br>项目地址：<a href="http://www.gluster.org" target="_blank" rel="noopener">http://www.gluster.org</a></li>
<li>Lustre®，为解决海量存储问题而设计的全新文件系统。是下一代的集群文件系统，可支持10,000个节点，PB的存储量，100GB/S的传输速度，完美的安全性和可管理性。 目前Lustre已经运用在一些领域，例如HP SFS产品等。<br>项目地址：<a href="http://lustre.org" target="_blank" rel="noopener">http://lustre.org</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>物联网技术之服务器端数据采集环境简单搭建</title>
    <url>/2018/01/10/%E7%89%A9%E8%81%94%E7%BD%91%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E7%8E%AF%E5%A2%83%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="1-创建数据库"><a href="#1-创建数据库" class="headerlink" title="1.创建数据库"></a>1.创建数据库</h2><p>在MySql数据库中创建一个名为<code>Sensor_server</code>的数据库，如下图：<br><img src="微信截图_20180111003012.png" alt="微信截图_20180111003012.png"><br>在数据库中创建一个名为<code>sensor_test</code>的数据表，使用如下SQL语句：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS `sensor_test` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `sen_id` int(11) NOT NULL,</span><br><span class="line">  `temp` int(11) NOT NULL,</span><br><span class="line">  `humi` int(11) NOT NULL,</span><br><span class="line">  `pm25` int(11) NOT NULL,</span><br><span class="line">  `pm10` int(11) NOT NULL,</span><br><span class="line">  `pm100` int(11) NOT NULL,</span><br><span class="line">  `co2` int(11) NOT NULL,</span><br><span class="line">  `ze08` int(11) NOT NULL,</span><br><span class="line">  `tvoc` int(11) NOT NULL,</span><br><span class="line">  `timeStamp` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP</span><br><span class="line">) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4;</span><br></pre></td></tr></table></figure></p>
<p><img src="微信截图_20180111001007.png" alt="微信截图_20180111001007.png"></p>
<h2 id="2-创建PHP文件"><a href="#2-创建PHP文件" class="headerlink" title="2.创建PHP文件"></a>2.创建PHP文件</h2><h3 id="2-1-创建数据库连接PHP文件"><a href="#2-1-创建数据库连接PHP文件" class="headerlink" title="2.1 创建数据库连接PHP文件"></a>2.1 创建数据库连接PHP文件</h3><p>创建名为<code>database.php</code> 的文件，写入以下代码：<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$connect=mysqli_connect(<span class="string">'localhost'</span>,<span class="string">'用户名（最好不用root）'</span>,<span class="string">'数据库密码'</span>,<span class="string">'sensor_server'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(mysqli_connect_errno($connect)) printf(<span class="string">"Failed to connect"</span>);</span><br><span class="line"><span class="keyword">else</span> printf(<span class="string">"Success to Connect\r\n"</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="2-2-创建数据库操作PHP文件"><a href="#2-2-创建数据库操作PHP文件" class="headerlink" title="2.2 创建数据库操作PHP文件"></a>2.2 创建数据库操作PHP文件</h3><p>创建名为<code>process.php</code> 的文件，写入以下代码：<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">header(<span class="string">"Content-type:text/html;charset=utf-8"</span>);</span><br><span class="line">date_default_timezone_set(<span class="string">"Asia/Shanghai"</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"当前时间是 "</span> . date(<span class="string">"H:i:s"</span>).<span class="string">"&lt;br&gt;"</span>;</span><br><span class="line"><span class="keyword">include</span>(<span class="string">"database.php"</span>);</span><br><span class="line">	$sen_id=$_POST[<span class="string">'sen_id'</span>];</span><br><span class="line">	$pm25=$_POST[<span class="string">'pm25'</span>];</span><br><span class="line">	$pm10=$_POST[<span class="string">'pm10'</span>];</span><br><span class="line">	$co2=$_POST[<span class="string">'co2'</span>];</span><br><span class="line">	$tvoc=$_POST[<span class="string">'tvoc'</span>];</span><br><span class="line">	$pm100=$_POST[<span class="string">'pm100'</span>];</span><br><span class="line">	$ze08=$_POST[<span class="string">'ze08'</span>];</span><br><span class="line">	$temp=$_POST[<span class="string">'temp'</span>];</span><br><span class="line">	$humi=$_POST[<span class="string">'humi'</span>];</span><br><span class="line">	$id=$_POST[<span class="string">'id'</span>];</span><br><span class="line">	print_r($_POST);</span><br><span class="line">	mysqli_query($connect,<span class="string">"INSERT INTO sensor_test(pm25,pm10,pm100,co2,tvoc,temp,humi,ze08,id,sen_id) VALUES('$pm25','$pm10','$pm100','$co2','$tvoc','$temp','$humi','$ze08','$id','$sen_id')"</span>);</span><br><span class="line"></span><br><span class="line">	mysqli_close($connect);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>物联网相关</category>
        <category>服务器端相关</category>
      </categories>
      <tags>
        <tag>物联网</tag>
        <tag>服务器操作</tag>
        <tag>数据采集</tag>
        <tag>Mysql</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>用Visual Studio 2015开发Arduino应用程序</title>
    <url>/2018/01/14/%E7%94%A8Visual-Studio-2015%E5%BC%80%E5%8F%91Arduino%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<p><a href="http://blog.csdn.net/yapingxin/article/details/51386451" target="_blank" rel="noopener">原文连接</a></p>
<h2 id="Arduino-IDE-的缺点"><a href="#Arduino-IDE-的缺点" class="headerlink" title="Arduino IDE 的缺点"></a>Arduino IDE 的缺点</h2><p>虽然 Arduino 很流行很火爆，但是 Arduino IDE 却非常、非常、非常弱。编写代码很不方便，只能说提供了一个最基本的写代码的工具而已，调试代码也很不方便。而且，Arduino IDE 中写代码，只能是把所有的源代码都集中在一个 .ino 文件中，对于写惯了 C++ 程序的工程师来说，Arduino IDE 完全不具备工程化的可能，只能给一般的爱好者当一个玩具而已。</p>
<p>所以，本教程既然大言不惭地号称是“高级”教程，首先要做的就是替换掉 Arduino IDE 这个开发工具。当然实际上并不是真的替换掉了 Arduino IDE 的所有的东西，而是把它的有用的工具链（gcc toolchain）进行了重用，然后编写代码、代码管理和调试等工作由更现代化的工具来完成。</p>
<h2 id="代替Arduino-IDE工具安装"><a href="#代替Arduino-IDE工具安装" class="headerlink" title="代替Arduino IDE工具安装"></a>代替Arduino IDE工具安装</h2><p>替代工具：Arduino for Visual Studio（Visual Micro）</p>
<p>说到太阳系中最强大和最友好的 C++ IDE，我个人认为是Visual Studio。当然您可能并不赞同我的说法，或许您更倾向于 Eclipse。好吧，您可以自行寻找解决办法，用 Eclipse 开发 Arduino 也是完全可行的，也有好事者用 vim 开发 Arduino……抱歉，扯远了。</p>
<p>在本节中，我们需要用到两个软件：</p>
<ol>
<li><p>Visual Studio</p>
</li>
<li><p>Visual Micro (Arduino for Visual Studio 插件)</p>
</li>
</ol>
<p>Visual Micro 的原理</p>
<p>简单说一下为什么我们可以在 Visual Studio 中开发 Arduino 应用程序。</p>
<p>官方的 Arduino IDE 开发 Arduino 应用程序，是这样的：<br><img src="clip_image001.png" alt="clip_image001.png"></p>
<p>而 Visual Studio + Visual Micro 开发 Arduino 应用程序，是这样的：<br><img src="clip_image002.png" alt="clip_image002.png"></p>
<p>所以说，我们替换掉的仅仅是 Arduino IDE 这个蹩脚的代码开发工具，但是编译、调试和代码烧写用的还是原来的 gcc toolchain。</p>
<p>$\color{red}{Notes：}$上图中，你会看到Atmel Studio。Atmel Studio是Atmel公司推出的免费开发工具，它是基于Visual Studio Shell的。所以本文虽然是针对Visual Studio来讲的，但也同时适用于Atmel Studio。</p>
<p>有关详细的Visual Micro工作原理的解释，请看这里：<a href="http://www.visualmicro.com/page/User-Guide.aspx?doc=How-The-Tools-Play-Together.html" target="_blank" rel="noopener">How the Software Tools WorkTogether</a></p>
<h3 id="Visual-Studio-安装"><a href="#Visual-Studio-安装" class="headerlink" title="Visual Studio 安装"></a>Visual Studio 安装</h3><p>Visual Studio 有很多版本，比如说 Professional、Enterprise、Ultimate……这些都可以用来开发 Arduino 应用程序。当然对于个人开发者来说，可能不会去购买付费版本的 Visual Studio，那么用免费的 Community 版本就可以了。</p>
<p>在本例中，我使用的是 Visual Studio Community 2015。</p>
<p>在安装 Visual Studio 的时候，有很多可选项，对于开发 Arduino 应用程序来说，只要装有 C++ 开发的安装选项即可。</p>
<h3 id="Visual-Micro-安装"><a href="#Visual-Micro-安装" class="headerlink" title="Visual Micro 安装"></a>Visual Micro 安装</h3><p>Visual Micro 的官方网站是：<a href="http://www.visualmicro.com/" target="_blank" rel="noopener">http://www.visualmicro.com</a><br>这个软件有收费版和免费版，收费版也不贵，Commercial $75<br>for 1 PC，批量有优惠。对于个人来说，装免费版就完全够用了。</p>
<p>所以说我们用的 Visual Studio 和 Visual Micro 都可以用免费的版本，对个人来说经济上零压力。</p>
<p>Visual Micro 下载下来是一个 .vsix 的安装包，双击就可以进行安装了。注意安装前要关掉 Visual Studio。<br><img src="clip_image003.png" alt="clip_image003"></p>
<p>接下来我们应该进行 Visual Micro 的设置。</p>
<h3 id="设置-Visual-Micro"><a href="#设置-Visual-Micro" class="headerlink" title="设置 Visual Micro"></a>设置 Visual Micro</h3><p>安装 Visual Micro 之后，首次打开 Visual Studio，就会弹出以下窗口：<br><img src="clip_image004.png" alt="clip_image004"></p>
<p>以上窗口中，我们需要正确选择 Arduino IDE 的版本和安装位置，好让 Visual Micro 能够帮助 Visual Studio 找到相应的 gcc toolchain。</p>
<p>至于其它的设置项（Optional sketchbook location、Optional additional boards manager urls），我们现在初始设置的时候可以先不理会，以后需要的时候可以再对此做设置。</p>
<p>实际上 Visual Micro 已经根据注册表里面的信息自动填好了初始设置项，我现在需要做的仅仅是确认无误之后点击“OK”按钮就可以了。</p>
<p>选择软件版本、开发板型号和端口</p>
<p>然后，你会发现 Visual Studio 的工具栏和菜单里面多了这些东西：</p>
<p><img src="clip_image005.png" alt="clip_image005"></p>
<p><img src="clip_image006.png" alt="clip_image006"></p>
<p>看来它是把 Arduino IDE 的工具栏和菜单里面的东西搬到这里来了。</p>
<h2 id="新建Arduino工程"><a href="#新建Arduino工程" class="headerlink" title="新建Arduino工程"></a>新建Arduino工程</h2><p>接下来我们就可以体验在 Visual Studio 里面写 Arduino 程序了。</p>
<p>如下图新建一个Aarduino工程<br><img src="clip_image008.png" alt="clip_image008.png"><br><img src="clip_image009.png" alt="clip_image009.png"><br>接下来我们先写一个点灯的程序<br>直接贴代码了<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void setup()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  /* add setup code here */</span><br><span class="line">	pinMode(13,OUTPUT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void loop()</span><br><span class="line">&#123;</span><br><span class="line">	digitalWrite(13, HIGH);</span><br><span class="line">	delay(200);</span><br><span class="line">	digitalWrite(13, LOW);</span><br><span class="line">	delay(200);</span><br><span class="line">  /* add main program code here */</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译的话我们选择正式编译Release<br>接下来根据开发板的具体情况选择板子类型、端口号<br><img src="clip_image010.png" alt="clip_image010.png"><br>点击<code>Start</code>编译并将程序下载到开发板上，然后就会看到灯在闪烁<br><img src="1.gif" alt="1.gif"></p>
]]></content>
      <categories>
        <category>Arduino相关</category>
        <category>Arduino IDE</category>
      </categories>
      <tags>
        <tag>单片机</tag>
        <tag>Arduino</tag>
      </tags>
  </entry>
  <entry>
    <title>简单实用的双向电平转换电路</title>
    <url>/2018/01/08/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%94%A8%E7%9A%84%E5%8F%8C%E5%90%91%E7%94%B5%E5%B9%B3%E8%BD%AC%E6%8D%A2%E7%94%B5%E8%B7%AF/</url>
    <content><![CDATA[<p>当你使用3.3V的单片机的时候，电平转换就在所难免了，经常会遇到3.3转5V或者5V转3.3V的情况，这里介绍一个简单的电路，他可以实现两个电平的相互转换(注意是相互哦，双向的，不是单向的!).电路十分简单，仅由3个电阻加一个MOS管构成。</p>
<p>　　电路图如下:<br> <img src="1.png" alt="1"></p>
<p>上图中，S1，S2为两个信号端，VCC_S1和VCC_S2为这两个信号的高电平电压.另外限制条件为:<br>　　1，VCC_S1&lt;=VCC_S2.<br>　　2，S1的低电平门限大于0.7V左右(视NMOS内的二极管压降而定).<br>　　3，Vgs&lt;=VCC_S1.<br>　　4，Vds&lt;=VCC_S2<br>　　对于3.3V和5V/12V等电路的相互转换，NMOS管选择AP2306即可.原理比较简单，大家自行分析吧!此电路我已在多处应用，效果很好.</p>
<p> <img src="2.png" alt="2"></p>
<p>I2C<br>　　类似这种吧，只是不知道这种电路的速率能达到多少<br>　　电平转换器的操作<br>　　在电平转换器的操作中要考虑下面的三种状态：<br>　　1 没有器件下拉总线线路。“低电压”部分的总线线路通过上拉电阻Rp 上拉至3.3V。 MOS-FET 管的门极和源极都是3.3V， 所以它的VGS 低于阀值电压，MOS-FET 管不导通。这就允许“高电压”部分的总线线路通过它的上拉电阻Rp 拉到5V。 此时两部分的总线线路都是高电平，只是电压电平不同。<br>　　2 一个3.3V器件下拉总线线路到低电平。MOS-FET管的源极也变成低电平，而门极是3.3V。VGS上升高于阀值，MOS-FET管开始导通。然后“高电压”部分的总线线路通过导通的MOS-FET管被3.3V器件下拉到低电平。此时，两部分的总线线路都是低电平，而且电压电平相同。<br>　　3 一个5V的器件下拉总线线路到低电平。MOS-FET管的漏极基底二极管“低电压”部分被下拉直到VGS超过阀值，MOS-FET管开始导通。“低电压”部分的总线线路通过导通的MOS-FET管被5V的器件进一步下拉到低电平。此时，两部分的总线线路都是低电平，而且电压电平相同。<br>　　这三种状态显示了逻辑电平在总线系统的两个方向上传输，与驱动的部分无关。状态1执行了电平转换功能。状态2和3按照I2C总线规范的要求在两部分的总线线路之间实现“线与”的功能。<br>　　除了3.3V VDD1和5V VDD2的电源电压外，还可以是例如：2V VDD1和10V VDD2。在正常操作中，VDD2必须等于或高于VDD1(在开关电源时允许VDD2低于VDD1)。<br>　　MOS-N场效应管双向电平转换电路—适用于低频信号电平转换的简单应用</p>
<p> <img src="3.png" alt="3"></p>
<p>如上图所示，是MOS-N场效应管双向电平转换电路。<br>　　双向传输原理：<br>　　为了方便讲述，定义 3.3V 为 A 端，5.0V 为 B 端。<br>　　A端输出低电平时(0V)，MOS管导通，B端输出是低电平(0V)<br>　　A端输出高电平时(3.3V)，MOS管截至，B端输出是高电平(5V)<br>　　A端输出高阻时(OC) ，MOS管截至，B端输出是高电平(5V)<br>　　B端输出低电平时(0V)，MOS管内的二极管导通，从而使MOS管导通，A端输出是低电平(0V)<br>　　B端输出高电平时(5V)，MOS管截至，A端输出是高电平(3.3V)<br>　　B端输出高阻时(OC) ，MOS管截至，A端输出是高电平(3.3V)<br>　　优点：<br>　　1、适用于低频信号电平转换，价格低廉。<br>　　2、导通后，压降比三极管小。<br>　　3、正反向双向导通，相当于机械开关。<br>　　4、电压型驱动，当然也需要一定的驱动电流，而且有的应用也许比三极管大。</p>
]]></content>
      <categories>
        <category>电路设计相关</category>
        <category>电平转换电路</category>
      </categories>
      <tags>
        <tag>电路设计</tag>
        <tag>3.3v 5v电平转换</tag>
      </tags>
  </entry>
  <entry>
    <title>经典电路之一键开关机及多用途按键设计</title>
    <url>/2019/12/19/%E7%BB%8F%E5%85%B8%E7%94%B5%E8%B7%AF%E4%B9%8B%E4%B8%80%E9%94%AE%E5%BC%80%E5%85%B3%E6%9C%BA%E5%8F%8A%E5%A4%9A%E7%94%A8%E9%80%94%E6%8C%89%E9%94%AE%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h3 id="mos管开关电路图"><a href="#mos管开关电路图" class="headerlink" title="mos管开关电路图"></a><strong>mos管开关电路图</strong></h3><p>图中电池的正电通过开关S1接到场效应管Q1的2脚源极，由于Q1是一个P沟道管，它的1脚栅极通过R20电阻提供一个正电位电压，所以不能通电，电压不能继续通过，3v稳压IC输入脚得不到电压所以就不能工作不开机！<br><a id="more"></a><br>这时，如果我们按下SW1开机按键时，正电通过按键、R11、R23、D4加到三极管Q2的基极，三极管Q2的基极得到一个正电位，三极管导通（前面讲到三极管的时候已经讲过），由于三极管的发射极直接接地，三极管Q2导通就相当于Q1的栅极直接接地，加在它上面的通过R20电阻的电压就直接入了地，Q1的栅极就从高电位变为低电位，Q1导通电就从Q1同过加到3v稳压IC的输入脚，3v稳压IC就是那个U1输出3v的工作电压vcc供给主控，主控通过复位清0，读取固件程序检测等一系列动作，输处一个控制电压到PWR_ON再通过R24、R13分压送到Q2的基极，保持Q2一直处于导通状态，即使你松开开机键断开Q1的基极电压，这时候有主控送来的控制电压保持着，Q2也就一直能够处于导通状态，Q1就能源源不断的给3v稳压IC提供工作电压！SW1还同时通过R11、R30两个电阻的分压，给主控PLAYON脚送去时间长短、次数不同的控制信号，主控通过固件鉴别是播放、暂停、开机、关机而输出不同的结果给相应的控制点，以达到不同的工作状态！<br><img src="20180612114430_9155.jpg" alt="最简单的mos管开关电路图"></p>
]]></content>
      <categories>
        <category>电路设计相关</category>
        <category>经典电路</category>
      </categories>
      <tags>
        <tag>PCB</tag>
        <tag>电路设计</tag>
      </tags>
  </entry>
  <entry>
    <title>经典电路之减法器</title>
    <url>/2018/01/08/%E7%BB%8F%E5%85%B8%E7%94%B5%E8%B7%AF%E4%B9%8B%E5%87%8F%E6%B3%95%E5%99%A8/</url>
    <content><![CDATA[<p>减法器有两种：一种是先对输入信号实现反相，然后再做加法运算；另一种是直接利用差分电路实现</p>
<h3 id="1-输入信号实现反相实现减法器"><a href="#1-输入信号实现反相实现减法器" class="headerlink" title="1.输入信号实现反相实现减法器"></a>1.输入信号实现反相实现减法器</h3><p><img src="543cf225x7ca35edcb97b&amp;690.jpg" alt="543cf225x7ca35edcb97b&amp;690.jpg"></p>
<h3 id="2-差分电路实现减法器"><a href="#2-差分电路实现减法器" class="headerlink" title="2.差分电路实现减法器"></a>2.差分电路实现减法器</h3><p><img src="543cf225x72dd2aab7ff5&amp;690.jpg" alt="543cf225x72dd2aab7ff5&amp;690.jpg"><br>我使用差分减法器比较多，主要用于电流、电压的测量<br>其计算输出电压的公式如下：</p>
<script type="math/tex; mode=display">V_o=\frac{R1+R4}{R1}(V_{i2}\frac{R3}{R2+R3}-V_{i1}\frac{R4}{R1+R4})</script><p>若令<strong>R1=R2,R3=R4</strong>,上式可简化为：</p>
<script type="math/tex; mode=display">V_o=\frac{R3}{R2}(V_{i2}-V_{i1})</script>]]></content>
      <categories>
        <category>电路设计相关</category>
        <category>经典电路</category>
      </categories>
      <tags>
        <tag>电路设计</tag>
        <tag>减法器电路</tag>
      </tags>
  </entry>
  <entry>
    <title>经典电路之惠斯通电桥原理及应用</title>
    <url>/2018/01/08/%E7%BB%8F%E5%85%B8%E7%94%B5%E8%B7%AF%E4%B9%8B%E6%83%A0%E6%96%AF%E9%80%9A%E7%94%B5%E6%A1%A5%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h2 id="1-电阻桥定义解释"><a href="#1-电阻桥定义解释" class="headerlink" title="1. 电阻桥定义解释"></a>1. 电阻桥定义解释</h2><p>   惠斯通电桥是由四个电阻组成的电桥电路，这四个电阻分别叫做电桥的桥臂，惠斯通电桥利用电阻的变化来测量物理量的变化，单片机采集可变电阻两端的电压然后处理，就可以计算出相应的物理量的变化，是一种精度很高的测量方式。其电路形式如下图所示。</p>
<p> <img src="110945pzcuhva3gm2cpncy.jpg" alt="110945pzcuhva3gm2cpncy"></p>
<p>   在电桥中有三个电阻阻值是固定的分别为R1，R2，R3，第四个电阻是可变的为Rx，Rx发生变化时，图中B,D两点之间的电压发生变化，通过采集电压的变化就可以知道环境中物理量的变化，而从实现测量的目的。下面举例介绍电桥电路的计算方式。</p>
<h2 id="2-电阻桥相关计算"><a href="#2-电阻桥相关计算" class="headerlink" title="2. 电阻桥相关计算"></a>2. 电阻桥相关计算</h2><p>   假设流过R1，R2桥臂的电流为I1，流过R3，Rx桥臂的电流为I2，电桥供电电压为VCC，如下图所示。<br><img src="fig1.png" alt="fig1"><br>   通过欧姆定律可以计算出每个电阻两端的电压。在R1和R2这两个桥臂上，R1，R2将VCC电压分压，R2电阻两端得到的电压即为V1；在R3和Rx这个桥臂上，R3，Rx将VCC电压分压，R3电阻两端得到的电压即为V2。下面分别用欧姆定律计算V1和V2。</p>
<p>   流过电阻R1和R2的电流I1: </p>
<script type="math/tex; mode=display">\ I1=\frac{VCC}{R1+R2}</script><p>   R2两端的电压V1：</p>
<script type="math/tex; mode=display">\ V1=I1\cdot R2=VCC\cdot\frac{R2}{R1+R2}</script><p>   流过电阻R3和Rx的电流I2:</p>
<script type="math/tex; mode=display">\ I2=\frac{VCC}{R3+Rx}</script><p>   R3两端的电压：</p>
<script type="math/tex; mode=display">\ V2=I2\cdot R3=VCC\cdot\frac{R3}{R3+Rx}</script><p>   V1和V2的电压差：</p>
<script type="math/tex; mode=display">\Delta V=V1-V2=VCC\cdot(\frac{R2}{R1+R2}-\frac{R3}{R3+Rx})</script><p>进一步计算得到：</p>
<script type="math/tex; mode=display">\Delta V=VCC\cdot(\frac{R2\cdot Rx-R3\cdot R1}{(R1+R2)(R3+Rx)})</script><p>由此可以看出：<br>如果4个电阻都相等，即R1=R2=R3=Rx，那么ΔV=0，即电桥处于平衡状态；　Rx发生变化会导致△V发生变化；</p>
<h2 id="3-电阻桥的应用"><a href="#3-电阻桥的应用" class="headerlink" title="3.电阻桥的应用"></a>3.电阻桥的应用</h2><p>   在实际使用中，我们通常将其中三个电阻值固定，而将另外一个电阻换成热敏电阻、压敏电阻、PT100等，这时候就可以用电桥来测物理量了。如果将PT100接入电桥，随着环境温度的变化，PT100的阻值发生变化导致ΔV发生变化，将差分电压ΔV通过差分运放放大后进入单片机的AD采样，再对照PT100的电阻-温度对应表就可以知道当前环境的温度了。</p>
]]></content>
      <categories>
        <category>电路设计相关</category>
        <category>经典电路</category>
      </categories>
      <tags>
        <tag>电路设计</tag>
        <tag>电阻测量</tag>
      </tags>
  </entry>
  <entry>
    <title>继电器驱动电路带隔离</title>
    <url>/2020/01/05/%E7%BB%A7%E7%94%B5%E5%99%A8%E9%A9%B1%E5%8A%A8%E7%94%B5%E8%B7%AF%E5%B8%A6%E9%9A%94%E7%A6%BB/</url>
    <content><![CDATA[<p>本文主要介绍如何使用光耦隔离并驱动继电器<br><a id="more"></a><br><img src="2c33ad368a65e4a08bb36a1ad44a6181.png" alt="2c33ad368a65e4a08bb36a1ad44a6181"></p>
]]></content>
      <categories>
        <category>电路设计相关</category>
        <category>控制类</category>
      </categories>
      <tags>
        <tag>PCB</tag>
      </tags>
  </entry>
  <entry>
    <title>[通信]Modbus协议</title>
    <url>/2020/04/03/%E9%80%9A%E4%BF%A1-Modbus%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p><br><br><div class="pdf" target="Modbus.pdf" height></div></p>
<div class="pdf" target="http://www.ti.com.cn/cn/lit/ds/symlink/dlp4500nir.pdf" height></div>
<p><br></p>
]]></content>
  </entry>
  <entry>
    <title>驱动数码管的几种方法</title>
    <url>/2020/02/26/%E9%A9%B1%E5%8A%A8%E6%95%B0%E7%A0%81%E7%AE%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Arduino教程之编写自己的Arduino库</title>
    <url>/2019/10/04/Arduino%E6%95%99%E7%A8%8B%E4%B9%8B%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84Arduino%E5%BA%93/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Arduino作为比较火的开源开发板，其丰富的库可以大大缩短开发周期,Arduino编程软件为Arduino IDE,编程思路和我们平常使用的IDE有所不同，Arduino编程没有main函数，因为好多东西都被隐藏了。一直想搞清楚，以便编写自己的库文件。下面是一些在网上搜集到的关于如何建立自己的库文件</p>
<a id="more"></a>
<h2 id="Arduino工程的初步认识"><a href="#Arduino工程的初步认识" class="headerlink" title="Arduino工程的初步认识"></a>Arduino工程的初步认识</h2><h3 id="1、目录规范"><a href="#1、目录规范" class="headerlink" title="1、目录规范"></a>1、目录规范</h3><p>首先创建一个空的工程，先按下ctrl+s保存一下。这个时候弹出对话框，命名工程。假如命名为IOTTS_LED，并保存在 我自己的Arduino工作目录下 <code>E:\arduino\IOTTS_Arduino\</code></p>
<p>于是IDE会自动帮我们在IOTTS_Arduino下创建1个文件夹，并将sketch(IOTTS_LED.ino)主文件放在里面，而且主文件和文件夹同名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IOTTS_Arduino</span><br><span class="line">|---IOTTS_LED</span><br><span class="line">    |---IOTTS_LED.ino</span><br></pre></td></tr></table></figure>
<h3 id="2、主文件代码框架规范"><a href="#2、主文件代码框架规范" class="headerlink" title="2、主文件代码框架规范"></a>2、主文件代码框架规范</h3><p>每一个Arduino程序（Sketch）都有1个主文件，后缀为 <strong>.ino</strong> ，它是程序的setup 函数和 loop函数所在的文件。</p>
<p>代码框架如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void setup() &#123;</span><br><span class="line">  // put your setup code here, to run once:</span><br><span class="line">  //初始化操作代码放在setup函数中，他们将在程序启动的第一步得到执行 并只执行一次</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void loop() &#123;</span><br><span class="line">  // put your main code here, to run repeatedly:</span><br><span class="line">  //将程序的主要逻辑代码，放在loop里。他们将会反复执行下去。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有C/C++开发经验的人看到这个程序框架会愣住：<strong>我的main函数去哪里呢？</strong></p>
<p>Arduino 为了让更多的人能够使用Arduino平台开发出好玩的东西出来，绞尽脑汁降低门槛，它隐藏了程序的细节，使得开发者将注意力放在实现上。</p>
<p>但我觉得这样适得其反。下面是Arduino程序的实质结构（这都是Arduino IDE 隐藏了的细节）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&quot;Arduino.h&quot; </span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">     init();   //arduino硬件初始化，不用你自己写</span><br><span class="line">    </span><br><span class="line">     setup();</span><br><span class="line">    </span><br><span class="line">     for(;;)</span><br><span class="line">        loop();</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="开始创建自己的库文件"><a href="#开始创建自己的库文件" class="headerlink" title="开始创建自己的库文件"></a>开始创建自己的库文件</h2><p>有时会程序越写越大，越大越乱。多文件管理可以解决这个麻烦。Arduino程序叫 Sketch。 一个Sketch可以有多个源代码文件，分离的源代码便于管理。但只有 1个 主文件，也就是存放 setup loop函数的文件。</p>
<p>让主文件用来控制程序的主要逻辑部分，而把具体的细节封装成单个模块，存放在其他的文件中，这样方便管理。那么怎么创建其他的文件呢？？？</p>
<p>下面开始介绍。</p>
<h3 id="1-使用IDE自动处理机制完成创建"><a href="#1-使用IDE自动处理机制完成创建" class="headerlink" title="1.使用IDE自动处理机制完成创建"></a>1.使用IDE自动处理机制完成创建</h3><p>点击下图中标记的按钮，选择第一个选项 【新建标签】，输入文件名即可。</p>
<p><img src="TIM截图20180114003102.png" alt="TIM截图20180114003102"></p>
<p>这样我们的工程就有了2个文件了。如下，一个主文件和一个名为LED的文件。这就是最简单的多文件方法。</p>
<p><img src="TIM截图20180114003146.png" alt="TIM截图20180114003146"></p>
<p>我不推荐使用这种方法，这是为没有C/C++编程经验的小白准备的，他们不懂函数定义 后还要声明才能使用，不懂得头文件的包含。这些都被Arduino IDE帮他们做了。IDE的具体处理是:</p>
<p>在编译前期，Arduino IDE会将无后缀的文件 和 主文件合并成为1个文件，效果就像是写在主文件中一样。并在主文件第一行添加 <code>#include &quot;Arduino.h&quot;</code>。 Arduino.h是 Arduino程序的核心头文件。然后，IDE将扫描合并后文件的函数定义，并对已经定义的函数添加函数的声明。（这个就是为什么即便我们定义的函数不声明也能编译通过的原因了）</p>
<p>但是官方明确说了，这个自动插入函数声明的机制是不完美的！所以我也建议大家养成手动声明函数的习惯。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Also, this generation isn&apos;t perfect: it won&apos;t create prototypes for functions that have default argument values, or which are declared within a namespace or class.</span><br></pre></td></tr></table></figure>
<h3 id="2-使用传统的-C-C-分离式文件"><a href="#2-使用传统的-C-C-分离式文件" class="headerlink" title="2.使用传统的 C/C++分离式文件"></a>2.使用传统的 C/C++分离式文件</h3><p>一般程序员都会将程序组织成源文件与库文件的形式，方便调用和代码修改,也就是 .c 和.h 或者 .cpp 和 .h 。前者是C语言风格，后者是对会使用C++来说的。官方貌似推崇我们使用C++编写Arduino代码，无论是Arduino 的从标准库，还是教程中，都透露出一股强烈的OOP气息。所以我下面使用C++风格来举例子。</p>
<p>例如我们想要将LED的控制封装成一个模块。</p>
<p>一开始我们需要创建2个文件 ：IOTTS_Led.cpp 、 IOTTS_Led.h 创建方式基本上分为两种：一是自己手动创建，二是利用上面提到的新建标签的方式创建</p>
<p><img src="TIM截图20180114005202.png" alt="TIM截图20180114005202"></p>
<p>然后是想清楚我们需要让提供LED控制的哪些操作。发挥你的想象力时候到了。规定操作后，我们先写出头文件，然后写出实现，最后在主文件中使用这个模块。在主文件中使用</p>
<p><code>#include&quot;IOTTS_Led.h&quot;</code>预处理指令包含。</p>
<p><strong>IOTTS_Led.h</strong>内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*******************</span><br><span class="line"> *IOTTS_Led.h</span><br><span class="line"> *******************/</span><br><span class="line"></span><br><span class="line">#ifndef _IOTTS_LED_H__</span><br><span class="line">#define _IOTTS_LED_H__</span><br><span class="line"></span><br><span class="line">//导入Arduino核心头文件</span><br><span class="line">#include&quot;Arduino.h&quot;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class LED</span><br><span class="line">&#123;</span><br><span class="line">     private:</span><br><span class="line">          byte pin;        //控制led使用的引脚</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     public:</span><br><span class="line">          </span><br><span class="line">          LED(byte p , bool state=LOW );   //构造函数</span><br><span class="line">          </span><br><span class="line">          ~LED();          //析构函数</span><br><span class="line"></span><br><span class="line">          byte getPin();   //获取控制的引脚</span><br><span class="line">          </span><br><span class="line">          void on();      //打开LED</span><br><span class="line"></span><br><span class="line">          void off();     //关闭LED</span><br><span class="line"></span><br><span class="line">          bool getState();  //获取LED状态</span><br><span class="line">          void disattach(); //释放引脚与LED的绑定，使得引脚可以控制其他的东西</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p><strong>IOTTS_Led.cpp</strong>内容如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*****************</span><br><span class="line"> *IOTTS_Led.cpp</span><br><span class="line"> ******************/</span><br><span class="line"></span><br><span class="line">#include&quot;IOTTS_Led.h&quot;</span><br><span class="line">#include&quot;Arduino.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LED::LED(byte p,bool state):pin(p)</span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">   pinMode(pin,OUTPUT);</span><br><span class="line">   digitalWrite(pin,state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LED::~LED()</span><br><span class="line">&#123;</span><br><span class="line">    disattach();</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">         </span><br><span class="line">void LED::on()</span><br><span class="line">&#123;</span><br><span class="line">    digitalWrite(pin,HIGH);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LED::off()</span><br><span class="line">&#123;</span><br><span class="line">   digitalWrite(pin,LOW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool LED::getState()</span><br><span class="line">&#123;</span><br><span class="line">    return digitalRead(pin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LED::disattach()        //引脚回收，恢复到上电状态</span><br><span class="line">&#123;</span><br><span class="line">    digitalWrite(pin,LOW);</span><br><span class="line">    pinMode(pin,INPUT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实例化程序</strong>内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**********************</span><br><span class="line">实例化1个LED对象，用13脚控制，闪烁10次，并在串口打印出引脚输出状态。</span><br><span class="line">10次完毕后释放回收引脚</span><br><span class="line">**********************/</span><br><span class="line">#include“IOTTS_Led.h”    </span><br><span class="line"></span><br><span class="line">LED led(13);</span><br><span class="line">byte count =0;</span><br><span class="line"></span><br><span class="line">void setup() &#123;</span><br><span class="line">   Serial.begin(9600);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void loop() &#123;</span><br><span class="line"></span><br><span class="line">   if(count&lt;10)&#123;</span><br><span class="line">     led.on();</span><br><span class="line">     delay(300);</span><br><span class="line">     Serial.println(led.getState(),DEC);</span><br><span class="line">     </span><br><span class="line">     led.off();</span><br><span class="line">     delay(300);</span><br><span class="line">     Serial.println(led.getState(),DEC);</span><br><span class="line">     </span><br><span class="line">     ++count;</span><br><span class="line">     if(count==10)</span><br><span class="line">        led.disattach();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="让它成为自己的库"><a href="#让它成为自己的库" class="headerlink" title="让它成为自己的库"></a>让它成为自己的库</h2><p>如果上面的模块你觉得好用，符合自己的使用习惯，而且经常要用到，那么你可以将它变成你自己的库文件,这样以后就可以直接拿来用啦。</p>
<p>Arduino的扩展库都是放在 libraries目录下的。</p>
<p><img src="TIM截图20180114010905.png" alt="TIM截图20180114010905"></p>
<p>所以我们需要在这个目录下创建一个文件夹，比如上面的例子是LED控制，于是我创建了IOTTS_Arduino_LED_Demo文件夹，最好命名和官方的区分开。然后把写好的.cpp 和 .h文件拷贝到里面去。</p>
<p><img src="TIM截图20180114010842.png" alt="TIM截图20180114010842"></p>
<p>这样我们 的Sketch就变成了下面这样，是不是很简洁干净呢。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;IOTTS_Led.h&gt; //注意，由于LED控制模块已经是标准库了，所以使用尖括号&lt;&gt; 包含</span><br><span class="line">                 </span><br><span class="line">LED led(13);</span><br><span class="line">byte count =0;</span><br><span class="line"></span><br><span class="line">void setup() &#123;</span><br><span class="line">   Serial.begin(9600);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void loop() &#123;</span><br><span class="line"></span><br><span class="line">   if(count&lt;10)&#123;</span><br><span class="line">     led.on();</span><br><span class="line">     delay(300);</span><br><span class="line">     Serial.println(led.getState(),DEC);</span><br><span class="line">     </span><br><span class="line">     led.off();</span><br><span class="line">     delay(300);</span><br><span class="line">     Serial.println(led.getState(),DEC);</span><br><span class="line">     </span><br><span class="line">     ++count;</span><br><span class="line">     if(count==10)</span><br><span class="line">        led.disattach();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以新建一个examples放入我们刚刚验证过的例程，目录结构按照文章开始讲的创建，这样就可以像加载官方历程一样加载自己的例程了。</p>
<p><img src="无标题.png" alt="无标题"></p>
<p>一般和自己建立的库一起的还有个 keywords.txt文件，这个是什么用呢？ 其实它没有太大的实用性，只是为了配置自定义库的语法高亮。让我们自己的库能在IDE下显示不同的颜色而已。如果不配置，Arduino IDE不能渲染出颜色的。</p>
<p>下面是keywords.txt 的内容，其中#开头的是注释，完全可以不写。格式：<code>word【tab】DESCRIPTION</code></p>
<p>word就是你要高亮的关键字接着1 个 tab 键 ，然后就是DESCRIPTION。</p>
<p>DESCRIPTION可以取的值：</p>
<p>KEYWORD1 高亮类名</p>
<p>KEYWORD2 高亮方法名</p>
<p>LITERAL1 高亮常量</p>
<p>注意中间使用的是 1 个 tab 键 隔开的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#class (KEYWORD1)</span><br><span class="line"></span><br><span class="line">LED	KEYWORD1</span><br><span class="line"></span><br><span class="line">#function and method (KEYWORD2)</span><br><span class="line"></span><br><span class="line">on	KEYWORD2</span><br><span class="line"></span><br><span class="line">off	KEYWORD2</span><br><span class="line"></span><br><span class="line">getState	KEYWORD2</span><br><span class="line"></span><br><span class="line">disattach	KEYWORD2</span><br><span class="line"></span><br><span class="line">#constant (LITERAL1)</span><br><span class="line"></span><br><span class="line">#none</span><br></pre></td></tr></table></figure>
<p>来一张做好的库文件图：</p>
<p><img src="TIM截图20180114131535.png" alt="TIM截图20180114131535.png"></p>
<p>文章中涉及到的源代码:</p>
<p><a href="https://iotts.top/2019/10/04/Arduino%E6%95%99%E7%A8%8B%E4%B9%8B%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84Arduino%E5%BA%93/IOTTS_Arduino_LED_Demo.rar">IOTTS_Arduino_LED_Demo.rar</a></p>
]]></content>
      <categories>
        <category>Arduino相关</category>
        <category>Arduino编程</category>
      </categories>
      <tags>
        <tag>单片机</tag>
        <tag>Arduino</tag>
      </tags>
  </entry>
  <entry>
    <title>CRC检验和计算方法</title>
    <url>/2019/10/23/CRC%E6%A3%80%E9%AA%8C%E5%92%8C%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>以下代码对应的CRC模型请参照最后面的图片<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uint8_t crc4_itu(uint8_t *data, uint_len length) </span><br><span class="line">&#123; </span><br><span class="line">    uint8_t i; </span><br><span class="line">    uint8_t crc = 0;        // Initial value </span><br><span class="line">    while(length--) </span><br><span class="line">    &#123; </span><br><span class="line">        crc ^= *data++;     // crc ^= *data; data++; </span><br><span class="line">        for (i = 0; i &lt; 8; ++i) </span><br><span class="line">        &#123; </span><br><span class="line">            if (crc &amp; 1) </span><br><span class="line">                crc = (crc &gt;&gt; 1) ^ 0x0C;// 0x0C = (reverse 0x03)&gt;&gt;(8-4) </span><br><span class="line">            else </span><br><span class="line">                crc = (crc &gt;&gt; 1); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    return crc; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uint8_t crc5_epc(uint8_t *data, uint_len length) </span><br><span class="line">&#123; </span><br><span class="line">    uint8_t i; </span><br><span class="line">    uint8_t crc = 0x48; // Initial value: 0x48 = 0x09&lt;&lt;(8-5)  </span><br><span class="line">    while(length--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        crc ^= *data++; // crc ^= *data; data++;  </span><br><span class="line">        for ( i = 0; i &lt; 8; i++ )  </span><br><span class="line">        &#123;  </span><br><span class="line">            if ( crc &amp; 0x80 )  </span><br><span class="line">                crc = (crc &lt;&lt; 1) ^ 0x48;  // 0x48 = 0x09&lt;&lt;(8-5)  </span><br><span class="line">            else  </span><br><span class="line">                crc &lt;&lt;= 1;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return crc &gt;&gt; 3;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uint8_t crc5_itu(uint8_t *data, uint_len length)  </span><br><span class="line">&#123;  </span><br><span class="line">    uint8_t i;  </span><br><span class="line">    uint8_t crc = 0;        // Initial value  </span><br><span class="line">    while(length--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        crc ^= *data++;     // crc ^= *data; data++;  </span><br><span class="line">        for (i = 0; i &lt; 8; ++i)  </span><br><span class="line">        &#123;  </span><br><span class="line">            if (crc &amp; 1)  </span><br><span class="line">                crc = (crc &gt;&gt; 1) ^ 0x15;// 0x15 = (reverse 0x15)&gt;&gt;(8-5)  </span><br><span class="line">            else  </span><br><span class="line">                crc = (crc &gt;&gt; 1);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return crc;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uint8_t crc5_usb(uint8_t *data, uint_len length)  </span><br><span class="line">&#123;  </span><br><span class="line">    uint8_t i;  </span><br><span class="line">    uint8_t crc = 0x1F;     // Initial value  </span><br><span class="line">    while(length--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        crc ^= *data++;     // crc ^= *data; data++;  </span><br><span class="line">        for (i = 0; i &lt; 8; ++i)  </span><br><span class="line">        &#123;  </span><br><span class="line">            if (crc &amp; 1)  </span><br><span class="line">                crc = (crc &gt;&gt; 1) ^ 0x14;// 0x14 = (reverse 0x05)&gt;&gt;(8-5)  </span><br><span class="line">            else  </span><br><span class="line">                crc = (crc &gt;&gt; 1);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return crc ^ 0x1F;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uint8_t crc6_itu(uint8_t *data, uint_len length)  </span><br><span class="line">&#123;  </span><br><span class="line">    uint8_t i;  </span><br><span class="line">    uint8_t crc = 0;    // Initial value  </span><br><span class="line">    while(length--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        crc ^= *data++; // crc ^= *data; data++;  </span><br><span class="line">        for (i = 0; i &lt; 8; ++i)  </span><br><span class="line">        &#123;  </span><br><span class="line">            if (crc &amp; 1)  </span><br><span class="line">                crc = (crc &gt;&gt; 1) ^ 0x30;// 0x30 = (reverse 0x03)&gt;&gt;(8-6)  </span><br><span class="line">            else  </span><br><span class="line">                crc = (crc &gt;&gt; 1);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return crc;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uint8_t crc7_mmc(uint8_t *data, uint_len length)  </span><br><span class="line">&#123;  </span><br><span class="line">    uint8_t i;  </span><br><span class="line">    uint8_t crc = 0;    // Initial value  </span><br><span class="line">    while(length--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        crc ^= *data++; // crc ^= *data; data++;  </span><br><span class="line">        for ( i = 0; i &lt; 8; i++ )  </span><br><span class="line">        &#123;  </span><br><span class="line">            if ( crc &amp; 0x80 )  </span><br><span class="line">                crc = (crc &lt;&lt; 1) ^ 0x12;  // 0x12 = 0x09&lt;&lt;(8-7)  </span><br><span class="line">            else  </span><br><span class="line">                crc &lt;&lt;= 1;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return crc &gt;&gt; 1;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uint8_t crc8(uint8_t *data, uint_len length)  </span><br><span class="line">&#123;  </span><br><span class="line">    uint8_t i;  </span><br><span class="line">    uint8_t crc = 0;    // Initial value  </span><br><span class="line">    while(length--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        crc ^= *data++; // crc ^= *data; data++;  </span><br><span class="line">        for ( i = 0; i &lt; 8; i++ )  </span><br><span class="line">        &#123;  </span><br><span class="line">            if ( crc &amp; 0x80 )  </span><br><span class="line">                crc = (crc &lt;&lt; 1) ^ 0x07;  </span><br><span class="line">            else  </span><br><span class="line">                crc &lt;&lt;= 1;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return crc;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uint8_t crc8_itu(uint8_t *data, uint_len length)  </span><br><span class="line">&#123;  </span><br><span class="line">    uint8_t i;  </span><br><span class="line">    uint8_t crc = 0;    // Initial value  </span><br><span class="line">    while(length--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        crc ^= *data++; // crc ^= *data; data++;  </span><br><span class="line">        for ( i = 0; i &lt; 8; i++ )  </span><br><span class="line">        &#123;  </span><br><span class="line">            if ( crc &amp; 0x80 )  </span><br><span class="line">                crc = (crc &lt;&lt; 1) ^ 0x07;  </span><br><span class="line">            else  </span><br><span class="line">                crc &lt;&lt;= 1;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return crc ^ 0x55;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uint8_t crc8_rohc(uint8_t *data, uint_len length)  </span><br><span class="line">&#123;  </span><br><span class="line">    uint8_t i;  </span><br><span class="line">    uint8_t crc = 0xFF;     // Initial value  </span><br><span class="line">    while(length--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        crc ^= *data++;     // crc ^= *data; data++;  </span><br><span class="line">        for (i = 0; i &lt; 8; ++i)  </span><br><span class="line">        &#123;  </span><br><span class="line">            if (crc &amp; 1)  </span><br><span class="line">                crc = (crc &gt;&gt; 1) ^ 0xE0;  // 0xE0 = reverse 0x07  </span><br><span class="line">            else  </span><br><span class="line">                crc = (crc &gt;&gt; 1);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return crc;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uint8_t crc8_maxim(uint8_t *data, uint_len length)  </span><br><span class="line">&#123;  </span><br><span class="line">    uint8_t i;  </span><br><span class="line">    uint8_t crc = 0;    // Initial value  </span><br><span class="line">    while(length--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        crc ^= *data++; // crc ^= *data; data++;  </span><br><span class="line">        for (i = 0; i &lt; 8; i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            if (crc &amp; 1)  </span><br><span class="line">                crc = (crc &gt;&gt; 1) ^ 0x8C;  // 0x8C = reverse 0x31  </span><br><span class="line">            else  </span><br><span class="line">                crc &gt;&gt;= 1;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return crc;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uint16_t crc16_ibm(uint8_t *data, uint_len length)  </span><br><span class="line">&#123;  </span><br><span class="line">    uint8_t i;  </span><br><span class="line">    uint16_t crc = 0;   // Initial value  </span><br><span class="line">    while(length--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        crc ^= *data++; // crc ^= *data; data++;  </span><br><span class="line">        for (i = 0; i &lt; 8; ++i)  </span><br><span class="line">        &#123;  </span><br><span class="line">            if (crc &amp; 1)  </span><br><span class="line">                crc = (crc &gt;&gt; 1) ^ 0xA001;    // 0xA001 = reverse 0x8005  </span><br><span class="line">            else  </span><br><span class="line">                crc = (crc &gt;&gt; 1);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return crc;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uint16_t crc16_maxim(uint8_t *data, uint_len length)  </span><br><span class="line">&#123;  </span><br><span class="line">    uint8_t i;  </span><br><span class="line">    uint16_t crc = 0;   // Initial value  </span><br><span class="line">    while(length--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        crc ^= *data++; // crc ^= *data; data++;  </span><br><span class="line">        for (i = 0; i &lt; 8; ++i)  </span><br><span class="line">        &#123;  </span><br><span class="line">            if (crc &amp; 1)  </span><br><span class="line">                crc = (crc &gt;&gt; 1) ^ 0xA001;    // 0xA001 = reverse 0x8005  </span><br><span class="line">            else  </span><br><span class="line">                crc = (crc &gt;&gt; 1);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return ~crc;    // crc^0xffff  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uint16_t crc16_usb(uint8_t *data, uint_len length)  </span><br><span class="line">&#123;  </span><br><span class="line">    uint8_t i;  </span><br><span class="line">    uint16_t crc = 0xffff;  // Initial value  </span><br><span class="line">    while(length--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        crc ^= *data++;     // crc ^= *data; data++;  </span><br><span class="line">        for (i = 0; i &lt; 8; ++i)  </span><br><span class="line">        &#123;  </span><br><span class="line">            if (crc &amp; 1)  </span><br><span class="line">                crc = (crc &gt;&gt; 1) ^ 0xA001;    // 0xA001 = reverse 0x8005  </span><br><span class="line">            else  </span><br><span class="line">                crc = (crc &gt;&gt; 1);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return ~crc;    // crc^0xffff  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uint16_t crc16_modbus(uint8_t *data, uint_len length)  </span><br><span class="line">&#123;  </span><br><span class="line">    uint8_t i;  </span><br><span class="line">    uint16_t crc = 0xffff;  // Initial value  </span><br><span class="line">    while(length--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        crc ^= *data++;     // crc ^= *data; data++;  </span><br><span class="line">        for (i = 0; i &lt; 8; ++i)  </span><br><span class="line">        &#123;  </span><br><span class="line">            if (crc &amp; 1)  </span><br><span class="line">                crc = (crc &gt;&gt; 1) ^ 0xA001;    // 0xA001 = reverse 0x8005  </span><br><span class="line">            else  </span><br><span class="line">                crc = (crc &gt;&gt; 1);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return crc;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uint16_t crc16_ccitt(uint8_t *data, uint_len length)  </span><br><span class="line">&#123;  </span><br><span class="line">    uint8_t i;  </span><br><span class="line">    uint16_t crc = 0;   // Initial value  </span><br><span class="line">    while(length--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        crc ^= *data++; // crc ^= *data; data++;  </span><br><span class="line">        for (i = 0; i &lt; 8; ++i)  </span><br><span class="line">        &#123;  </span><br><span class="line">            if (crc &amp; 1)  </span><br><span class="line">                crc = (crc &gt;&gt; 1) ^ 0x8408;    // 0x8408 = reverse 0x1021  </span><br><span class="line">            else  </span><br><span class="line">                crc = (crc &gt;&gt; 1);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return crc;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uint16_t crc16_ccitt_false(uint8_t *data, uint_len length)  </span><br><span class="line">&#123;  </span><br><span class="line">    uint8_t i;  </span><br><span class="line">    uint16_t crc = 0xffff;  //Initial value  </span><br><span class="line">    while(length--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        crc ^= (uint16_t)(*data++) &lt;&lt; 8; // crc ^= (uint6_t)(*data)&lt;&lt;8; data++;  </span><br><span class="line">        for (i = 0; i &lt; 8; ++i)  </span><br><span class="line">        &#123;  </span><br><span class="line">            if ( crc &amp; 0x8000 )  </span><br><span class="line">                crc = (crc &lt;&lt; 1) ^ 0x1021;  </span><br><span class="line">            else  </span><br><span class="line">                crc &lt;&lt;= 1;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return crc;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uint16_t crc16_x25(uint8_t *data, uint_len length)  </span><br><span class="line">&#123;  </span><br><span class="line">    uint8_t i;  </span><br><span class="line">    uint16_t crc = 0xffff;  // Initial value  </span><br><span class="line">    while(length--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        crc ^= *data++;     // crc ^= *data; data++;  </span><br><span class="line">        for (i = 0; i &lt; 8; ++i)  </span><br><span class="line">        &#123;  </span><br><span class="line">            if (crc &amp; 1)  </span><br><span class="line">                crc = (crc &gt;&gt; 1) ^ 0x8408;    // 0x8408 = reverse 0x1021  </span><br><span class="line">            else  </span><br><span class="line">                crc = (crc &gt;&gt; 1);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return ~crc;            // crc^Xorout  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uint16_t crc16_xmodem(uint8_t *data, uint_len length)  </span><br><span class="line">&#123;  </span><br><span class="line">    uint8_t i;  </span><br><span class="line">    uint16_t crc = 0;       // Initial value  </span><br><span class="line">    while(length--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        crc ^= (uint16_t)(*data++) &lt;&lt; 8; // crc ^= (uint16_t)(*data)&lt;&lt;8; data++;  </span><br><span class="line">        for (i = 0; i &lt; 8; ++i)  </span><br><span class="line">        &#123;  </span><br><span class="line">            if ( crc &amp; 0x8000 )  </span><br><span class="line">                crc = (crc &lt;&lt; 1) ^ 0x1021;  </span><br><span class="line">            else  </span><br><span class="line">                crc &lt;&lt;= 1;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return crc;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uint16_t crc16_dnp(uint8_t *data, uint_len length)  </span><br><span class="line">&#123;  </span><br><span class="line">    uint8_t i;  </span><br><span class="line">    uint16_t crc = 0;       // Initial value  </span><br><span class="line">    while(length--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        crc ^= *data++;     // crc ^= *data; data++;  </span><br><span class="line">        for (i = 0; i &lt; 8; ++i)  </span><br><span class="line">        &#123;  </span><br><span class="line">            if (crc &amp; 1)  </span><br><span class="line">                crc = (crc &gt;&gt; 1) ^ 0xA6BC;    // 0xA6BC = reverse 0x3D65  </span><br><span class="line">            else  </span><br><span class="line">                crc = (crc &gt;&gt; 1);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return ~crc;            // crc^Xorout  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uint32_t crc32(uint8_t *data, uint_len length)  </span><br><span class="line">&#123;  </span><br><span class="line">    uint8_t i;  </span><br><span class="line">    uint32_t crc = 0xffffffff;  // Initial value  </span><br><span class="line">    while(length--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        crc ^= *data++;         // crc ^= *data; data++;  </span><br><span class="line">        for (i = 0; i &lt; 8; ++i)  </span><br><span class="line">        &#123;  </span><br><span class="line">            if (crc &amp; 1)  </span><br><span class="line">                crc = (crc &gt;&gt; 1) ^ 0xEDB88320;// 0xEDB88320= reverse 0x04C11DB7  </span><br><span class="line">            else  </span><br><span class="line">                crc = (crc &gt;&gt; 1);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return ~crc;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uint32_t crc32_mpeg_2(uint8_t *data, uint_len length)  </span><br><span class="line">&#123;  </span><br><span class="line">    uint8_t i;  </span><br><span class="line">    uint32_t crc = 0xffffffff;  // Initial value  </span><br><span class="line">    while(length--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        crc ^= (uint32_t)(*data++) &lt;&lt; 24;// crc ^=(uint32_t)(*data)&lt;&lt;24; data++;  </span><br><span class="line">        for (i = 0; i &lt; 8; ++i)  </span><br><span class="line">        &#123;  </span><br><span class="line">            if ( crc &amp; 0x80000000 )  </span><br><span class="line">                crc = (crc &lt;&lt; 1) ^ 0x04C11DB7;  </span><br><span class="line">            else  </span><br><span class="line">                crc &lt;&lt;= 1;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return crc;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常见CRC参数模型如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>CRC算法名称</th>
<th>多项式公式</th>
<th>宽度</th>
<th>多项式</th>
<th>初始值</th>
<th>结果异或值</th>
<th>输入值反转</th>
<th>输出值反转</th>
</tr>
</thead>
<tbody>
<tr>
<td>CRC-4/ITU</td>
<td>x4 + x + 1</td>
<td>4</td>
<td>03</td>
<td>00</td>
<td>00</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>CRC-5/EPC</td>
<td>x4 + x3 + 1</td>
<td>5</td>
<td>09</td>
<td>09</td>
<td>00</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>CRC-5/ITU</td>
<td>x5 + x4 + x2 + 1</td>
<td>5</td>
<td>15</td>
<td>00</td>
<td>00</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>CRC-5/USB</td>
<td>x5 + x2 + 1</td>
<td>5</td>
<td>05</td>
<td>1F</td>
<td>1F</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>CRC-6/ITU</td>
<td>x6 + x + 1</td>
<td>6</td>
<td>03</td>
<td>00</td>
<td>00</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>CRC-7/MMC</td>
<td>x7 + x3 + 1</td>
<td>7</td>
<td>09</td>
<td>00</td>
<td>00</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>CRC-8</td>
<td>x8 + x2 + x + 1</td>
<td>8</td>
<td>07</td>
<td>00</td>
<td>00</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>CRC-8/ITU</td>
<td>x8 + x2 + x + 1</td>
<td>8</td>
<td>07</td>
<td>00</td>
<td>55</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>CRC-8/ROHC</td>
<td>x8 + x2 + x + 1</td>
<td>8</td>
<td>07</td>
<td>FF</td>
<td>00</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>CRC-8/MAXIM</td>
<td>x8 + x5 + x4 + 1</td>
<td>8</td>
<td>31</td>
<td>00</td>
<td>00</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>CRC-16/IBM</td>
<td>x6 + x5 + x2 + 1</td>
<td>16</td>
<td>8005</td>
<td>0000</td>
<td>0000</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>CRC-16/MAXIM</td>
<td>x6 + x5 + x2 + 1</td>
<td>16</td>
<td>8005</td>
<td>0000</td>
<td>FFFF</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>CRC-16/USB</td>
<td>x6 + x5 + x2 + 1</td>
<td>16</td>
<td>8005</td>
<td>FFFF</td>
<td>FFFF</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>CRC-16/MODBUS</td>
<td>x6 + x5 + x2 + 1</td>
<td>16</td>
<td>8005</td>
<td>FFFF</td>
<td>0000</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>CRC-16/CCITT</td>
<td>x6 + x2 + x5 + 1</td>
<td>16</td>
<td>1021</td>
<td>0000</td>
<td>0000</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>CRC-16/CCITT-FALSE</td>
<td>x6 + x2 + x5 + 1</td>
<td>16</td>
<td>1021</td>
<td>FFFF</td>
<td>0000</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>CRC-16/x5</td>
<td>x6 + x2 + x5 + 1</td>
<td>16</td>
<td>1021</td>
<td>FFFF</td>
<td>FFFF</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>CRC-16/XMODEM</td>
<td>x6 + x2 + x5 + 1</td>
<td>16</td>
<td>1021</td>
<td>0000</td>
<td>0000</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>CRC-16/DNP</td>
<td>x6 + x3 + x2 + x1 + x0 + x8 + x6 + x5 + x2 + 1</td>
<td>16</td>
<td>3D65</td>
<td>0000</td>
<td>FFFF</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>CRC-32</td>
<td>x2 + x6 + x3 + x2 + x6 + x2 + x1 + x0 + x8 + x7 + x5 + x4 + x2 + x + 1</td>
<td>32</td>
<td>04C11DB7</td>
<td>FFFFFFFF</td>
<td>FFFFFFFF</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>CRC-32/MPEG-2</td>
<td>x32 + x6 + x3 + x2 + x6 + x2 + x1 + x0 + x8 + x7 + x5 + x4 + x2 + x + 1</td>
<td>32</td>
<td>04C11DB7</td>
<td>FFFFFFFF</td>
<td>00000000</td>
<td>false</td>
<td>false</td>
</tr>
</tbody>
</table>
</div>
<p>在线计算：<a href="http://www.ip33.com/crc.html" target="_blank" rel="noopener">http://www.ip33.com/crc.html</a></p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>CRC算法</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言教程之枚举类型</title>
    <url>/2018/01/10/c%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B%E4%B9%8B%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/JCSU/articles/1299051.html" target="_blank" rel="noopener">原文链接</a><br>注：以下全部代码的执行环境为VC++ 6.0</p>
<p>在程序中，可能需要为某些整数定义一个别名，我们可以利用预处理指令#define来完成这项工作，您的代码可能是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define MON  1</span></span><br><span class="line"><span class="comment">#define TUE   2</span></span><br><span class="line"><span class="comment">#define WED  3</span></span><br><span class="line"><span class="comment">#define THU   4</span></span><br><span class="line"><span class="comment">#define FRI    5</span></span><br><span class="line"><span class="comment">#define SAT   6</span></span><br><span class="line"><span class="comment">#define SUN   7</span></span><br></pre></td></tr></table></figure>
<p>在此，我们定义一种新的数据类型，希望它能完成同样的工作。这种新的数据类型叫枚举型。</p>
<h2 id="1-定义一种新的数据类型-枚举型"><a href="#1-定义一种新的数据类型-枚举型" class="headerlink" title="1. 定义一种新的数据类型 - 枚举型"></a>1. 定义一种新的数据类型 - 枚举型</h2><p> 以下代码定义了这种新的数据类型 - 枚举型<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">enum DAY</span><br><span class="line">&#123;</span><br><span class="line">      MON=1, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>(1) 枚举型是一个集合，集合中的元素(枚举成员)是一些命名的整型常量，元素之间用逗号,隔开。</p>
<p>(2) DAY是一个标识符，可以看成这个集合的名字，是一个可选项，即是可有可无的项。</p>
<p>(3) 第一个枚举成员的默认值为整型的0，后续枚举成员的值在前一个成员上加1。</p>
<p>(4) 可以人为设定枚举成员的值，从而自定义某个范围内的整数。</p>
<p>(5) 枚举型是预处理指令#define的替代。</p>
<p>(6) 类型定义以分号;结束。</p>
<h2 id="2-使用枚举类型对变量进行声明"><a href="#2-使用枚举类型对变量进行声明" class="headerlink" title="2. 使用枚举类型对变量进行声明"></a>2. 使用枚举类型对变量进行声明</h2><p>新的数据类型定义完成后，它就可以使用了。我们已经见过最基本的数据类型，如：整型int, 单精度浮点型float, 双精度浮点型double, 字符型char, 短整型short等等。用这些基本数据类型声明变量通常是这样：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">char     a; //变量a的类型均为字符型char</span><br><span class="line">char     letter;</span><br><span class="line">int        x,</span><br><span class="line">           y,</span><br><span class="line">           z; //变量x,y和z的类型均为整型int</span><br><span class="line">int       number;</span><br><span class="line">double  m, n;</span><br><span class="line">double  result; //变量result的类型为双精度浮点型double</span><br></pre></td></tr></table></figure></p>
<p>既然枚举也是一种数据类型，那么它和基本数据类型一样也可以对变量进行声明。</p>
<h4 id="方法一：枚举类型的定义和变量的声明分开"><a href="#方法一：枚举类型的定义和变量的声明分开" class="headerlink" title="方法一：枚举类型的定义和变量的声明分开"></a>方法一：枚举类型的定义和变量的声明分开</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">enum DAY</span><br><span class="line">&#123;</span><br><span class="line">      MON=1, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">enum DAY yesterday;</span><br><span class="line">enum DAY today;</span><br><span class="line">enum DAY tomorrow; //变量tomorrow的类型为枚举型enum DAY</span><br><span class="line">enum DAY good_day, bad_day; //变量good_day和bad_day的类型均为枚举型enum DAY</span><br></pre></td></tr></table></figure>
<h4 id="方法二：类型定义与变量声明同时进行："><a href="#方法二：类型定义与变量声明同时进行：" class="headerlink" title="方法二：类型定义与变量声明同时进行："></a>方法二：类型定义与变量声明同时进行：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">enum //跟第一个定义不同的是，此处的标号DAY省略，这是允许的。</span><br><span class="line">&#123;</span><br><span class="line">    saturday,</span><br><span class="line">    sunday = 0,</span><br><span class="line">    monday,</span><br><span class="line">    tuesday,</span><br><span class="line">    wednesday,</span><br><span class="line">    thursday,</span><br><span class="line">    friday</span><br><span class="line">&#125; workday; //变量workday的类型为枚举型enum DAY</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">enum week &#123; Mon=1, Tue, Wed, Thu, Fri Sat, Sun&#125; days; //变量days的类型为枚举型enum week</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">enum BOOLEAN &#123; <span class="literal">false</span>, <span class="literal">true</span> &#125; end_flag, match_flag; //定义枚举类型并声明了两个枚举型变量</span><br></pre></td></tr></table></figure>
<h4 id="方法三：用typedef关键字将枚举类型定义成别名，并利用该别名进行变量声明："><a href="#方法三：用typedef关键字将枚举类型定义成别名，并利用该别名进行变量声明：" class="headerlink" title="方法三：用typedef关键字将枚举类型定义成别名，并利用该别名进行变量声明："></a>方法三：用typedef关键字将枚举类型定义成别名，并利用该别名进行变量声明：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typedef enum workday</span><br><span class="line">&#123;</span><br><span class="line">    saturday,</span><br><span class="line">    sunday = 0,</span><br><span class="line">    monday,</span><br><span class="line">    tuesday,</span><br><span class="line">    wednesday,</span><br><span class="line">    thursday,</span><br><span class="line">    friday</span><br><span class="line">&#125; workday; //此处的workday为枚举型enum workday的别名</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">workday today, tomorrow; //变量today和tomorrow的类型为枚举型workday，也即enum workday</span><br></pre></td></tr></table></figure>
<p>enum workday中的workday可以省略：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typedef enum</span><br><span class="line">&#123;</span><br><span class="line">    saturday,</span><br><span class="line">    sunday = 0,</span><br><span class="line">    monday,</span><br><span class="line">    tuesday,</span><br><span class="line">    wednesday,</span><br><span class="line">    thursday,</span><br><span class="line">    friday</span><br><span class="line">&#125; workday; //此处的workday为枚举型enum workday的别名</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">workday today, tomorrow; //变量today和tomorrow的类型为枚举型workday，也即enum workday</span><br></pre></td></tr></table></figure>
<p>也可以用这种方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typedef enum workday</span><br><span class="line">&#123;</span><br><span class="line">    saturday,</span><br><span class="line">    sunday = 0,</span><br><span class="line">    monday,</span><br><span class="line">    tuesday,</span><br><span class="line">    wednesday,</span><br><span class="line">    thursday,</span><br><span class="line">    friday</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">workday today, tomorrow; //变量today和tomorrow的类型为枚举型workday，也即enum workday</span><br></pre></td></tr></table></figure>
<p>注意：同一个程序中不能定义同名的枚举类型，不同的枚举类型中也不能存在同名的命名常量。错误示例如下所示：</p>
<p>$\color{red}{错误声明一：}$存在同名的枚举类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typedef enum</span><br><span class="line">&#123;</span><br><span class="line">    wednesday,</span><br><span class="line">    thursday,</span><br><span class="line">    friday</span><br><span class="line">&#125; workday;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typedef enum WEEK</span><br><span class="line">&#123;</span><br><span class="line">    saturday,</span><br><span class="line">    sunday = 0,</span><br><span class="line">    monday,</span><br><span class="line">&#125; workday;</span><br></pre></td></tr></table></figure>
<p>$\color{red}{错误声明二：}$存在同名的枚举成员</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typedef enum</span><br><span class="line">&#123;</span><br><span class="line">    wednesday,</span><br><span class="line">    thursday,</span><br><span class="line">    friday</span><br><span class="line">&#125; workday_1;</span><br><span class="line"></span><br><span class="line">typedef enum WEEK</span><br><span class="line">&#123;</span><br><span class="line">    wednesday,</span><br><span class="line">    sunday = 0,</span><br><span class="line">    monday,</span><br><span class="line">&#125; workday_2;</span><br></pre></td></tr></table></figure>
<h2 id="3-使用枚举类型的变量"><a href="#3-使用枚举类型的变量" class="headerlink" title="3.使用枚举类型的变量"></a>3.使用枚举类型的变量</h2><h3 id="3-1-对枚举型的变量赋值。"><a href="#3-1-对枚举型的变量赋值。" class="headerlink" title="3.1 对枚举型的变量赋值。"></a>3.1 对枚举型的变量赋值。</h3><p>实例将枚举类型的赋值与基本数据类型的赋值进行了对比：</p>
<h4 id="方法一：先声明变量，再对变量赋值"><a href="#方法一：先声明变量，再对变量赋值" class="headerlink" title="方法一：先声明变量，再对变量赋值"></a>方法一：先声明变量，再对变量赋值</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">/* 定义枚举类型 */</span><br><span class="line">enum DAY &#123; MON=1, TUE, WED, THU, FRI, SAT, SUN &#125;;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    /* 使用基本数据类型声明变量，然后对变量赋值 */</span><br><span class="line">    int x, y, z;</span><br><span class="line">    </span><br><span class="line">    x = 10;</span><br><span class="line">    y = 20;</span><br><span class="line">    z = 30;</span><br><span class="line">    </span><br><span class="line">    /* 使用枚举类型声明变量，再对枚举型变量赋值 */</span><br><span class="line">    enum DAY yesterday, today, tomorrow;</span><br><span class="line">    </span><br><span class="line">    yesterday = MON;</span><br><span class="line">    today     = TUE;</span><br><span class="line">    tomorrow  = WED;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d \n"</span>, yesterday, today, tomorrow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法二：声明变量的同时赋初值"><a href="#方法二：声明变量的同时赋初值" class="headerlink" title="方法二：声明变量的同时赋初值"></a>方法二：声明变量的同时赋初值</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">/* 定义枚举类型 */</span><br><span class="line">enum DAY &#123; MON=1, TUE, WED, THU, FRI, SAT, SUN &#125;;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    /* 使用基本数据类型声明变量同时对变量赋初值 */</span><br><span class="line">    int x=10, y=20, z=30;</span><br><span class="line">    </span><br><span class="line">    /* 使用枚举类型声明变量同时对枚举型变量赋初值 */</span><br><span class="line">    enum DAY yesterday = MON, </span><br><span class="line">                        today = TUE,</span><br><span class="line">                   tomorrow = WED;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d \n"</span>, yesterday, today, tomorrow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法三：定义类型的同时声明变量，然后对变量赋值。"><a href="#方法三：定义类型的同时声明变量，然后对变量赋值。" class="headerlink" title="方法三：定义类型的同时声明变量，然后对变量赋值。"></a>方法三：定义类型的同时声明变量，然后对变量赋值。</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">/* 定义枚举类型，同时声明该类型的三个变量，它们都为全局变量 */</span><br><span class="line">enum DAY &#123; MON=1, TUE, WED, THU, FRI, SAT, SUN &#125; yesterday, today, tomorrow;</span><br><span class="line"></span><br><span class="line">/* 定义三个具有基本数据类型的变量，它们都为全局变量 */</span><br><span class="line">int x, y, z;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    /* 对基本数据类型的变量赋值 */</span><br><span class="line">    x = 10;  y = 20;  z = 30;</span><br><span class="line">    </span><br><span class="line">    /* 对枚举型的变量赋值 */</span><br><span class="line">    yesterday = MON;</span><br><span class="line">    today     = TUE;</span><br><span class="line">    tomorrow  = WED;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d \n"</span>, x, y, z); //输出：10 20 30</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d \n"</span>, yesterday, today, tomorrow); //输出：1 2 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法四：类型定义，变量声明，赋初值同时进行。"><a href="#方法四：类型定义，变量声明，赋初值同时进行。" class="headerlink" title="方法四：类型定义，变量声明，赋初值同时进行。"></a>方法四：类型定义，变量声明，赋初值同时进行。</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">/* 定义枚举类型，同时声明该类型的三个变量，并赋初值。它们都为全局变量 */</span><br><span class="line">enum DAY</span><br><span class="line">&#123;</span><br><span class="line">    MON=1, </span><br><span class="line">    TUE,</span><br><span class="line">    WED,</span><br><span class="line">    THU,</span><br><span class="line">    FRI,</span><br><span class="line">    SAT,</span><br><span class="line">    SUN </span><br><span class="line">&#125;</span><br><span class="line">yesterday = MON, today = TUE, tomorrow = WED;</span><br><span class="line"></span><br><span class="line">/* 定义三个具有基本数据类型的变量，并赋初值。它们都为全局变量 */</span><br><span class="line">int x = 10, y = 20, z = 30;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d \n"</span>, x, y, z); //输出：10 20 30</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d \n"</span>, yesterday, today, tomorrow); //输出：1 2 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-对枚举型的变量赋整数值时，需要进行类型转换。"><a href="#3-2-对枚举型的变量赋整数值时，需要进行类型转换。" class="headerlink" title="3.2 对枚举型的变量赋整数值时，需要进行类型转换。"></a>3.2 对枚举型的变量赋整数值时，需要进行类型转换。</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">enum DAY &#123; MON=1, TUE, WED, THU, FRI, SAT, SUN &#125;;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    enum DAY yesterday, today, tomorrow;</span><br><span class="line"></span><br><span class="line">    yesterday = TUE;</span><br><span class="line">    today = (enum DAY) (yesterday + 1); //类型转换</span><br><span class="line">    tomorrow = (enum DAY) 30; //类型转换</span><br><span class="line">    //tomorrow = 3; //错误</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d \n"</span>, yesterday, today, tomorrow); //输出：2 3 30</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-使用枚举型变量"><a href="#3-3-使用枚举型变量" class="headerlink" title="3.3 使用枚举型变量"></a>3.3 使用枚举型变量</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">enum</span><br><span class="line">&#123; </span><br><span class="line">    BELL          = <span class="string">'\a'</span>,</span><br><span class="line">    BACKSPACE = <span class="string">'\b'</span>,</span><br><span class="line">    HTAB         = <span class="string">'\t'</span>,</span><br><span class="line">    RETURN      = <span class="string">'\r'</span>,</span><br><span class="line">    NEWLINE    = <span class="string">'\n'</span>, </span><br><span class="line">    VTAB         = <span class="string">'\v'</span>,</span><br><span class="line">    SPACE       = <span class="string">' '</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">enum BOOLEAN &#123; FALSE = 0, TRUE &#125; match_flag;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    int index = 0;</span><br><span class="line">    int count_of_letter = 0;</span><br><span class="line">    int count_of_space = 0;</span><br><span class="line">    </span><br><span class="line">    char str[] = <span class="string">"I'm Ely efod"</span>;</span><br><span class="line">    </span><br><span class="line">    match_flag = FALSE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(; str[index] != <span class="string">'\0'</span>; index++)</span><br><span class="line">        <span class="keyword">if</span>( SPACE != str[index] )</span><br><span class="line">            count_of_letter++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            match_flag = (enum BOOLEAN) 1;</span><br><span class="line">            count_of_space++;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s %d times %c"</span>, match_flag ? <span class="string">"match"</span> : <span class="string">"not match"</span>, count_of_space, NEWLINE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"count of letters: %d %c%c"</span>, count_of_letter, NEWLINE, RETURN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">match 2 <span class="built_in">times</span></span><br><span class="line">count of letters: 10</span><br><span class="line">Press any key to <span class="built_in">continue</span></span><br></pre></td></tr></table></figure></p>
<h2 id="4-枚举类型与sizeof运算符"><a href="#4-枚举类型与sizeof运算符" class="headerlink" title="4. 枚举类型与sizeof运算符"></a>4. 枚举类型与sizeof运算符</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">enum escapes</span><br><span class="line">&#123; </span><br><span class="line">    BELL      = <span class="string">'\a'</span>,</span><br><span class="line">    BACKSPACE = <span class="string">'\b'</span>,</span><br><span class="line">    HTAB      = <span class="string">'\t'</span>,</span><br><span class="line">    RETURN    = <span class="string">'\r'</span>,</span><br><span class="line">    NEWLINE   = <span class="string">'\n'</span>, </span><br><span class="line">    VTAB      = <span class="string">'\v'</span>,</span><br><span class="line">    SPACE     = <span class="string">' '</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">enum BOOLEAN &#123; FALSE = 0, TRUE &#125; match_flag;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d bytes \n"</span>, sizeof(enum escapes)); //4 bytes</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d bytes \n"</span>, sizeof(escapes)); //4 bytes</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d bytes \n"</span>, sizeof(enum BOOLEAN)); //4 bytes</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d bytes \n"</span>, sizeof(BOOLEAN)); //4 bytes</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d bytes \n"</span>, sizeof(match_flag)); //4 bytes</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d bytes \n"</span>, sizeof(SPACE)); //4 bytes</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d bytes \n"</span>, sizeof(NEWLINE)); //4 bytes</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d bytes \n"</span>, sizeof(FALSE)); //4 bytes</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d bytes \n"</span>, sizeof(0)); //4 bytes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-综合举例"><a href="#5-综合举例" class="headerlink" title="5. 综合举例"></a>5. 综合举例</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">enum Season</span><br><span class="line">&#123;</span><br><span class="line">    spring, summer=100, fall=96, winter</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef enum</span><br><span class="line">&#123;</span><br><span class="line">    Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday</span><br><span class="line">&#125;</span><br><span class="line">Weekday;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    /* Season */</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d \n"</span>, spring); // 0</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d, %c \n"</span>, summer, summer); // 100, d</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d \n"</span>, fall+winter); // 193</span><br><span class="line">    </span><br><span class="line">    Season mySeason=winter;</span><br><span class="line">    <span class="keyword">if</span>(winter==mySeason)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"mySeason is winter \n"</span>); // mySeason is winter</span><br><span class="line">    </span><br><span class="line">    int x=100;</span><br><span class="line">    <span class="keyword">if</span>(x==summer)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"x is equal to summer\n"</span>); // x is equal to summer</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d bytes\n"</span>, sizeof(spring)); // 4 bytes</span><br><span class="line">    </span><br><span class="line">    /* Weekday */</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sizeof Weekday is: %d \n"</span>, sizeof(Weekday)); //sizeof Weekday is: 4</span><br><span class="line">    </span><br><span class="line">    Weekday today = Saturday;</span><br><span class="line">    Weekday tomorrow;</span><br><span class="line">    <span class="keyword">if</span>(today == Monday)</span><br><span class="line">        tomorrow = Tuesday;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tomorrow = (Weekday) (today + 1); //remember to convert from int to Weekday</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C语言</category>
        <category>C语言教程</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>linux命令之解压缩命令</title>
    <url>/2018/01/09/linux%E5%91%BD%E4%BB%A4%E4%B9%8B%E8%A7%A3%E5%8E%8B%E7%BC%A9%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>Linux下的压缩解压缩命令详解及实例</p>
<p>实例：压缩服务器上当前目录的内容为xxx.zip文件<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zip -r xxx.zip ./*</span><br></pre></td></tr></table></figure></p>
<p>解压zip文件到当前目录<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unzip filename.zip</span><br></pre></td></tr></table></figure></p>
<p>另：有些服务器没有安装zip包执行不了zip命令，但基本上都可以用tar命令的，实例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zcvf /home/zdzlibs.tar.gz /home/zdz/java/zdzlibs/</span><br></pre></td></tr></table></figure>
<p>linux zip命令</p>
<p>zip -r myfile.zip ./*<br>将当前目录下的所有文件和文件夹全部压缩成myfile.zip文件,－r表示递归压缩子目录下所有文件.</p>
<p>2.unzip<br>unzip -o -d /home/sunny myfile.zip<br>把myfile.zip文件解压到 /home/sunny/<br>-o:不提示的情况下覆盖文件；<br>-d:-d /home/sunny 指明将文件解压缩到/home/sunny目录下；</p>
<p>3.其他<br>zip -d myfile.zip smart.txt<br>删除压缩文件中smart.txt文件<br>zip -m myfile.zip ./rpm_info.txt</p>
<h2 id="向压缩文件中myfile-zip中添加rpm-info-txt文件"><a href="#向压缩文件中myfile-zip中添加rpm-info-txt文件" class="headerlink" title="向压缩文件中myfile.zip中添加rpm_info.txt文件"></a>向压缩文件中myfile.zip中添加rpm_info.txt文件</h2><p>要使用 zip 来压缩文件，在 shell 提示下键入下面的命令：</p>
<p>zip -r filename.zip filesdir</p>
<p>在这个例子里，filename.zip 代表你创建的文件，filesdir 代表你想放置新 zip 文件的目录。-r 选项指定你想递归地（recursively）包括所有包括在 filesdir 目录中的文件。</p>
<p>要抽取 zip 文件的内容，键入以下命令：</p>
<p>unzip filename.zip</p>
<p>你可以使用 zip 命令同时处理多个文件和目录，方法是将它们逐一列出，并用空格间隔：</p>
<p>zip -r filename.zip file1 file2 file3 /usr/work/school </p>
<p>上面的命令把 file1、file2、 file3、以及 /usr/work/school 目录的内容（假设这个目录存在）压缩起来，然后放入 filename.zip 文件中。</p>
<p>tar 命令详解</p>
<p>　　-c: 建立压缩档案</p>
<p>　　-x：解压</p>
<p>　　-t：查看内容</p>
<p>　　-r：向压缩归档文件末尾追加文件</p>
<p>　　-u：更新原压缩包中的文件</p>
<p>　　这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。</p>
<p>　　-c: 建立压缩档案</p>
<p>　　-x：解压</p>
<p>　　-t：查看内容</p>
<p>　　-r：向压缩归档文件末尾追加文件</p>
<p>　　-u：更新原压缩包中的文件</p>
<p>　　下面的参数-f是必须的</p>
<p>　　-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。</p>
<p>　　# tar -cf all.tar *.jpg</p>
<p>　　这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。</p>
<p>　　# tar -rf all.tar *.gif</p>
<p>　　这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。</p>
<p>　　# tar -uf all.tar logo.gif</p>
<p>　　这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。</p>
<p>　　# tar -tf all.tar</p>
<p>　　这条命令是列出all.tar包中所有文件，-t是列出文件的意思</p>
<p>　　# tar -xf all.tar</p>
<p>　　这条命令是解出all.tar包中所有文件，-t是解开的意思</p>
<p>　　压缩</p>
<p>　　tar –cvf jpg.tar *.jpg //将目录里所有jpg文件打包成tar.jpg</p>
<p>　　tar –czf jpg.tar.gz *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz</p>
<p>　　tar –cjf jpg.tar.bz2 *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2</p>
<p>　　tar –cZf jpg.tar.Z *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z</p>
<p>　　rar a jpg.rar *.jpg //rar格式的压缩，需要先下载rar for linux</p>
<p>　　zip jpg.zip *.jpg //zip格式的压缩，需要先下载zip for linux</p>
<p>　　解压</p>
<p>　　tar –xvf file.tar //解压 tar包</p>
<p>　　tar -xzvf file.tar.gz //解压tar.gz</p>
<p>　　tar -xjvf file.tar.bz2 //解压 tar.bz2</p>
<p>　　tar –xZvf file.tar.Z //解压tar.Z</p>
<p>　　unrar e file.rar //解压rar</p>
<p>　　unzip file.zip //解压zip</p>
<p>　　总结</p>
<p>　　1、*.tar 用 tar –xvf 解压</p>
<p>　　2、*.gz 用 gzip -d或者gunzip 解压</p>
<p>　　3、<em>.tar.gz和</em>.tgz 用 tar –xzf 解压</p>
<p>　　4、*.bz2 用 bzip2 -d或者用bunzip2 解压</p>
<p>　　5、*.tar.bz2用tar –xjf 解压</p>
<p>　　6、*.Z 用 uncompress 解压</p>
<p>　　7、*.tar.Z 用tar –xZf 解压</p>
<p>　　8、*.rar 用 unrar e解压</p>
<p>　　9、*.zip 用 unzip 解压</p>
<p>　　Linux中tar命令详解(转载的资料)</p>
<p>　　2008年04月17日 星期四 15:37</p>
<p>　　tar命令</p>
<p>　　tar 可以为文件和目录创建档案。利用tar，用户可以为某一特定文件创建档案(备份文件)，也可以在档案中改变文件，或者向档案中加入新的文件。tar最初被 用来在磁带上创建档案，现在，用户可以在任何设备上创建档案，如软盘。利用tar命令，可以把一大堆的文件和目录全部打包成一个文件，这对于备份文件或将 几个文件组合成为一个文件以便于网络传输是非常有用的。Linux上的tar是GNU版本的。</p>
<p>　　语法：tar [主选项+辅选项] 文件或者目录</p>
<p>　　使用该命令时，主选项是必须要有的，它告诉tar要做什么事情，辅选项是辅助使用的，可以选用。</p>
<p>　　主选项：</p>
<p>　　c 创建新的档案文件。如果用户想备份一个目录或是一些文件，就要选择这个选项。</p>
<p>　　r 把要存档的文件追加到档案文件的未尾。例如用户已经作好备份文件，又发现还有一个目录或是一些文件忘记备份了，这时可以使用该选项，将忘记的目录或文件追加到备份文件中。</p>
<p>　　t 列出档案文件的内容，查看已经备份了哪些文件。</p>
<p>　　u 更新文件。就是说，用新增的文件取代原备份文件，如果在备份文件中找不到要更新的文件，则把它追加到备份文件的最后。</p>
<p>　　x 从档案文件中释放文件。</p>
<p>　　辅助选项：</p>
<p>　　b 该选项是为磁带机设定的。其后跟一数字，用来说明区块的大小，系统预设值为20(20*512 bytes)。</p>
<p>　　f 使用档案文件或设备，这个选项通常是必选的。</p>
<p>　　k 保存已经存在的文件。例如我们把某个文件还原，在还原的过程中，遇到相同的文件，不会进行覆盖。</p>
<p>　　m 在还原文件时，把所有文件的修改时间设定为现在。</p>
<p>　　M 创建多卷的档案文件，以便在几个磁盘中存放。</p>
<p>　　v 详细报告tar处理的文件信息。如无此选项，tar不报告文件信息。</p>
<p>　　w 每一步都要求确认。</p>
<p>　　z 用gzip来压缩/解压缩文件，加上该选项后可以将档案文件进行压缩，但还原时也一定要使用该选项进行解压缩。</p>
<p>　　Linux下的压缩文件剖析</p>
<p>　　对于刚刚接触Linux的人来说，一定会给Linux下一大堆各式各样的文件名给搞晕。别个不说，单单就压缩文件为例，我们知道在Windows下最常见 的压缩文件就只有两种，一是,zip，另一个是.rap。可是Linux就不同了，它有.gz、.tar.gz、tgz、bz2、.Z、.tar等众多的 压缩文件名，此外windows下的.zip和.rar也可以在Linux下使用，不过在Linux使用.zip和.rar的人就太少了。本文就来对这些 常见的压缩文件进行一番小结，希望你下次遇到这些文件时不至于被搞晕。</p>
<p>　　在具体总结各类压缩文件之前呢，首先要弄清两个概念：打包和压缩。打包是指将一大堆文件或目录什么的变成一个总的文件，压缩则是将一个大的文件通过一些压 缩算法变成一个小文件。为什么要区分这两个概念呢?其实这源于Linux中的很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你就 得先借助另它的工具将这一大堆文件先打成一个包，然后再就原来的压缩程序进行压缩。</p>
<p>　　Linux下最常用的打包程序就是tar了，使用tar程序打出来的包我们常称为tar包，tar包文件的命令通常都是以.tar结尾的。生成tar包后，就可以用其它的程序来进行压缩了，所以首先就来讲讲tar命令的基本用法：</p>
<p>　　tar命令的选项有很多(用man tar可以查看到)，但常用的就那么几个选项，下面来举例说明一下：</p>
<p>　　# tar -cf all.tar *.jpg</p>
<p>　　这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。</p>
<p>　　# tar -rf all.tar *.gif</p>
<p>　　这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。</p>
<p>　　# tar -uf all.tar logo.gif</p>
<p>　　这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。</p>
<p>　　# tar -tf all.tar</p>
<p>　　这条命令是列出all.tar包中所有文件，-t是列出文件的意思</p>
<p>　　# tar -xf all.tar</p>
<p>　　这条命令是解出all.tar包中所有文件，-t是解开的意思</p>
<p>　　以上就是tar的最基本的用法。为了方便用户在打包解包的同时可以压缩或解压文件，tar提供了一种特殊的功能。这就是tar可以在打包或解包的同时调用其它的压缩程序，比如调用gzip、bzip2等。</p>
<p>　　1) tar调用gzip</p>
<p>　　gzip是GNU组织开发的一个压缩程序，.gz结尾的文件就是gzip压缩的结果。与gzip相对的解压程序是gunzip。tar中使用-z这个参数来调用gzip。下面来举例说明一下：</p>
<p>　　# tar -czf all.tar.gz *.jpg</p>
<p>　　这条命令是将所有.jpg的文件打成一个tar包，并且将其用gzip压缩，生成一个gzip压缩过的包，包名为all.tar.gz</p>
<p>　　# tar -xzf all.tar.gz</p>
<p>　　这条命令是将上面产生的包解开。</p>
<p>　　2) tar调用bzip2</p>
<p>　　bzip2是一个压缩能力更强的压缩程序，.bz2结尾的文件就是bzip2压缩的结果。与bzip2相对的解压程序是bunzip2。tar中使用-j这个参数来调用gzip。下面来举例说明一下：</p>
<p>　　# tar -cjf all.tar.bz2 *.jpg</p>
<p>　　这条命令是将所有.jpg的文件打成一个tar包，并且将其用bzip2压缩，生成一个bzip2压缩过的包，包名为all.tar.bz2</p>
<p>　　# tar -xjf all.tar.bz2</p>
<p>　　这条命令是将上面产生的包解开。</p>
<p>　　3)tar调用compress</p>
<p>　　compress也是一个压缩程序，但是好象使用compress的人不如gzip和bzip2的人多。.Z结尾的文件就是bzip2压缩的结果。与 compress相对的解压程序是uncompress。tar中使用-Z这个参数来调用gzip。下面来举例说明一下：</p>
<p>　　# tar -cZf all.tar.Z *.jpg</p>
<p>　　这条命令是将所有.jpg的文件打成一个tar包，并且将其用compress压缩，生成一个uncompress压缩过的包，包名为all.tar.Z</p>
<p>　　# tar -xZf all.tar.Z</p>
<p>　　这条命令是将上面产生的包解开</p>
<p>　　有了上面的知识，你应该可以解开多种压缩文件了，下面对于tar系列的压缩文件作一个小结：</p>
<p>　　1)对于.tar结尾的文件</p>
<p>　　tar -xf all.tar</p>
<p>　　2)对于.gz结尾的文件</p>
<p>　　gzip -d all.gz</p>
<p>　　gunzip all.gz</p>
<p>　　3)对于.tgz或.tar.gz结尾的文件</p>
<p>　　tar -xzf all.tar.gz</p>
<p>　　tar -xzf all.tgz</p>
<p>　　4)对于.bz2结尾的文件</p>
<p>　　bzip2 -d all.bz2</p>
<p>　　bunzip2 all.bz2</p>
<p>　　5)对于tar.bz2结尾的文件</p>
<p>　　tar -xjf all.tar.bz2</p>
<p>　　6)对于.Z结尾的文件</p>
<p>　　uncompress all.Z</p>
<p>　　7)对于.tar.Z结尾的文件</p>
<p>　　tar -xZf all.tar.z</p>
<p>　　另外对于Window下的常见压缩文件.zip和.rar，Linux也有相应的方法来解压它们：</p>
<p>　　1)对于.zip</p>
<p>　　linux下提供了zip和unzip程序，zip是压缩程序，unzip是解压程序。它们的参数选项很多，这里只做简单介绍，依旧举例说明一下其用法：</p>
<p>　　# zip all.zip *.jpg</p>
<p>　　这条命令是将所有.jpg的文件压缩成一个zip包</p>
<p>　　# unzip all.zip</p>
<p>　　这条命令是将all.zip中的所有文件解压出来</p>
<p>　　2)对于.rar</p>
<p>　　要在linux下处理.rar文件，需要安装RAR for Linux，可以从网上下载，但要记住，RAR for Linux</p>
<p>　　不是免费的;然后安装：</p>
<p>　　# tar -xzpvf rarlinux-3.2.0.tar.gz</p>
<p>　　# cd rar</p>
<p>　　# make</p>
<p>　　这样就安装好了，安装后就有了rar和unrar这两个程序，rar是压缩程序，unrar是解压程序。它们的参数选项很多，这里只做简单介绍，依旧举例说明一下其用法：</p>
<p>　　# rar a all *.jpg</p>
<p>　　这条命令是将所有.jpg的文件压缩成一个rar包，名为all.rar，该程序会将.rar 扩展名将自动附加到包名后。</p>
<p>　　# unrar e all.rar</p>
<p>　　这条命令是将all.rar中的所有文件解压出来</p>
<p>　　到此为至，我们已经介绍过linux下的tar、gzip、gunzip、bzip2、bunzip2、compress、uncompress、 zip、unzip、rar、unrar等程式，你应该已经能够使用它们对.tar、.gz、.tar.gz、.tgz、.bz2、.tar.bz2、. Z、.tar.Z、.zip、.rar这10种压缩文件进行解压了，以后应该不需要为下载了一个软件而不知道如何在Linux下解开而烦恼了。而且以上方 法对于Unix也基本有效。</p>
<p>　　本文介绍了linux下的压缩程式tar、gzip、gunzip、bzip2、bunzip2、 compress、uncompress、zip、unzip、rar、unrar等程式，以及如何使用它们对.tar、.gz、.tar.gz、. tgz、.bz2、.tar.bz2、.Z、.tar.Z、.zip、.rar这10种压缩文件进行操作</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>linux命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
        <tag>解压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu下ReText编辑器安装与配置</title>
    <url>/2018/01/07/ubuntu%E4%B8%8BReText%E7%BC%96%E8%BE%91%E5%99%A8%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="1-Retext-的安装"><a href="#1-Retext-的安装" class="headerlink" title="1. Retext 的安装"></a>1. Retext 的安装</h1><p>在Ubuntu中只需要<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install retext</span><br></pre></td></tr></table></figure></p>
<p>即可以安装该软件，其效果如下：<br><img src="2018-01-07 20-31-25屏幕截图.png" alt="2018-01-07 20-31-25屏幕截图.png"></p>
<h1 id="2-Retext配置"><a href="#2-Retext配置" class="headerlink" title="2. Retext配置"></a>2. Retext配置</h1><h2 id="2-1-添加数学公式"><a href="#2-1-添加数学公式" class="headerlink" title="2.1 添加数学公式"></a>2.1 添加数学公式</h2><p>下载安装MathJax<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libjs-mathjax</span><br></pre></td></tr></table></figure></p>
<p>打开ReText的设置界面，在Markdown extensions框里添加字段：mathjax</p>
<p>编辑(Edit) –&gt; 个人偏好（Preference），打开Preferences - Retext界面，输入mathjax</p>
<p><img src="2018-01-07 20-42-30屏幕截图.png" alt="2018-01-07 20-42-30屏幕截图.png"></p>
<p>重启ReText之后，输入公式，在预览中不显示。此时，通过 编辑(Edit) –&gt; 使用WebKit渲染， 就可以完美解决问题。</p>
<p>示例：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$\frac&#123;1&#125;&#123;2x+1&#125;$或者<span class="variable">$1</span>\over&#123;2x+1&#125;$</span><br></pre></td></tr></table></figure></p>
<p>效果：$\frac{1}{2x+1}$或者$1\over{2x+1}$</p>
<h2 id="2-2-添加语法高亮"><a href="#2-2-添加语法高亮" class="headerlink" title="2.2 添加语法高亮"></a>2.2 添加语法高亮</h2><p>(1) 下载安装高亮支持模块python-pygments<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python-pygments</span><br></pre></td></tr></table></figure></p>
<p>(2) 打开ReText的设置界面，在Markdown extensions框里添加字段 codehilite<br>需要注意：</p>
<pre><code>1、文档里的扩展功能添加进ReText的Markdown extensions时，都必须该成小写字母，否则无效！

2、两个扩展之间用英文逗号分割。
</code></pre><h2 id="2-3-添加自定义CSS"><a href="#2-3-添加自定义CSS" class="headerlink" title="2.3 添加自定义CSS"></a>2.3 添加自定义CSS</h2><p>reText支持添加自定义的css，比如，添加 github-markdown-css 方法如下：</p>
<p>打开 编辑 –&gt;个人偏好（Preferences），打开PreferencesReText对话框。然后在Interface下面，点击Color scheme file，选择github-markdown-css.css，重新启动即可。    </p>
<p>其中，github-markdown.css的内容如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@font-face &#123;</span><br><span class="line">  font-family: octicons-link;</span><br><span class="line">  src: url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAAAZwABAAAAAACFQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABEU0lHAAAGaAAAAAgAAAAIAAAAAUdTVUIAAAZcAAAACgAAAAoAAQAAT1MvMgAAAyQAAABJAAAAYFYEU3RjbWFwAAADcAAAAEUAAACAAJThvmN2dCAAAATkAAAABAAAAAQAAAAAZnBnbQAAA7gAAACyAAABCUM+8IhnYXNwAAAGTAAAABAAAAAQABoAI2dseWYAAAFsAAABPAAAAZwcEq9taGVhZAAAAsgAAAA0AAAANgh4a91oaGVhAAADCAAAABoAAAAkCA8DRGhtdHgAAAL8AAAADAAAAAwGAACfbG9jYQAAAsAAAAAIAAAACABiATBtYXhwAAACqAAAABgAAAAgAA8ASm5hbWUAAAToAAABQgAAAlXu73sOcG9zdAAABiwAAAAeAAAAME3QpOBwcmVwAAAEbAAAAHYAAAB/aFGpk3jaTY6xa8JAGMW/O62BDi0tJLYQincXEypYIiGJjSgHniQ6umTsUEyLm5BV6NDBP8Tpts6F0v+k/0an2i+itHDw3v2+9+DBKTzsJNnWJNTgHEy4BgG3EMI9DCEDOGEXzDADU5hBKMIgNPZqoD3SilVaXZCER3/I7AtxEJLtzzuZfI+VVkprxTlXShWKb3TBecG11rwoNlmmn1P2WYcJczl32etSpKnziC7lQyWe1smVPy/Lt7Kc+0vWY/gAgIIEqAN9we0pwKXreiMasxvabDQMM4riO+qxM2ogwDGOZTXxwxDiycQIcoYFBLj5K3EIaSctAq2kTYiw+ymhce7vwM9jSqO8JyVd5RH9gyTt2+J/yUmYlIR0s04n6+7Vm1ozezUeLEaUjhaDSuXHwVRgvLJn1tQ7xiuVv/ocTRF42mNgZGBgYGbwZOBiAAFGJBIMAAizAFoAAABiAGIAznjaY2BkYGAA4in8zwXi+W2+MjCzMIDApSwvXzC97Z4Ig8N/BxYGZgcgl52BCSQKAA3jCV8CAABfAAAAAAQAAEB42mNgZGBg4f3vACQZQABIMjKgAmYAKEgBXgAAeNpjYGY6wTiBgZWBg2kmUxoDA4MPhGZMYzBi1AHygVLYQUCaawqDA4PChxhmh/8ODDEsvAwHgMKMIDnGL0x7gJQCAwMAJd4MFwAAAHjaY2BgYGaA4DAGRgYQkAHyGMF8NgYrIM3JIAGVYYDT+AEjAwuDFpBmA9KMDEwMCh9i/v8H8sH0/4dQc1iAmAkALaUKLgAAAHjaTY9LDsIgEIbtgqHUPpDi3gPoBVyRTmTddOmqTXThEXqrob2gQ1FjwpDvfwCBdmdXC5AVKFu3e5MfNFJ29KTQT48Ob9/lqYwOGZxeUelN2U2R6+cArgtCJpauW7UQBqnFkUsjAY/kOU1cP+DAgvxwn1chZDwUbd6CFimGXwzwF6tPbFIcjEl+vvmM/byA48e6tWrKArm4ZJlCbdsrxksL1AwWn/yBSJKpYbq8AXaaTb8AAHja28jAwOC00ZrBeQNDQOWO//sdBBgYGRiYWYAEELEwMTE4uzo5Zzo5b2BxdnFOcALxNjA6b2ByTswC8jYwg0VlNuoCTWAMqNzMzsoK1rEhNqByEyerg5PMJlYuVueETKcd/89uBpnpvIEVomeHLoMsAAe1Id4AAAAAAAB42oWQT07CQBTGv0JBhagk7HQzKxca2sJCE1hDt4QF+9JOS0nbaaYDCQfwCJ7Au3AHj+LO13FMmm6cl7785vven0kBjHCBhfpYuNa5Ph1c0e2Xu3jEvWG7UdPDLZ4N92nOm+EBXuAbHmIMSRMs+4aUEd4Nd3CHD8NdvOLTsA2GL8M9PODbcL+hD7C1xoaHeLJSEao0FEW14ckxC+TU8TxvsY6X0eLPmRhry2WVioLpkrbp84LLQPGI7c6sOiUzpWIWS5GzlSgUzzLBSikOPFTOXqly7rqx0Z1Q5BAIoZBSFihQYQOOBEdkCOgXTOHA07HAGjGWiIjaPZNW13/+lm6S9FT7rLHFJ6fQbkATOG1j2OFMucKJJsxIVfQORl+9Jyda6Sl1dUYhSCm1dyClfoeDve4qMYdLEbfqHf3O/AdDumsjAAB42mNgYoAAZQYjBmyAGYQZmdhL8zLdDEydARfoAqIAAAABAAMABwAKABMAB///AA8AAQAAAAAAAAAAAAAAAAABAAAAAA==) format(<span class="string">'woff'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body &#123;</span><br><span class="line">  -ms-text-size-adjust: 100%;</span><br><span class="line">  -webkit-text-size-adjust: 100%;</span><br><span class="line">  line-height: 1.5;</span><br><span class="line">  color: <span class="comment">#333;</span></span><br><span class="line">  font-family: -apple-system, BlinkMacSystemFont, <span class="string">"Segoe UI"</span>, Roboto, Helvetica, Arial, sans-serif, <span class="string">"Apple Color Emoji"</span>, <span class="string">"Segoe UI Emoji"</span>, <span class="string">"Segoe UI Symbol"</span>;</span><br><span class="line">  font-size: 16px;</span><br><span class="line">  line-height: 1.5;</span><br><span class="line">  word-wrap: <span class="built_in">break</span>-word;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body .pl-c &#123;</span><br><span class="line">  color: <span class="comment">#969896;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body .pl-c1,</span><br><span class="line">.markdown-body .pl<span class="_">-s</span> .pl-v &#123;</span><br><span class="line">  color: <span class="comment">#0086b3;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body .pl<span class="_">-e</span>,</span><br><span class="line">.markdown-body .pl-en &#123;</span><br><span class="line">  color: <span class="comment">#795da3;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body .pl-smi,</span><br><span class="line">.markdown-body .pl<span class="_">-s</span> .pl-s1 &#123;</span><br><span class="line">  color: <span class="comment">#333;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body .pl-ent &#123;</span><br><span class="line">  color: <span class="comment">#63a35c;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body .pl-k &#123;</span><br><span class="line">  color: <span class="comment">#a71d5d;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body .pl<span class="_">-s</span>,</span><br><span class="line">.markdown-body .pl-pds,</span><br><span class="line">.markdown-body .pl<span class="_">-s</span> .pl-pse .pl-s1,</span><br><span class="line">.markdown-body .pl-sr,</span><br><span class="line">.markdown-body .pl-sr .pl-cce,</span><br><span class="line">.markdown-body .pl-sr .pl-sre,</span><br><span class="line">.markdown-body .pl-sr .pl-sra &#123;</span><br><span class="line">  color: <span class="comment">#183691;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body .pl-v &#123;</span><br><span class="line">  color: <span class="comment">#ed6a43;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body .pl-id &#123;</span><br><span class="line">  color: <span class="comment">#b52a1d;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body .pl-ii &#123;</span><br><span class="line">  color: <span class="comment">#f8f8f8;</span></span><br><span class="line">  background-color: <span class="comment">#b52a1d;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body .pl-sr .pl-cce &#123;</span><br><span class="line">  font-weight: bold;</span><br><span class="line">  color: <span class="comment">#63a35c;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body .pl-ml &#123;</span><br><span class="line">  color: <span class="comment">#693a17;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body .pl-mh,</span><br><span class="line">.markdown-body .pl-mh .pl-en,</span><br><span class="line">.markdown-body .pl-ms &#123;</span><br><span class="line">  font-weight: bold;</span><br><span class="line">  color: <span class="comment">#1d3e81;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body .pl-mq &#123;</span><br><span class="line">  color: <span class="comment">#008080;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body .pl-mi &#123;</span><br><span class="line">  font-style: italic;</span><br><span class="line">  color: <span class="comment">#333;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body .pl-mb &#123;</span><br><span class="line">  font-weight: bold;</span><br><span class="line">  color: <span class="comment">#333;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body .pl-md &#123;</span><br><span class="line">  color: <span class="comment">#bd2c00;</span></span><br><span class="line">  background-color: <span class="comment">#ffecec;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body .pl-mi1 &#123;</span><br><span class="line">  color: <span class="comment">#55a532;</span></span><br><span class="line">  background-color: <span class="comment">#eaffea;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body .pl-mdr &#123;</span><br><span class="line">  font-weight: bold;</span><br><span class="line">  color: <span class="comment">#795da3;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body .pl-mo &#123;</span><br><span class="line">  color: <span class="comment">#1d3e81;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body .octicon &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  vertical-align: text-top;</span><br><span class="line">  fill: currentColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body a &#123;</span><br><span class="line">  background-color: transparent;</span><br><span class="line">  -webkit-text-decoration-skip: objects;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body a:active,</span><br><span class="line">.markdown-body a:hover &#123;</span><br><span class="line">  outline-width: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body strong &#123;</span><br><span class="line">  font-weight: inherit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body strong &#123;</span><br><span class="line">  font-weight: bolder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body h1 &#123;</span><br><span class="line">  font-size: 2em;</span><br><span class="line">  margin: 0.67em 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body img &#123;</span><br><span class="line">  border-style: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body svg:not(:root) &#123;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body code,</span><br><span class="line">.markdown-body kbd,</span><br><span class="line">.markdown-body pre &#123;</span><br><span class="line">  font-family: monospace, monospace;</span><br><span class="line">  font-size: 1em;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body hr &#123;</span><br><span class="line">  box-sizing: content-box;</span><br><span class="line">  height: 0;</span><br><span class="line">  overflow: visible;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body input &#123;</span><br><span class="line">  font: inherit;</span><br><span class="line">  margin: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body input &#123;</span><br><span class="line">  overflow: visible;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body [<span class="built_in">type</span>=<span class="string">"checkbox"</span>] &#123;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  padding: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body * &#123;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body input &#123;</span><br><span class="line">  font-family: inherit;</span><br><span class="line">  font-size: inherit;</span><br><span class="line">  line-height: inherit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body a &#123;</span><br><span class="line">  color: <span class="comment">#4078c0;</span></span><br><span class="line">  text-decoration: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body a:hover,</span><br><span class="line">.markdown-body a:active &#123;</span><br><span class="line">  text-decoration: underline;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body strong &#123;</span><br><span class="line">  font-weight: 600;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body hr &#123;</span><br><span class="line">  height: 0;</span><br><span class="line">  margin: 15px 0;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  background: transparent;</span><br><span class="line">  border: 0;</span><br><span class="line">  border-bottom: 1px solid <span class="comment">#ddd;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body hr::before &#123;</span><br><span class="line">  display: table;</span><br><span class="line">  content: <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body hr::after &#123;</span><br><span class="line">  display: table;</span><br><span class="line">  clear: both;</span><br><span class="line">  content: <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body table &#123;</span><br><span class="line">  border-spacing: 0;</span><br><span class="line">  border-collapse: collapse;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body td,</span><br><span class="line">.markdown-body th &#123;</span><br><span class="line">  padding: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body h1,</span><br><span class="line">.markdown-body h2,</span><br><span class="line">.markdown-body h3,</span><br><span class="line">.markdown-body h4,</span><br><span class="line">.markdown-body h5,</span><br><span class="line">.markdown-body h6 &#123;</span><br><span class="line">  margin-top: 0;</span><br><span class="line">  margin-bottom: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body h1 &#123;</span><br><span class="line">  font-size: 32px;</span><br><span class="line">  font-weight: 600;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body h2 &#123;</span><br><span class="line">  font-size: 24px;</span><br><span class="line">  font-weight: 600;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body h3 &#123;</span><br><span class="line">  font-size: 20px;</span><br><span class="line">  font-weight: 600;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body h4 &#123;</span><br><span class="line">  font-size: 16px;</span><br><span class="line">  font-weight: 600;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body h5 &#123;</span><br><span class="line">  font-size: 14px;</span><br><span class="line">  font-weight: 600;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body h6 &#123;</span><br><span class="line">  font-size: 12px;</span><br><span class="line">  font-weight: 600;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body p &#123;</span><br><span class="line">  margin-top: 0;</span><br><span class="line">  margin-bottom: 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body blockquote &#123;</span><br><span class="line">  margin: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body ul,</span><br><span class="line">.markdown-body ol &#123;</span><br><span class="line">  padding-left: 0;</span><br><span class="line">  margin-top: 0;</span><br><span class="line">  margin-bottom: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body ol ol,</span><br><span class="line">.markdown-body ul ol &#123;</span><br><span class="line">  list-style-type: lower-roman;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body ul ul ol,</span><br><span class="line">.markdown-body ul ol ol,</span><br><span class="line">.markdown-body ol ul ol,</span><br><span class="line">.markdown-body ol ol ol &#123;</span><br><span class="line">  list-style-type: lower-alpha;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body dd &#123;</span><br><span class="line">  margin-left: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body code &#123;</span><br><span class="line">  font-family: Consolas, <span class="string">"Liberation Mono"</span>, Menlo, Courier, monospace;</span><br><span class="line">  font-size: 12px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body pre &#123;</span><br><span class="line">  margin-top: 0;</span><br><span class="line">  margin-bottom: 0;</span><br><span class="line">  font: 12px Consolas, <span class="string">"Liberation Mono"</span>, Menlo, Courier, monospace;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body .octicon &#123;</span><br><span class="line">  vertical-align: text-bottom;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body input &#123;</span><br><span class="line">  -webkit-font-feature-settings: <span class="string">"liga"</span> 0;</span><br><span class="line">  font-feature-settings: <span class="string">"liga"</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body::before &#123;</span><br><span class="line">  display: table;</span><br><span class="line">  content: <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body::after &#123;</span><br><span class="line">  display: table;</span><br><span class="line">  clear: both;</span><br><span class="line">  content: <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body&gt;*:first-child &#123;</span><br><span class="line">  margin-top: 0 !important;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body&gt;*:last-child &#123;</span><br><span class="line">  margin-bottom: 0 !important;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body a:not([href]) &#123;</span><br><span class="line">  color: inherit;</span><br><span class="line">  text-decoration: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body .anchor &#123;</span><br><span class="line">  <span class="built_in">float</span>: left;</span><br><span class="line">  padding-right: 4px;</span><br><span class="line">  margin-left: -20px;</span><br><span class="line">  line-height: 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body .anchor:focus &#123;</span><br><span class="line">  outline: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body p,</span><br><span class="line">.markdown-body blockquote,</span><br><span class="line">.markdown-body ul,</span><br><span class="line">.markdown-body ol,</span><br><span class="line">.markdown-body dl,</span><br><span class="line">.markdown-body table,</span><br><span class="line">.markdown-body pre &#123;</span><br><span class="line">  margin-top: 0;</span><br><span class="line">  margin-bottom: 16px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body hr &#123;</span><br><span class="line">  height: 0.25em;</span><br><span class="line">  padding: 0;</span><br><span class="line">  margin: 24px 0;</span><br><span class="line">  background-color: <span class="comment">#e7e7e7;</span></span><br><span class="line">  border: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body blockquote &#123;</span><br><span class="line">  padding: 0 1em;</span><br><span class="line">  color: <span class="comment">#777;</span></span><br><span class="line">  border-left: 0.25em solid <span class="comment">#ddd;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body blockquote&gt;:first-child &#123;</span><br><span class="line">  margin-top: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body blockquote&gt;:last-child &#123;</span><br><span class="line">  margin-bottom: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body kbd &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  padding: 3px 5px;</span><br><span class="line">  font-size: 11px;</span><br><span class="line">  line-height: 10px;</span><br><span class="line">  color: <span class="comment">#555;</span></span><br><span class="line">  vertical-align: middle;</span><br><span class="line">  background-color: <span class="comment">#fcfcfc;</span></span><br><span class="line">  border: solid 1px <span class="comment">#ccc;</span></span><br><span class="line">  border-bottom-color: <span class="comment">#bbb;</span></span><br><span class="line">  border-radius: 3px;</span><br><span class="line">  box-shadow: inset 0 -1px 0 <span class="comment">#bbb;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body h1,</span><br><span class="line">.markdown-body h2,</span><br><span class="line">.markdown-body h3,</span><br><span class="line">.markdown-body h4,</span><br><span class="line">.markdown-body h5,</span><br><span class="line">.markdown-body h6 &#123;</span><br><span class="line">  margin-top: 24px;</span><br><span class="line">  margin-bottom: 16px;</span><br><span class="line">  font-weight: 600;</span><br><span class="line">  line-height: 1.25;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body h1 .octicon-link,</span><br><span class="line">.markdown-body h2 .octicon-link,</span><br><span class="line">.markdown-body h3 .octicon-link,</span><br><span class="line">.markdown-body h4 .octicon-link,</span><br><span class="line">.markdown-body h5 .octicon-link,</span><br><span class="line">.markdown-body h6 .octicon-link &#123;</span><br><span class="line">  color: <span class="comment">#000;</span></span><br><span class="line">  vertical-align: middle;</span><br><span class="line">  visibility: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body h1:hover .anchor,</span><br><span class="line">.markdown-body h2:hover .anchor,</span><br><span class="line">.markdown-body h3:hover .anchor,</span><br><span class="line">.markdown-body h4:hover .anchor,</span><br><span class="line">.markdown-body h5:hover .anchor,</span><br><span class="line">.markdown-body h6:hover .anchor &#123;</span><br><span class="line">  text-decoration: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body h1:hover .anchor .octicon-link,</span><br><span class="line">.markdown-body h2:hover .anchor .octicon-link,</span><br><span class="line">.markdown-body h3:hover .anchor .octicon-link,</span><br><span class="line">.markdown-body h4:hover .anchor .octicon-link,</span><br><span class="line">.markdown-body h5:hover .anchor .octicon-link,</span><br><span class="line">.markdown-body h6:hover .anchor .octicon-link &#123;</span><br><span class="line">  visibility: visible;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body h1 &#123;</span><br><span class="line">  padding-bottom: 0.3em;</span><br><span class="line">  font-size: 2em;</span><br><span class="line">  border-bottom: 1px solid <span class="comment">#eee;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body h2 &#123;</span><br><span class="line">  padding-bottom: 0.3em;</span><br><span class="line">  font-size: 1.5em;</span><br><span class="line">  border-bottom: 1px solid <span class="comment">#eee;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body h3 &#123;</span><br><span class="line">  font-size: 1.25em;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body h4 &#123;</span><br><span class="line">  font-size: 1em;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body h5 &#123;</span><br><span class="line">  font-size: 0.875em;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body h6 &#123;</span><br><span class="line">  font-size: 0.85em;</span><br><span class="line">  color: <span class="comment">#777;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body ul,</span><br><span class="line">.markdown-body ol &#123;</span><br><span class="line">  padding-left: 2em;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body ul ul,</span><br><span class="line">.markdown-body ul ol,</span><br><span class="line">.markdown-body ol ol,</span><br><span class="line">.markdown-body ol ul &#123;</span><br><span class="line">  margin-top: 0;</span><br><span class="line">  margin-bottom: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body li&gt;p &#123;</span><br><span class="line">  margin-top: 16px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body li+li &#123;</span><br><span class="line">  margin-top: 0.25em;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body dl &#123;</span><br><span class="line">  padding: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body dl dt &#123;</span><br><span class="line">  padding: 0;</span><br><span class="line">  margin-top: 16px;</span><br><span class="line">  font-size: 1em;</span><br><span class="line">  font-style: italic;</span><br><span class="line">  font-weight: bold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body dl dd &#123;</span><br><span class="line">  padding: 0 16px;</span><br><span class="line">  margin-bottom: 16px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body table &#123;</span><br><span class="line">  display: block;</span><br><span class="line">  width: 100%;</span><br><span class="line">  overflow: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body table th &#123;</span><br><span class="line">  font-weight: bold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body table th,</span><br><span class="line">.markdown-body table td &#123;</span><br><span class="line">  padding: 6px 13px;</span><br><span class="line">  border: 1px solid <span class="comment">#ddd;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body table tr &#123;</span><br><span class="line">  background-color: <span class="comment">#fff;</span></span><br><span class="line">  border-top: 1px solid <span class="comment">#ccc;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body table tr:nth-child(2n) &#123;</span><br><span class="line">  background-color: <span class="comment">#f8f8f8;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body img &#123;</span><br><span class="line">  max-width: 100%;</span><br><span class="line">  box-sizing: content-box;</span><br><span class="line">  background-color: <span class="comment">#fff;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body code &#123;</span><br><span class="line">  padding: 0;</span><br><span class="line">  padding-top: 0.2em;</span><br><span class="line">  padding-bottom: 0.2em;</span><br><span class="line">  margin: 0;</span><br><span class="line">  font-size: 85%;</span><br><span class="line">  background-color: rgba(0,0,0,0.04);</span><br><span class="line">  border-radius: 3px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body code::before,</span><br><span class="line">.markdown-body code::after &#123;</span><br><span class="line">  letter-spacing: -0.2em;</span><br><span class="line">  content: <span class="string">"\00a0"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body pre &#123;</span><br><span class="line">  word-wrap: normal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body pre&gt;code &#123;</span><br><span class="line">  padding: 0;</span><br><span class="line">  margin: 0;</span><br><span class="line">  font-size: 100%;</span><br><span class="line">  word-break: normal;</span><br><span class="line">  white-space: pre;</span><br><span class="line">  background: transparent;</span><br><span class="line">  border: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body .highlight &#123;</span><br><span class="line">  margin-bottom: 16px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body .highlight pre &#123;</span><br><span class="line">  margin-bottom: 0;</span><br><span class="line">  word-break: normal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body .highlight pre,</span><br><span class="line">.markdown-body pre &#123;</span><br><span class="line">  padding: 16px;</span><br><span class="line">  overflow: auto;</span><br><span class="line">  font-size: 85%;</span><br><span class="line">  line-height: 1.45;</span><br><span class="line">  background-color: <span class="comment">#f7f7f7;</span></span><br><span class="line">  border-radius: 3px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body pre code &#123;</span><br><span class="line">  display: inline;</span><br><span class="line">  max-width: auto;</span><br><span class="line">  padding: 0;</span><br><span class="line">  margin: 0;</span><br><span class="line">  overflow: visible;</span><br><span class="line">  line-height: inherit;</span><br><span class="line">  word-wrap: normal;</span><br><span class="line">  background-color: transparent;</span><br><span class="line">  border: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body pre code::before,</span><br><span class="line">.markdown-body pre code::after &#123;</span><br><span class="line">  content: normal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body .pl-0 &#123;</span><br><span class="line">  padding-left: 0 !important;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body .pl-1 &#123;</span><br><span class="line">  padding-left: 3px !important;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body .pl-2 &#123;</span><br><span class="line">  padding-left: 6px !important;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body .pl-3 &#123;</span><br><span class="line">  padding-left: 12px !important;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body .pl-4 &#123;</span><br><span class="line">  padding-left: 24px !important;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body .pl-5 &#123;</span><br><span class="line">  padding-left: 36px !important;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body .pl-6 &#123;</span><br><span class="line">  padding-left: 48px !important;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body .full-commit .btn-outline:not(:disabled):hover &#123;</span><br><span class="line">  color: <span class="comment">#4078c0;</span></span><br><span class="line">  border: 1px solid <span class="comment">#4078c0;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body kbd &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  padding: 3px 5px;</span><br><span class="line">  font: 11px Consolas, <span class="string">"Liberation Mono"</span>, Menlo, Courier, monospace;</span><br><span class="line">  line-height: 10px;</span><br><span class="line">  color: <span class="comment">#555;</span></span><br><span class="line">  vertical-align: middle;</span><br><span class="line">  background-color: <span class="comment">#fcfcfc;</span></span><br><span class="line">  border: solid 1px <span class="comment">#ccc;</span></span><br><span class="line">  border-bottom-color: <span class="comment">#bbb;</span></span><br><span class="line">  border-radius: 3px;</span><br><span class="line">  box-shadow: inset 0 -1px 0 <span class="comment">#bbb;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body :checked+.radio-label &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  z-index: 1;</span><br><span class="line">  border-color: <span class="comment">#4078c0;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body .task-list-item &#123;</span><br><span class="line">  list-style-type: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body .task-list-item+.task-list-item &#123;</span><br><span class="line">  margin-top: 3px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body .task-list-item input &#123;</span><br><span class="line">  margin: 0 0.2em 0.25em -1.6em;</span><br><span class="line">  vertical-align: middle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.markdown-body hr &#123;</span><br><span class="line">  border-bottom-color: <span class="comment">#eee;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>ReText使用教程</category>
      </categories>
      <tags>
        <tag>ReText使用说明</tag>
        <tag>ReText配置</tag>
      </tags>
  </entry>
  <entry>
    <title>经典电路之运算放大器基本电路</title>
    <url>/2018/01/08/%E7%BB%8F%E5%85%B8%E7%94%B5%E8%B7%AF%E4%B9%8B%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E5%9F%BA%E6%9C%AC%E7%94%B5%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="虚短和虚断的概念"><a href="#虚短和虚断的概念" class="headerlink" title="虚短和虚断的概念"></a>虚短和虚断的概念</h2><p>由于运放的电压放大倍数很大，一般通用型运算放大器的开环电压放大倍数都在80 dB以上。而运放的输出电压是有限的，一般在 10 V～14 V。因此运放的差模输入电压不足1 mV，两输入端近似等电位，相当于 “短路”。开环电压放大倍数越大，两输入端的电位越接近相等。</p>
<p><strong>  “虚短”是指在分析运算放大器处于线性状态时，可把两输入端视为等电位，这一特性称为虚假短路，简称虚短。显然不能将两输入端真正短路。 </strong></p>
<p>由于运放的差模输入电阻很大，一般通用型运算放大器的输入电阻都在1MΩ以上。因此流入运放输入端的电流往往不足1uA，远小于输入端外电路的电流。故 通常可把运放的两输入端视为开路，且输入电阻越大，两输入端越接近开路。</p>
<p><strong>  “虚断”是指在分析运放处于线性状态时，可以把两输入端视为等效开路，这一特性 称为虚假开路，简称虚断。显然不能将两输入端真正断路。 </strong></p>
<p>在分析运放电路工作原理时，首先请各位暂时忘掉什么同向放大、反向放大，什么加法器、减法器，什么差动输入……暂时忘掉那些输入输出关系的公式……这些东东只会干扰你，让你更糊涂﹔也请各位暂时不要理会输入偏置电流、共模抑制比、失调电压等电路参数，这是设计者要考虑的事情。我们理解的就是理想放大器（其实在维修中和大多数设计过程中，把实际放大器当做理想放大器来分析也不会有问题）。</p>
<h2 id="1-反向放大器"><a href="#1-反向放大器" class="headerlink" title="1.反向放大器"></a>1.反向放大器</h2><p><img src="http://uphotos.eepw.com.cn/jackwang/pics/2058bef8c165b781f37ad61ddfea2273.jpg" alt="img"></p>
<p>图一运放的同向端接地=0V，反向端和同向端虚短，所以也是0V，反向输入端输入电阻很高，虚断，几乎没有电流注入和流出，那么R1和R2相当于是串联的，流过一个串联电路中的每一只组件的电流是相同的，即流过R1的电流和流过R2的电流是相同的。<br>流过R1的电流</p>
<script type="math/tex; mode=display">I1 =\frac{V_i - V_-}{R1}</script><p>流过R2的电流</p>
<script type="math/tex; mode=display">I2 =\frac{V_-- Vout}{R2}</script><p>由虚短得</p>
<script type="math/tex; mode=display">V_- = V_+ = 0</script><p>由虚断得</p>
<script type="math/tex; mode=display">I1 = I2</script><p>求解上面的初中代数方程得</p>
<script type="math/tex; mode=display">Vout = -\frac{R2}{R1} \cdot Vi</script><p>这就是传说中的反向放大器的输入输出关系式了。</p>
<h2 id="2-正向放大器"><a href="#2-正向放大器" class="headerlink" title="2.正向放大器"></a>2.正向放大器</h2><p><img src="http://uphotos.eepw.com.cn/jackwang/pics/30f445811662fd9bb5ede4e8a0bdfcff.jpg" alt="img"><br>图二中Vi与V-虚短，则</p>
<script type="math/tex; mode=display">V_i = V_-</script><p>因为虚断，反向输入端没有电流输入输出，通过R1和R2 的电流相等，设此电流为I，由欧姆定律得：</p>
<script type="math/tex; mode=display">I = \frac{Vout}{R1+R2}</script><p>Vi等于R2上的分压， 即：</p>
<script type="math/tex; mode=display">Vi = I\cdot R2</script><p>由上得</p>
<script type="math/tex; mode=display">Vout=Vi\cdot \frac{R1+R2}{R2}</script><p>这就是传说中的同向放大器的公式了。</p>
<h2 id="3-加法器"><a href="#3-加法器" class="headerlink" title="3.加法器"></a>3.加法器</h2><p><img src="http://uphotos.eepw.com.cn/jackwang/pics/305e521499284d03efea95e20be26542.jpg" alt="img"><br>图三中，<br>由虚断及基尔霍夫定律知，通过R2与R1的电流之和等于通过R3的电流，故 </p>
<script type="math/tex; mode=display">\frac{V_1 – V_-}{R1} + \frac{V_2 – V_-}{R2} = \frac{ V_-–V_{out} }{R3} \cdot\cdot\cdot\cdot\cdot\cdot(1)</script><p>由虚短知： </p>
<script type="math/tex; mode=display">V_- = V_+ = 0            \cdot\cdot\cdot\cdot\cdot\cdot(2)</script><p>代入(2)式，(1)式变为</p>
<script type="math/tex; mode=display">\frac{V_1}{R1} + \frac{V_2}{R2} = \frac{ –V_{out} }{R3}</script><p>如果取$R1=R2=R3$，则上式变为</p>
<script type="math/tex; mode=display">V_{out}=-(V_1+V_2)</script><p>这就是传说中的加法器了。</p>
<p><img src="http://uphotos.eepw.com.cn/jackwang/pics/5a50c7dc8d8cf952cea6b74ac514a3aa.jpg" alt="img"></p>
<p>由虚断知：运放同向端没有电流流过，则流过R1和R2的电流相等，同理流过R4和R3的电流也相等。故</p>
<script type="math/tex; mode=display">\frac{V_1 – V_+}{R1} =\frac{V_+ - V_2}{R2}</script><script type="math/tex; mode=display">\frac{V_{out} – V_-}{R3} = \frac{V_-}{R4}</script><p>由虚短知：<script type="math/tex">V_+ = V_-</script><br>如果 <script type="math/tex">R1=R2，R3=R4</script>，则由以上式子可以推导出</p>
<script type="math/tex; mode=display">V_+ = (V1 + V2)/2</script><script type="math/tex; mode=display">V_- = V_{out}/2</script><p>故</p>
<script type="math/tex; mode=display">V_{out} = V_1 + V_2</script><p>也是一个加法器！</p>
<h2 id="4-减法器"><a href="#4-减法器" class="headerlink" title="4.减法器"></a>4.减法器</h2><p><img src="http://uphotos.eepw.com.cn/jackwang/pics/328abf957180223f595872ad166f0973.jpg" alt="img"><br>图五由虚断知，通过R1的电流等于通过R2的电流，同理通过R4的电流等于R3的电流，故有</p>
<script type="math/tex; mode=display">(V_2 – V_+)/R1 = V_+/R2</script><script type="math/tex; mode=display">(V_1 – V_-)/R4 = (V_- - V_{out})/R3</script><p>如果$R1=R2$， 则</p>
<script type="math/tex; mode=display">V_+ = V_2/2</script><p>如果$R3=R4$， 则</p>
<script type="math/tex; mode=display">V_- = (V_{out} + V_1)/2</script><p>由虚短知 <script type="math/tex">V_+ = V_-</script><br>所以</p>
<script type="math/tex; mode=display">V_{out}=V_2-V_1</script><p>这就是传说中的减法器了。</p>
<h2 id="5-积分电路"><a href="#5-积分电路" class="headerlink" title="5.积分电路"></a>5.积分电路</h2><p><img src="http://uphotos.eepw.com.cn/jackwang/pics/1ecbce047b1868098b7b25aa82324113.jpg" alt="img"><br>图六电路中<br>由虚短知，反向输入端的电压与同向端相等<br>由虚断知，通过R1的电流与通过C1的电流相等。<br>通过R1的电流</p>
<script type="math/tex; mode=display">i= \frac{V_1}{R_1}</script><p>通过C1的电流</p>
<script type="math/tex; mode=display">i=C\cdot \frac{dU_c}{dt}=-C1\cdot \frac{dV_{out}}{dt}</script><p>所以</p>
<script type="math/tex; mode=display">Vout=\frac{-1}{R1*C1}\cdot \int V_1dt</script><p>输出电压与输入电压对时间的积分成正比,这就是传说中的积分电路了。<br>若V1为恒定电压U，则上式变换为</p>
<script type="math/tex; mode=display">Vout = -\frac{U*t}{R1*C1}</script><p>t 是时间，则Vout输出电压是一条从0至负电源电压按时间变化的直线。 </p>
<h2 id="6-微分电路"><a href="#6-微分电路" class="headerlink" title="6.微分电路"></a>6.微分电路</h2><p><img src="http://uphotos.eepw.com.cn/jackwang/pics/57422ac64debc71a6ef231f3643096d8.jpg" alt="img"><br>图七中<br>由虚断知，通过电容C1和电阻R2的电流是相等的<br>由虚短知，运放同向端与反向端电压是相等的。则：</p>
<script type="math/tex; mode=display">V_{out} = -i \cdot R2 = -(R2*C1)\frac{dV_1}{dt}</script><p>这是一个微分电路。<br>如果V1是一个突然加入的直流电压，则输出Vout对应一个方向与V1相反的脉冲。</p>
<h2 id="7-差分放大电路"><a href="#7-差分放大电路" class="headerlink" title="7.差分放大电路"></a>7.差分放大电路</h2><p><img src="http://uphotos.eepw.com.cn/jackwang/pics/71f69b4788c78b18c48dbdf9b34f9fdd.jpg" alt="img"><br>图八.由虚短知 </p>
<script type="math/tex; mode=display">Vx = V1 \cdot\cdot\cdot\cdot\cdot\cdot(1)</script><script type="math/tex; mode=display">Vy = V2 \cdot\cdot\cdot\cdot\cdot\cdot(2)</script><p>由虚断知，运放输入端没有电流流过，则R1、R2、R3可视为串联，通过每一个电阻的电流是相同的， 则电流</p>
<script type="math/tex; mode=display">I=\frac{V_x-V_y}{R2} \cdot\cdot\cdot\cdot\cdot\cdot(3)</script><p>则：</p>
<script type="math/tex; mode=display">V_{o1}-V_{o2}=I\cdot (R1+R2+R3) =\frac{(V_x-V_y)(R1+R2+R3)}{R2} \cdot\cdot\cdot\cdot\cdot\cdot(4)</script><p>由虚断知，流过R6与流过R7的电流相等,若$R6=R7$， 则</p>
<script type="math/tex; mode=display">V_w = \frac{V_{o2}}2 \cdot\cdot\cdot\cdot\cdot\cdot(5)</script><p>同理若$R4=R5$，则</p>
<script type="math/tex; mode=display">V_{out} – V_u = V_u – V_{o1} \cdot\cdot\cdot\cdot\cdot\cdot(6)</script><p>故</p>
<script type="math/tex; mode=display">V_u = \frac{V_{out}+V_{o1}}2 \cdot\cdot\cdot\cdot\cdot\cdot(7)</script><p>由虚短知，</p>
<script type="math/tex; mode=display">V_u = V_w \cdot\cdot\cdot\cdot\cdot\cdot(8)</script><p>由(5)(7)(8)得</p>
<script type="math/tex; mode=display">V_{out} = V_{o2} – V_{o1}\cdot\cdot\cdot\cdot\cdot\cdot(9)</script><p>由(4)(9)得 </p>
<script type="math/tex; mode=display">V_{out} = \frac{(V_y –V_x)(R1+R2+R3)}{R2}</script><p>上式中 $\frac{R1+R2+R3}{R2}$是定值，此值确定了差值$(V_y –V_x)$的放大倍数。</p>
<p>这个电路就是传说中的差分放大电路了。</p>
<h2 id="8-电流采集电路"><a href="#8-电流采集电路" class="headerlink" title="8.电流采集电路"></a>8.电流采集电路</h2><p><img src="http://uphotos.eepw.com.cn/jackwang/pics/22579387c644bd80ccbc24ac4127edad.jpg" alt="img"><br>分析一个大家接触得较多的电路。很多控制器接受来自各种检测仪表的0~20mA或4~20mA电流，电路将此电流转换成电压后再送ADC转换成数字信号，图九就是这样一个典型电路。如图4~20mA电流流过采样100Ω电阻R1，在R1上会产生0.4~2V的电压差。<br>由虚断知，运放输入端没有电流流过，则流过R3和R5的电流相等，流过R2和R4的电流相等。故： </p>
<script type="math/tex; mode=display">\frac{V_2-V_y}{R3} =\frac{V_y}{R5} \cdot\cdot\cdot\cdot\cdot\cdot(1)</script><script type="math/tex; mode=display">\frac{V_1-V_x}{R2} =\frac{V_x-V_{out}}{R4} \cdot\cdot\cdot\cdot\cdot\cdot(2)</script><p>由虚短知：</p>
<script type="math/tex; mode=display">V_x = V_y \cdot\cdot\cdot\cdot\cdot\cdot(3)</script><p>电流从0~20mA变化，则</p>
<script type="math/tex; mode=display">V_1 = V_2 + \Delta I\cdot R1 \cdot\cdot\cdot\cdot\cdot\cdot(4)</script><p>由(3)(4)式代入(2)式得</p>
<script type="math/tex; mode=display">\frac{V_2 + \Delta I\cdot R1-V_y}{R2} = \frac{V_y-V_{out}}{R4} \cdot\cdot\cdot\cdot\cdot\cdot(5)</script><p>如果R3=R2，R4=R5，则由(5)-(1)得</p>
<script type="math/tex; mode=display">V_{out} = -\frac{\Delta I\cdot  R1\cdot R4}{R2}</script><p>图九中R4/R2=22k/10k=2.2，则f式Vout = -(0.88~4.4)V<br>即是说，将4~20mA电流转换成了-0.88 ~ -4.4V电压，此电压可以送ADC去处理。</p>
<h2 id="9-恒流源电路"><a href="#9-恒流源电路" class="headerlink" title="9.恒流源电路"></a>9.恒流源电路</h2><p><img src="http://uphotos.eepw.com.cn/jackwang/pics/0d28d87b2927fcff4fe820c34d4c7b90.jpg" alt="img"><br>电流可以转换成电压，电压也可以转换成电流。图十就是这样一个电路。上图的负反馈没有通过电阻直接反馈，而是串联了三极管Q1的发射结，大家可不要以为是一个比较器就是了。只要是放大电路，虚短虚断的规律仍然是符合的！<br>由虚断知，运放输入端没有电流流过，<br>则             </p>
<script type="math/tex; mode=display">\frac{V_i – V_1}{R2} = \frac{V_1 – V_4}{R6}  \cdot\cdot\cdot\cdot\cdot\cdot(1)</script><p>同理           </p>
<script type="math/tex; mode=display">\frac{V_3 – V_2}{R5} =  \frac{V_2}{R4}    \cdot\cdot\cdot\cdot\cdot\cdot(2)</script><p>由虚短知   $ V1 = V2  \cdot\cdot\cdot\cdot\cdot\cdot(3)  $<br>如果  $ R2=R6，R4=R5 $，则由(1)(2)(3)式得</p>
<script type="math/tex; mode=display">V_3-V_4=V_i</script><p>上式说明R7两端的电压和输入电压Vi相等，则通过R7的电流</p>
<script type="math/tex; mode=display">I=V_i/R7</script><p>如果负载<strong>RL&lt;&lt;100KΩ</strong>，则通过Rl和通过R7的电流基本相同。</p>
<h2 id="10-三线制PT100前置放大电路"><a href="#10-三线制PT100前置放大电路" class="headerlink" title="10.三线制PT100前置放大电路"></a>10.三线制PT100前置放大电路</h2><p><img src="http://uphotos.eepw.com.cn/jackwang/pics/36e6042c7ef601d35393aee859d5399c.jpg" alt="img"><br>图十一是一个三线制PT100前置放大电路。<br>PT100传感器引出三根材质、线径、长度完全相同的线，接法如图所示。有2V的电压加在由R14、R20、R15、Z1、PT100及其线电阻组成的桥电路上。Z1、Z2、Z3、D11、D12、D83及各电容在电路中起滤波和保护作用，静态分析时可不予理会，Z1、Z2、Z3可视为短路，D11、D12、D83及各电容可视为开路。<br>由电阻分压知， V3=2<em>R20/(R14+20)=200/1100=2/11 ……a<br>由虚短知，U8B第6、7脚 电压和第5脚电压相等 V4=V3 ……b<br>由虚断知，U8A第2脚没有电流流过，则流过R18和R19上的电流相等。<br>(V2-V4)/R19=(V5-V2)/R18 ……c<br>由虚断知，U8A第3脚没有电流流过， V1=V7 ……d<br>在桥电路中R15和Z1、PT100及线电阻串联，PT100与线电阻串联分得的电压通过电阻R17加至U8A的第3脚， V7=2</em>(Rx+2R0)/(R15+Rx+2R0) …..e<br>由虚短知，U8A第3脚和第2脚电压相等， V1=V2 ……f<br>由abcdef得， (V5-V7)/100=(V7-V3)/2.2 化简得 V5=(102.2<em>V7-100V3)/2.2 即 V5=204.4(Rx+2R0)/(1000+Rx+2R0) – 200/11 ……g<br>上式输出电压V5是Rx的函数我们再看线电阻的影响。Pt100最下端线电阻上产生的电压降经过中间的线电阻、Z2、R22，加至U8C的第10脚，<br>由虚断知， V5=V8=V9=2</em>R0/(R15+Rx+2R0) ……a<br>(V6-V10)/R25=V10/R26 ……b<br>由虚短知， V10=V5 ……c<br>由式abc得 V6=(102.2/2.2)V5=204.4R0/[2.2(1000+Rx+2R0)] ……h<br>由式gh组成的方程组知，如果测出V5、V6的值，就可算出Rx及R0，知道Rx，查pt100分度表就知道温度的大小了。</p>
]]></content>
      <categories>
        <category>电路设计相关</category>
        <category>经典电路</category>
      </categories>
      <tags>
        <tag>电路设计</tag>
        <tag>运放</tag>
      </tags>
  </entry>
  <entry>
    <title>[通信]R232转RS485的通讯电路</title>
    <url>/2018/01/17/%E9%80%9A%E4%BF%A1-R232%E8%BD%ACRS485%E7%9A%84%E9%80%9A%E8%AE%AF%E7%94%B5%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="RS232简介："><a href="#RS232简介：" class="headerlink" title="RS232简介："></a>RS232简介：</h1><p>RS-232-C是美国电子工业协会EIA（Electronic Industry Association）制定的一种串行物理接口标准。RS是英文“推荐标准”的缩写，232为标识号，C表示修改次数。RS-232-C总线标准设有25条信号线，包括一个主通道和一个辅助通道。</p>
<p>在多数情况下主要使用主通道，对于一般双工通信，仅需几条信号线就可实现，如一条发送线、一条接收线及一条地线。</p>
<p>RS-232-C标准规定的数据传输速率为50、75、100、150、300、600、1200、2400、4800、9600、19200、38400波特。</p>
<p>RS-232-C标准规定，驱动器允许有2500pF的电容负载，通信距离将受此电容限制，例如，采用150pF/m的通信电缆时，最大通信距离为15m；若每米电缆的电容量减小，通信距离可以增加。传输距离短的另一原因是RS-232属单端信号传送，存在共地噪声和不能抑制共模干扰等问题，因此一般用于20m以内的通信。具体通讯距离还与通信速率有关，例如，在9600pbs时，普通双绞屏蔽线时，距离可达30-35米。</p>
<p>串行通信接口标准经过使用和发展，目前已经有几种。但都是在RS-232标准的基础上经过改进而形成的。所以，以RS-232C为主来讨论。RS-232C标准是美国EIA（电子工业联合会）与BELL等公司一起开发的1969年公布的通信协议。它适合于数据传输速率在0～20000b/s范围内的通信。这个标准对串行通信接口的有关问题，如信号线功能、电气特性都作了明确规定。由于通信设备厂商都生产与RS-232C制式兼容的通信设备，因此，它作为一种标准，目前已在微机通信接口中广泛采用。</p>
<p>首先，RS-232-C标准最初是远程通信连接数据终端设备DTE(Data Terminal Equipment）与数据通信设备DCE（Data Communicate Equipment）而制定的。因此这个标准的制定，并未考虑计算机系统的应用要求。但目前它又广泛地被借来用于计算机（更准确的说，是计算机接口与终端或外设之间的近端连接标准)。显然，这个标准的有些规定和计算机系统是不一致的。有了对这种背景的了解，我们对RS-232C标准与计算机不兼容的地方就不难理解了。<br>其次，RS-232C标准中所提到的“发送”和“接收”，都是站在DTE立场上，而不是站在DCE的立场来定义的。由于在计算机系统中，往往是CPU和I/O设备之间传送信息，两者都是DTE，因此双方都能发送和接收。</p>
<h2 id="电气特性"><a href="#电气特性" class="headerlink" title="电气特性"></a>电气特性</h2><p>EIA-RS-232C对电气特性、逻辑电平和各种信号线功能都作了规定。</p>
<p>在TxD和RxD上：</p>
<p>$\color{red}{逻辑1(MARK)=-3V～-15V}$</p>
<p>$\color{green}{逻辑0(SPACE)=+3～+15V}$</p>
<p>在RTS、CTS、DSR、DTR和DCD等控制线上：<br>信号有效（接通，ON状态，正电压）=+3V～+15V<br>信号无效（断开，OFF状态，负电压）=-3V～-15V</p>
<p>以上规定说明了RS-232C标准对逻辑电平的定义。对于数据（信息码）：逻辑“1”（传号）的电平低于-3V，逻辑“0”（空号）的电平高于+3V；对于控制信号；接通状态（ON）即信号有效的电平高于+3V，断开状态（OFF）即信号无效的电平低于-3V，也就是当传输电平的绝对值大于3V时，电路可以有效地检查出来，介于-3～+3V之间的电压无意义，低于-15V或高于+15V的电压也认为无意义，因此，实际工作时，应保证电平在-3V～-15V或+3V～+15V之间。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>连接器：由于RS-232C并未定义连接器的物理特性，因此，出现了DB-25、DB-15和DB-9各种类型的连接器，其引脚的定义也各不相同。下面分别介绍两种连接器。<br>（1）DB-25：PC和XT机采用DB-25型连接器。DB-25连接器定义了25根信号线，分为4组：<br>①异步通信的9个电压信号（含信号地SG）2，3，4，5，6，7，8，20，22<br>②20mA电流环信号 9个（12，13，14，15，16，17，19,23，24）<br>③空6个（9，10，11，18，21，25）<br>④保护地（PE）1个，作为设备接地端（1脚）<br>注意，20mA电流环信号仅IBM PC和IBM PC/XT机提供，至AT机及以后，已不支持。<br>（2）DB-9：<br>在AT机及以后，不支持20mA电流环接口，使用DB-9连接器，作为提供多功能I/O卡或主板上COM1和COM2两个串行接口的连接器。它只提供异步通信的9个信号。DB-9型连接器的引脚分配与DB-25型引脚信号完全不同。因此，若与配接DB-25型连接器的DCE设备连接，必须使用专门的电缆线。<br>电缆长度：在通信速率低于20kb/s时，RS-232C 所直接连接的最大物理距离为15m（50英尺）。<br>最大直接传输距离说明：RS-232C标准规定，若不使用MODEM，在码元畸变小于4%的情况下，DTE和DCE之间最大传输距离为15m（50英尺）。可见这个最大的距离是在码元畸变小于4%的前提下给出的。为了保证码元畸变小于4%的要求，接口标准在电气特性中规定，驱动器的负载电容应小于2500pF。</p>
<h2 id="接口信号"><a href="#接口信号" class="headerlink" title="接口信号"></a>接口信号</h2><p>RS-232C 的功能特性定义了25芯标准连接器中的20根信号线，其中2条地线、4条数据线、11条控制线、3条定时信号线，剩下的5根线作备用或未定义。常用的只有10根，它们是：</p>
<p>（1）联络控制信号线：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据发送准备好（Data set ready-DSR）——有效时（ON）状态，表明MODEM处于可以使用的状态。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据终端准备好（Data terminal ready-DTR）——有效时（ON）状态，表明数据终端可以使用。</span><br></pre></td></tr></table></figure>
<p>这两个信号有时连到电源上，一上电就立即有效。这两个设备状态信号有效，只表示设备本身可用，并不说明通信链路可以开始进行通信了，能否开始进行通信要由下面的控制信号决定。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请求发送（Request to send-RTS）——用来表示DTE请求DCE发送数据，即当终端准备要接收MODEM传来的数据时，使该信号有效（ON状态），请求MODEM发送数据。它用来控制MODEM是否要进入发送状态。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">允许发送（Clear to send-CTS）——用来表示DCE准备好接收DTE发来的数据，是与请求发送信号RTS相应的信号。当MODEM准备好接收终端传来的数据，并向前发送时，使该信号有效，通知终端开始沿发送数据线TxD发送数据。</span><br></pre></td></tr></table></figure>
<p>这对RTS/CTS请求应答联络信号是用于半双工MODEM系统中发送方式和接收方式之间的切换。在全双工系统中，因配置双向通道，故不需要RTS/CTS联络信号，使其变高。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">接收线信号检出（Received Line detection-RLSD）——用来表示DCE已接通通信链路，告知DTE准备接收数据。当本地的MODEM收到由通信链路另一端（远地）的MODEM送来的载波信号时，使RLSD信号有效，通知终端准备接收，并且由MODEM将接收下来的载波信号解调成数字量数据后，沿接收数据线RxD送到终端。此线也叫做数据载波检出（Data Carrier dectection-DCD）线。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">振铃指示（Ringing-RI）——当MODEM收到交换台送来的振铃呼叫信号时，使该信号有效（ON状态），通知终端，已被呼叫。</span><br></pre></td></tr></table></figure>
<p>（2）数据发送与接收线：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">发送数据（Transmitted data-TxD）——通过TxD终端将串行数据发送到MODEM，（DTE→DCE）。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">接收数据（Received data-RxD）——通过RxD线终端接收从MODEM发来的串行数据，（DCE→DTE）。</span><br></pre></td></tr></table></figure>
<p>（3）地线 ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GND、Sig.GND——保护地和信号地，无方向。</span><br></pre></td></tr></table></figure>
<p>上述控制信号线何时有效，何时无效的顺序表示了接口信号的传送过程。例如，只有当DSR和DTR都处于有效（ON）状态时，才能在DTE和DCE之间进行传送操作。若DTE要发送数据，则预先将DTR线置成有效（ON）状态，等CTS线上收到有效（ON）状态的回答后，才能在TxD线上发送串行数据。这种顺序的规定对半双工的通信线路特别有用，因为半双工的通信才能确定DCE已由接收方向改为发送方向，这时线路才能开始发送。</p>
<h2 id="接线"><a href="#接线" class="headerlink" title="接线"></a>接线</h2><p>在工程当中经常会用到232口，一般是圆头8针与D型9针两种串口。在一定的条件下，必须要自己制作一个相应的”圆头或者是D型的”232串口。<br>RS232C串口通信接线方法（三线制）<br>首先，串口传输数据只要有接收数据针脚和发送针脚就能实现：同一个串口的接收脚和发送脚直接用线相连，两个串口相连或一个串口和多个串口相连</p>
<h4 id="同一个串口"><a href="#同一个串口" class="headerlink" title="同一个串口"></a>同一个串口</h4><p>接收脚和发送脚直接用线相连对9针串口和25针串口，均是2与3直接相连；</p>
<h4 id="两个不同串口（不论是同一台计算机的两个串口或分别是不同计算机的串口）"><a href="#两个不同串口（不论是同一台计算机的两个串口或分别是不同计算机的串口）" class="headerlink" title="两个不同串口（不论是同一台计算机的两个串口或分别是不同计算机的串口）"></a>两个不同串口（不论是同一台计算机的两个串口或分别是不同计算机的串口）</h4><p>DB9-DB9<br>2-3,3-2,5-5</p>
<p>DB25-DB25<br>2-3,3-2,7-7</p>
<p>DB9-DB25<br>2-3,3-2,5-7</p>
<p>上面是对微机标准串行口而言的，还有许多非标准设备，如接收GPS数据或电子罗盘数据，只要记住一个原则：接收数据针脚（或线）与发送数据针脚（或线）相连，彼此交叉，信号地对应相接。</p>
<h4 id="8针圆形串口接线："><a href="#8针圆形串口接线：" class="headerlink" title="8针圆形串口接线："></a>8针圆形串口接线：</h4><p>2”逻辑地”，4”TXD”,7”RXD”。</p>
<h4 id="9针D型串口："><a href="#9针D型串口：" class="headerlink" title="9针D型串口："></a>9针D型串口：</h4><p>2”RXD”，3”TXD”，5”逻辑地”。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">针脚</th>
<th style="text-align:left">信号</th>
<th style="text-align:left">定义</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">DCD</td>
<td style="text-align:left">载波检测</td>
<td style="text-align:left">eceived Line Signal Detector(Data Carrier Detect)</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">RXD</td>
<td style="text-align:left">接收数据</td>
<td style="text-align:left">Received Data</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">TXD</td>
<td style="text-align:left">发送数据</td>
<td style="text-align:left">Transmit Data</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">DTR</td>
<td style="text-align:left">数据终端准备好</td>
<td style="text-align:left">Data Terminal Ready</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">SGND</td>
<td style="text-align:left">信号地</td>
<td style="text-align:left">Signal Ground</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">DSR</td>
<td style="text-align:left">数据准备好</td>
<td style="text-align:left">Data Set Ready</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">RTS</td>
<td style="text-align:left">请求发送</td>
<td style="text-align:left">Request To Send</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">CTS</td>
<td style="text-align:left">清除发送</td>
<td style="text-align:left">Clear To Send</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left">RI</td>
<td style="text-align:left">振铃提示</td>
<td style="text-align:left">Ring Indicator</td>
</tr>
</tbody>
</table>
</div>
<h2 id="使用RS232接口时注意"><a href="#使用RS232接口时注意" class="headerlink" title="使用RS232接口时注意"></a>使用RS232接口时注意</h2><p>RS-232-C的电气接口电路采取的是不平衡传输方式，即所谓单端通讯，其发送电平与接收电平的差只有2～3V，所以共模抑制能力较差，容易受到共地噪声和外部干扰的影响，再加上信号线之间的分布电容，因此其传送距离最大为约15米，最高数据传输速率为20kb/s。此外RS-232-C的接口电路的信号电平较高，容易损坏接口电路的芯片，与TTL电路的电平也不兼容，影响其通用性。为了弥补RS-232-C的不足，提高数据传输率和延长通信距离，EIA于1977年制订了RS－499串行通信标准，这个标准对RS-232-C的不足做了改进和补充。</p>
<p>RS-422A是RS-499的标准子集之一。</p>
<h1 id="RS485简介："><a href="#RS485简介：" class="headerlink" title="RS485简介："></a>RS485简介：</h1><h2 id="RS485的特点："><a href="#RS485的特点：" class="headerlink" title="RS485的特点："></a>RS485的特点：</h2><ol>
<li>RS-485的电气特性：采用差分信号正逻辑，逻辑”1”以两线间的电压差为+(2~6)V表示；逻辑”0”以两线间的电压差为-(2~6)V表示。接口信号电平比RS-232-C降低了，就不易损坏接口电路的芯片， 且该电平与TTL电平兼容，可方便与TTL电路连接。</li>
<li>RS-485的数据最高传输速率为10Mbps。</li>
<li>RS-485接口是采用平衡驱动器和差分接收器的组合，抗共模干扰能力增强，即抗噪声干扰性好。</li>
<li>RS-485最大的通信距离约为1219m，最大传输速率为10Mbps，传输速率与传输距离成反比，传输速率越低，传输距离越长，如果需传输比RS-485最大通信距离更长的距离，需要加485中继器。RS-485总线一般最大支持32个节点，如果使用特制的485芯片，可以达到128个或者256个节点，最大的可以支持到400个节点。<br>因为RS485接口组成的半双工网络，一般只需二根连线（一般叫AB线），所以RS485接口均采用屏蔽双绞线传输。<h2 id="接口-1"><a href="#接口-1" class="headerlink" title="接口"></a>接口</h2>RS485接口组成的半双工网络，一般是两线制（以前有四线制接法，只能实现点对点的通信方式，现很少采用），多采用屏蔽双绞线传输。这种接线方式为总线式拓扑结构在同一总线上最多可以挂接32个结点。在RS485通信网络中一般采用的是主从通信方式，即一个主机带多个从机。很多情况下，连接RS-485通信链路时只是简单地用一对双绞线将各个接口的“A”、“B”端连接起来。RS485接口连接器采用DB-9的9芯插头座，与智能终端RS485接口采用DB-9（孔），与键盘连接的键盘接口RS485采用DB-9（针）。<h2 id="使用RS485接口时注意"><a href="#使用RS485接口时注意" class="headerlink" title="使用RS485接口时注意"></a>使用RS485接口时注意</h2><a href="使用RS485接口时应注意的问题.docx">使用RS485接口时应注意的问题</a><h1 id="参考电路："><a href="#参考电路：" class="headerlink" title="参考电路："></a>参考电路：</h1><img src="fig1.jpg" alt="fig1.jpg"><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3>RS232-485转换器主要包括了电源、232电平转换、485电路三部分。本电路的232电平转换电路采用了NIH232或者也可以直接使用MAX232集成电路，485电路采用了MAX485集成电路。为了使用方便，电源部分设计成无源方式，整个电路的供电直接从PC机的RS232接口中的DTR（4脚）和RTS（7脚）窃取。PC串口每根线可以提供大约9mA的电流，因此两根线提供的电流足够供给这个电路使用了。经实验，本电路只使用其中一条线也能够正常工作。使用本电路需注意PC程序必须使串口的DTR和RTS输出高电平，经过D3稳压后得到VCC，经过实际测试，VCC电压大约在4.7V左右。因此，电路中要说D3起的作用是稳压还不如说是限压功能。</li>
</ol>
<p>　　MAX485是通过两个引脚RE（2脚）和DE（3脚）来控制数据的输入和输出。当RE为低电平时，MAX485数据输入有效；当DE为高电平时，MAX485数据输出有效。在半双工使用中，通常可以将这两个脚直接相连，然后由PC或者单片机输出的高低电平就可以让MAX485在接收和发送状态之间转换了。由于本电路DTR和RTS都用于了电路供电，因此使用TX线和HIN232的另外一个通道及Q1来控制MAX485的状态切换。平时NIH232的9脚输出高电平，经Q1倒相后，使MAX485的RE和DE为低电平而处于数据接收状态。当PC机发送数据时，NIH232的9脚输出低电平，经Q1倒相后，使MAX485的RE和DE为高电平而处于数据发送状态。</p>
]]></content>
      <categories>
        <category>电路设计相关</category>
        <category>通信方式</category>
      </categories>
      <tags>
        <tag>电路设计</tag>
        <tag>RS232 RS485</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法说明链接</title>
    <url>/2018/01/06/Markdown%E8%AF%AD%E6%B3%95%E8%AF%B4%E6%98%8E%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<p><a href="https://www.appinn.com/markdown/#p" target="_blank" rel="noopener">Markdown 语法说明 (简体中文版)</a></p>
<p><strong>声明：</strong> 这份文档派生(fork)于<a href="http://markdown.tw/" target="_blank" rel="noopener">繁体中文版</a>，在此基础上进行了繁体转简体工作，并进行了适当的润色。此文档用 Markdown 语法编写，你可以到这里<a href="http://gitcafe.com/riku/Markdown-Syntax-CN/blob/master/syntax.md" target="_blank" rel="noopener">查看它的源文件</a>。「繁体中文版的原始文件可以<a href="https://github.com/othree/markdown-syntax-zhtw/blob/master/syntax.md" target="_blank" rel="noopener">查看这里</a> 。」—By @<a href="http://twitter.com/riku" target="_blank" rel="noopener">riku</a></p>
<p><strong>注：</strong> 本项目托管于 <a href="http://gitcafe.com/riku/Markdown-Syntax-CN/" target="_blank" rel="noopener">GitCafe</a>上，请通过”派生”和”合并请求”来帮忙改进本项目。</p>
<h1 id="Markdown-语法说明-简体中文版-点击查看快速入门"><a href="#Markdown-语法说明-简体中文版-点击查看快速入门" class="headerlink" title="Markdown 语法说明 (简体中文版) / (点击查看快速入门)"></a>Markdown 语法说明 (简体中文版) / (<a href="./basic.html">点击查看快速入门</a>)</h1><ul>
<li><a href="#overview">概述</a><ul>
<li><a href="#philosophy">宗旨</a></li>
<li><a href="#html">兼容 HTML</a></li>
<li><a href="#autoescape">特殊字符自动转换</a></li>
</ul>
</li>
<li><a href="#block">区块元素</a><ul>
<li><a href="#p">段落和换行</a></li>
<li><a href="#header">标题</a></li>
<li><a href="#blockquote">区块引用</a></li>
<li><a href="#list">列表</a></li>
<li><a href="#precode">代码区块</a></li>
<li><a href="#hr">分隔线</a></li>
</ul>
</li>
<li><a href="#span">区段元素</a><ul>
<li><a href="#link">链接</a></li>
<li><a href="#em">强调</a></li>
<li><a href="#code">代码</a></li>
<li><a href="#img">图片</a></li>
</ul>
</li>
<li><a href="#misc">其它</a><ul>
<li><a href="#backslash">反斜杠</a></li>
<li><a href="#autolink">自动链接</a></li>
</ul>
</li>
<li><a href="#acknowledgement">感谢</a><br>*<a href="#editor">Markdown 免费编辑器</a></li>
</ul>
<hr>
<h2 id="overview">概述</h2>

<h3 id="philosophy">宗旨</h3>

<p>Markdown 的目标是实现「易读易写」。</p>
<p>可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 <a href="http://docutils.sourceforge.net/mirror/setext.html" target="_blank" rel="noopener">Setext</a>、<a href="http://www.aaronsw.com/2002/atx/" target="_blank" rel="noopener">atx</a>、<a href="http://textism.com/tools/textile/" target="_blank" rel="noopener">Textile</a>、<a href="http://docutils.sourceforge.net/rst.html" target="_blank" rel="noopener">reStructuredText</a>、<a href="http://www.triptico.com/software/grutatxt.html" target="_blank" rel="noopener">Grutatext</a> 和 <a href="http://ettext.taint.org/doc/" target="_blank" rel="noopener">EtText</a>，而最大灵感来源其实是纯文本电子邮件的格式。</p>
<p>总之， Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像*强调*。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。</p>
<h3 id="html">兼容 HTML</h3>

<p>Markdown 语法的目标是：成为一种适用于网络的<em>书写</em>语言。</p>
<p>Markdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想<em>不是</em>要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种<em>发布</em>的格式，Markdown 是一种<em>书写</em>的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。</p>
<p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。</p>
<p>要制约的只有一些 HTML 区块元素――比如 <code>&lt;div&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;pre&gt;</code>、<code>&lt;p&gt;</code> 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 <code>&lt;p&gt;</code> 标签。</p>
<p>例子如下，在 Markdown 文件里加上一段 HTML 表格：</p>
<pre><code>这是一个普通段落。

&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;Foo&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

这是另一个普通段落。
</code></pre><p>请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的<code>*强调*</code>会没有效果。</p>
<p>HTML 的区段（行内）标签如 <code>&lt;span&gt;</code>、<code>&lt;cite&gt;</code>、<code>&lt;del&gt;</code> 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 <code>&lt;a&gt;</code> 或 <code>&lt;img&gt;</code> 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。</p>
<p>和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。</p>
<h3 id="autoescape">特殊字符自动转换</h3>

<p>在 HTML 文件中，有两个字符需要特殊处理： <code>&lt;</code> 和 <code>&amp;</code> 。 <code>&lt;</code> 符号用于起始标签，<code>&amp;</code> 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 <code>&amp;lt;</code> 和 <code>&amp;amp;</code>。</p>
<p><code>&amp;</code> 字符尤其让网络文档编写者受折磨，如果你要打「<code>AT&amp;T</code>」 ，你必须要写成「<code>AT&amp;amp;T</code>」。而网址中的 <code>&amp;</code> 字符也要转换。比如你要链接到：</p>
<pre><code>http://images.google.com/images?num=30&amp;q=larry+bird
</code></pre><p>你必须要把网址转换写为：</p>
<pre><code>http://images.google.com/images?num=30&amp;amp;q=larry+bird
</code></pre><p>才能放到链接标签的 <code>href</code> 属性里。不用说也知道这很容易忽略，这也可能是 HTML 标准检验所检查到的错误中，数量最多的。</p>
<p>Markdown 让你可以自然地书写字符，需要转换的由它来处理好了。如果你使用的 <code>&amp;</code> 字符是 HTML 字符实体的一部分，它会保留原状，否则它会被转换成 <code>&amp;amp</code>;。</p>
<p>所以你如果要在文档中插入一个版权符号 <code>©</code>，你可以这样写：</p>
<pre><code>&amp;copy;
</code></pre><p>Markdown 会保留它不动。而若你写：</p>
<pre><code>AT&amp;T
</code></pre><p>Markdown 就会将它转为：</p>
<pre><code>AT&amp;amp;T
</code></pre><p>类似的状况也会发生在 <code>&lt;</code> 符号上，因为 Markdown 允许 <a href="#html">兼容 HTML</a> ，如果你是把 <code>&lt;</code> 符号作为 HTML 标签的定界符使用，那 Markdown 也不会对它做任何转换，但是如果你写：</p>
<pre><code>4 &lt; 5
</code></pre><p>Markdown 将会把它转换为：</p>
<pre><code>4 &amp;lt; 5
</code></pre><p>不过需要注意的是，code 范围内，不论是行内还是区块， <code>&lt;</code> 和 <code>&amp;</code> 两个符号都<em>一定</em>会被转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML code （和 HTML 相对而言， HTML 语法中，你要把所有的 <code>&lt;</code> 和 <code>&amp;</code> 都转换为 HTML 实体，才能在 HTML 文件里面写出 HTML code。）</p>
<hr>
<h2 id="block">区块元素</h2>


<h3 id="p">段落和换行</h3>

<p>一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。</p>
<p>「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 <code>&lt;br /&gt;</code> 标签。</p>
<p>如果你<em>确实</em>想要依赖 Markdown 来插入 <code>&lt;br /&gt;</code> 标签的话，在插入处先按入两个以上的空格然后回车。</p>
<p>的确，需要多费点事（多加空格）来产生 <code>&lt;br /&gt;</code> ，但是简单地「每个换行都转换为 <code>&lt;br /&gt;</code>」的方法在 Markdown 中并不适合， Markdown 中 email 式的 <a href="#blockquote">区块引用</a> 和多段落的 <a href="#list">列表</a> 在使用换行来排版的时候，不但更好用，还更方便阅读。</p>
<h3 id="header">标题</h3>

<p>Markdown 支持两种标题的语法，类 <a href="http://docutils.sourceforge.net/mirror/setext.html" target="_blank" rel="noopener">Setext</a> 和类 <a href="http://www.aaronsw.com/2002/atx/" target="_blank" rel="noopener">atx</a> 形式。</p>
<p>类 Setext 形式是用底线的形式，利用 <code>=</code> （最高阶标题）和 <code>-</code> （第二阶标题），例如：</p>
<pre><code>This is an H1
=============

This is an H2
-------------
</code></pre><p>任何数量的 <code>=</code> 和 <code>-</code> 都可以有效果。</p>
<p>类 Atx 形式则是在行首插入 1 到 6 个 <code>#</code> ，对应到标题 1 到 6 阶，例如：</p>
<pre><code># 这是 H1

## 这是 H2

###### 这是 H6
</code></pre><p>你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 <code>#</code>，而行尾的 <code>#</code> 数量也不用和开头一样（行首的井字符数量决定标题的阶数）：</p>
<pre><code># 这是 H1 #

## 这是 H2 ##

### 这是 H3 ######
</code></pre><h3 id="blockquote">区块引用 Blockquotes</h3>

<p>Markdown 标记区块引用是使用类似 email 中用 <code>&gt;</code> 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 <code>&gt;</code> ：</p>
<pre><code>&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.
&gt; 
&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
&gt; id sem consectetuer libero luctus adipiscing.
</code></pre><p>Markdown 也允许你偷懒只在整个段落的第一行最前面加上 <code>&gt;</code> ：</p>
<pre><code>&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.

&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.
</code></pre><p>区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 <code>&gt;</code> ：</p>
<pre><code>&gt; This is the first level of quoting.
&gt;
&gt; &gt; This is nested blockquote.
&gt;
&gt; Back to the first level.
</code></pre><p>引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：</p>
<pre><code>&gt; ## 这是一个标题。
&gt; 
&gt; 1.   这是第一行列表项。
&gt; 2.   这是第二行列表项。
&gt; 
&gt; 给出一些例子代码：
&gt; 
&gt;     return shell_exec(&quot;echo $input | $markdown_script&quot;);
</code></pre><p>任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择<em>增加引用阶层</em>。</p>
<h3 id="list">列表</h3>

<p>Markdown 支持有序列表和无序列表。</p>
<p>无序列表使用星号、加号或是减号作为列表标记：</p>
<pre><code>*   Red
*   Green
*   Blue
</code></pre><p>等同于：</p>
<pre><code>+   Red
+   Green
+   Blue
</code></pre><p>也等同于：</p>
<pre><code>-   Red
-   Green
-   Blue
</code></pre><p>有序列表则使用数字接着一个英文句点：</p>
<pre><code>1.  Bird
2.  McHale
3.  Parish
</code></pre><p>很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为：</p>
<pre><code>&lt;ol&gt;
&lt;li&gt;Bird&lt;/li&gt;
&lt;li&gt;McHale&lt;/li&gt;
&lt;li&gt;Parish&lt;/li&gt;
&lt;/ol&gt;
</code></pre><p>如果你的列表标记写成：</p>
<pre><code>1.  Bird
1.  McHale
1.  Parish
</code></pre><p>或甚至是：</p>
<pre><code>3. Bird
1. McHale
8. Parish
</code></pre><p>你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。</p>
<p>如果你使用懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。</p>
<p>列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。</p>
<p>要让列表看起来更漂亮，你可以把内容用固定的缩进整理好：</p>
<pre><code>*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
    Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
    viverra nec, fringilla in, laoreet vitae, risus.
*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
    Suspendisse id sem consectetuer libero luctus adipiscing.
</code></pre><p>但是如果你懒，那也行：</p>
<pre><code>*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
viverra nec, fringilla in, laoreet vitae, risus.
*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
Suspendisse id sem consectetuer libero luctus adipiscing.
</code></pre><p>如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 <code>&lt;p&gt;</code><br>标签包起来，举例来说：</p>
<pre><code>*   Bird
*   Magic
</code></pre><p>会被转换为：</p>
<pre><code>&lt;ul&gt;
&lt;li&gt;Bird&lt;/li&gt;
&lt;li&gt;Magic&lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>但是这个：</p>
<pre><code>*   Bird

*   Magic
</code></pre><p>会被转换为：</p>
<pre><code>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Bird&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Magic&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符：</p>
<pre><code>1.  This is a list item with two paragraphs. Lorem ipsum dolor
    sit amet, consectetuer adipiscing elit. Aliquam hendrerit
    mi posuere lectus.

    Vestibulum enim wisi, viverra nec, fringilla in, laoreet
    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum
    sit amet velit.

2.  Suspendisse id sem consectetuer libero luctus adipiscing.
</code></pre><p>如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许：</p>
<pre><code>*   This is a list item with two paragraphs.

    This is the second paragraph in the list item. You&#39;re
only required to indent the first line. Lorem ipsum dolor
sit amet, consectetuer adipiscing elit.

*   Another item in the same list.
</code></pre><p>如果要在列表项目内放进引用，那 <code>&gt;</code> 就需要缩进：</p>
<pre><code>*   A list item with a blockquote:

    &gt; This is a blockquote
    &gt; inside a list item.
</code></pre><p>如果要放代码区块的话，该区块就需要缩进<em>两次</em>，也就是 8 个空格或是 2 个制表符：</p>
<pre><code>*   一列表项包含一个列表区块：

        &lt;代码写在这&gt;
</code></pre><p>当然，项目列表很可能会不小心产生，像是下面这样的写法：</p>
<pre><code>1986. What a great season.
</code></pre><p>换句话说，也就是在行首出现<em>数字-句点-空白</em>，要避免这样的状况，你可以在句点前面加上反斜杠。</p>
<pre><code>1986\. What a great season.
</code></pre><h3 id="precode">代码区块</h3>

<p>和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 <code>&lt;pre&gt;</code> 和 <code>&lt;code&gt;</code> 标签来把代码区块包起来。</p>
<p>要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入：</p>
<pre><code>这是一个普通段落：

    这是一个代码区块。
</code></pre><p>Markdown 会转换成：</p>
<pre><code>&lt;p&gt;这是一个普通段落：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;这是一个代码区块。
&lt;/code&gt;&lt;/pre&gt;
</code></pre><p>这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如：</p>
<pre><code>Here is an example of AppleScript:

    tell application &quot;Foo&quot;
        beep
    end tell
</code></pre><p>会被转换为：</p>
<pre><code>&lt;p&gt;Here is an example of AppleScript:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tell application &quot;Foo&quot;
    beep
end tell
&lt;/code&gt;&lt;/pre&gt;
</code></pre><p>一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。</p>
<p>在代码区块里面， <code>&amp;</code> 、 <code>&lt;</code> 和 <code>&gt;</code> 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理，例如：</p>
<pre><code>    &lt;div class=&quot;footer&quot;&gt;
        &amp;copy; 2004 Foo Corporation
    &lt;/div&gt;
</code></pre><p>会被转换为：</p>
<pre><code>&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;footer&quot;&amp;gt;
    &amp;amp;copy; 2004 Foo Corporation
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</code></pre><p>代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。</p>
<h3 id="hr">分隔线</h3>

<p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>
<pre><code>* * *

***

*****

- - -

---------------------------------------
</code></pre><hr>
<h2 id="span">区段元素</h2>

<h3 id="link">链接</h3>

<p>Markdown 支持两种形式的链接语法： <em>行内式</em>和<em>参考式</em>两种形式。</p>
<p>不管是哪一种，链接文字都是用 [方括号] 来标记。</p>
<p>要建立一个<em>行内式</em>的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：</p>
<pre><code>This is [an example](http://example.com/ &quot;Title&quot;) inline link.

[This link](http://example.net/) has no title attribute.
</code></pre><p>会产生：</p>
<pre><code>&lt;p&gt;This is &lt;a href=&quot;http://example.com/&quot; title=&quot;Title&quot;&gt;
an example&lt;/a&gt; inline link.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://example.net/&quot;&gt;This link&lt;/a&gt; has no
title attribute.&lt;/p&gt;
</code></pre><p>如果你是要链接到同样主机的资源，你可以使用相对路径：</p>
<pre><code>See my [About](/about/) page for details.   
</code></pre><p><em>参考式</em>的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：</p>
<pre><code>This is [an example][id] reference-style link.
</code></pre><p>你也可以选择性地在两个方括号中间加上一个空格：</p>
<pre><code>This is [an example] [id] reference-style link.
</code></pre><p>接着，在文件的任意处，你可以把这个标记的链接内容定义出来：</p>
<pre><code>[id]: http://example.com/  &quot;Optional Title Here&quot;
</code></pre><p>链接内容定义的形式为：</p>
<ul>
<li>方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字</li>
<li>接着一个冒号</li>
<li>接着一个以上的空格或制表符</li>
<li>接着链接的网址</li>
<li>选择性地接着 title 内容，可以用单引号、双引号或是括弧包着</li>
</ul>
<p>下面这三种链接的定义都是相同：</p>
<pre><code>[foo]: http://example.com/  &quot;Optional Title Here&quot;
[foo]: http://example.com/  &#39;Optional Title Here&#39;
[foo]: http://example.com/  (Optional Title Here)
</code></pre><p><strong>请注意：</strong>有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。</p>
<p>链接网址也可以用尖括号包起来：</p>
<pre><code>[id]: &lt;http://example.com/&gt;  &quot;Optional Title Here&quot;
</code></pre><p>你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看：</p>
<pre><code>[id]: http://example.com/longish/path/to/resource/here
    &quot;Optional Title Here&quot;
</code></pre><p>网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。</p>
<p>链接辨别标签可以有字母、数字、空白和标点符号，但是并<em>不</em>区分大小写，因此下面两个链接是一样的：</p>
<pre><code>[link text][a]
[link text][A]
</code></pre><p><em>隐式链接标记</em>功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 “Google” 链接到 google.com，你可以简化成：</p>
<pre><code>[Google][]
</code></pre><p>然后定义链接内容：</p>
<pre><code>[Google]: http://google.com/
</code></pre><p>由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词：</p>
<pre><code>Visit [Daring Fireball][] for more information.
</code></pre><p>然后接着定义链接：</p>
<pre><code>[Daring Fireball]: http://daringfireball.net/
</code></pre><p>链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。</p>
<p>下面是一个参考式链接的范例：</p>
<pre><code>I get 10 times more traffic from [Google] [1] than from
[Yahoo] [2] or [MSN] [3].

  [1]: http://google.com/        &quot;Google&quot;
  [2]: http://search.yahoo.com/  &quot;Yahoo Search&quot;
  [3]: http://search.msn.com/    &quot;MSN Search&quot;
</code></pre><p>如果改成用链接名称的方式写：</p>
<pre><code>I get 10 times more traffic from [Google][] than from
[Yahoo][] or [MSN][].

  [google]: http://google.com/        &quot;Google&quot;
  [yahoo]:  http://search.yahoo.com/  &quot;Yahoo Search&quot;
  [msn]:    http://search.msn.com/    &quot;MSN Search&quot;
</code></pre><p>上面两种写法都会产生下面的 HTML。</p>
<pre><code>&lt;p&gt;I get 10 times more traffic from &lt;a href=&quot;http://google.com/&quot;
title=&quot;Google&quot;&gt;Google&lt;/a&gt; than from
&lt;a href=&quot;http://search.yahoo.com/&quot; title=&quot;Yahoo Search&quot;&gt;Yahoo&lt;/a&gt;
or &lt;a href=&quot;http://search.msn.com/&quot; title=&quot;MSN Search&quot;&gt;MSN&lt;/a&gt;.&lt;/p&gt;
</code></pre><p>下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用：</p>
<pre><code>I get 10 times more traffic from [Google](http://google.com/ &quot;Google&quot;)
than from [Yahoo](http://search.yahoo.com/ &quot;Yahoo Search&quot;) or
[MSN](http://search.msn.com/ &quot;MSN Search&quot;).
</code></pre><p>参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。</p>
<p>使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。</p>
<h3 id="em">强调</h3>

<p>Markdown 使用星号（<code>*</code>）和底线（<code>_</code>）作为标记强调字词的符号，被 <code>*</code> 或 <code>_</code> 包围的字词会被转成用 <code>&lt;em&gt;</code> 标签包围，用两个 <code>*</code> 或 <code>_</code> 包起来的话，则会被转成 <code>&lt;strong&gt;</code>，例如：</p>
<pre><code>*single asterisks*

_single underscores_

**double asterisks**

__double underscores__
</code></pre><p>会转成：</p>
<pre><code>&lt;em&gt;single asterisks&lt;/em&gt;

&lt;em&gt;single underscores&lt;/em&gt;

&lt;strong&gt;double asterisks&lt;/strong&gt;

&lt;strong&gt;double underscores&lt;/strong&gt;
</code></pre><p>你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。</p>
<p>强调也可以直接插在文字中间：</p>
<pre><code>un*frigging*believable
</code></pre><p>但是<strong>如果你的 <code>*</code> 和 <code>_</code> 两边都有空白的话，它们就只会被当成普通的符号</strong>。</p>
<p>如果要在文字前后直接插入普通的星号或底线，你可以用反斜线：</p>
<pre><code>\*this text is surrounded by literal asterisks\*
</code></pre><h3 id="code">代码</h3>

<p>如果要标记一小段行内代码，你可以用反引号把它包起来（<code>` </code>），例如：</p>
<pre><code>Use the `printf()` function.
</code></pre><p>会产生：</p>
<pre><code>&lt;p&gt;Use the &lt;code&gt;printf()&lt;/code&gt; function.&lt;/p&gt;
</code></pre><p>如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：</p>
<pre><code>``There is a literal backtick (`) here.``
</code></pre><p>这段语法会产生：</p>
<pre><code>&lt;p&gt;&lt;code&gt;There is a literal backtick (`) here.&lt;/code&gt;&lt;/p&gt;
</code></pre><p>代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号：</p>
<pre><code>A single backtick in a code span: `` ` ``

A backtick-delimited string in a code span: `` `foo` ``
</code></pre><p>会产生：</p>
<pre><code>&lt;p&gt;A single backtick in a code span: &lt;code&gt;`&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;A backtick-delimited string in a code span: &lt;code&gt;`foo`&lt;/code&gt;&lt;/p&gt;
</code></pre><p>在代码区段内，<code>&amp;</code> 和尖括号<strong>都</strong>会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段：</p>
<pre><code>Please don&#39;t use any `&lt;blink&gt;` tags.
</code></pre><p>转为：</p>
<pre><code>&lt;p&gt;Please don&#39;t use any &lt;code&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tags.&lt;/p&gt;
</code></pre><p>你也可以这样写：</p>
<pre><code>`&amp;#8212;` is the decimal-encoded equivalent of `&amp;mdash;`.
</code></pre><p>以产生：</p>
<pre><code>&lt;p&gt;&lt;code&gt;&amp;amp;#8212;&lt;/code&gt; is the decimal-encoded
equivalent of &lt;code&gt;&amp;amp;mdash;&lt;/code&gt;.&lt;/p&gt;
</code></pre><h3 id="img">图片</h3>

<p>很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。</p>
<p>Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： <em>行内式</em>和<em>参考式</em>。</p>
<p>行内式的图片语法看起来像是：</p>
<pre><code>![Alt text](/path/to/img.jpg)

![Alt text](/path/to/img.jpg &quot;Optional title&quot;)
</code></pre><p>详细叙述如下：</p>
<ul>
<li>一个惊叹号 <code>!</code></li>
<li>接着一个方括号，里面放上图片的替代文字</li>
<li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上<br>选择性的 ‘title’ 文字。</li>
</ul>
<p>参考式的图片语法则长得像这样：</p>
<pre><code>![Alt text][id]
</code></pre><p>「id」是图片参考的名称，图片参考的定义方式则和连结参考一样：</p>
<pre><code>[id]: url/to/image  &quot;Optional title attribute&quot;
</code></pre><p>到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 <code>&lt;img&gt;</code> 标签。</p>
<hr>
<h2 id="misc">其它</h2>

<h3 id="autolink">自动链接</h3>

<p>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：</p>
<pre><code>&lt;http://example.com/&gt;
</code></pre><p>Markdown 会转为：</p>
<pre><code>&lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt;
</code></pre><p>邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如：</p>
<pre><code>&lt;address@example.com&gt;
</code></pre><p>Markdown 会转成：</p>
<pre><code>&lt;a href=&quot;&amp;#x6D;&amp;#x61;i&amp;#x6C;&amp;#x74;&amp;#x6F;:&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;
&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;
&amp;#109;&quot;&gt;&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;
&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt;
</code></pre><p>在浏览器里面，这段字串（其实是 <code>&lt;a href=&quot;mailto:address@example.com&quot;&gt;address@example.com&lt;/a&gt;</code>）会变成一个可以点击的「address@example.com」链接。</p>
<p>（这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。）</p>
<h3 id="backslash">反斜杠</h3>

<p>Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 <code>&lt;em&gt;</code> 标签），你可以在星号的前面加上反斜杠：</p>
<pre><code>\*literal asterisks\*
</code></pre><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p>
<pre><code>\   反斜线
`   反引号
*   星号
_   底线
{}  花括号
[]  方括号
()  括弧
#   井字号
+   加号
-   减号
.   英文句点
!   惊叹号
</code></pre><h2 id="acknowledgement">感谢</h2>

<p>感谢 <a href="https://twitter.com/#!/leafy7382" target="_blank" rel="noopener">leafy7382</a> 协助翻译，<a href="http://iamhlb.com/" target="_blank" rel="noopener">hlb</a>、<a href="http://twitter.com/randylien" target="_blank" rel="noopener">Randylien</a> 帮忙润稿，<a href="https://twitter.com/#!/ethantw" target="_blank" rel="noopener">ethantw</a> 的<a href="http://ethantw.net/projects/han/" target="_blank" rel="noopener">汉字标准格式・CSS Reset</a>， <a href="http://kidwm.net/" target="_blank" rel="noopener">WM</a> 回报文字错误。</p>
<p>感谢 <a href="https://github.com/fenprace" target="_blank" rel="noopener">fenprace</a>，<a href="https://github.com/addv" target="_blank" rel="noopener">addv</a>。</p>
<hr>
<h2 id="editor">Markdown 免费编辑器</h2>

<p>Windows 平台</p>
<ul>
<li><a href="http://markdownpad.com/" target="_blank" rel="noopener">MarkdownPad</a></li>
<li><a href="http://code52.org/DownmarkerWPF/" target="_blank" rel="noopener">MarkPad</a></li>
</ul>
<p>Linux 平台</p>
<ul>
<li><a href="http://sourceforge.net/p/retext/home/ReText/" target="_blank" rel="noopener">ReText</a></li>
</ul>
<p>Mac 平台</p>
<ul>
<li><a href="http://mouapp.com/" target="_blank" rel="noopener">Mou</a></li>
</ul>
<p>在线编辑器</p>
<ul>
<li><a href="http://markable.in/" target="_blank" rel="noopener">Markable.in</a></li>
<li><a href="http://dillinger.io/" target="_blank" rel="noopener">Dillinger.io</a></li>
</ul>
<p>浏览器插件</p>
<ul>
<li><a href="https://chrome.google.com/webstore/detail/oknndfeeopgpibecfjljjfanledpbkog" target="_blank" rel="noopener">MaDe</a> (Chrome)</li>
</ul>
<p>高级应用</p>
<ul>
<li><a href="http://www.sublimetext.com/2" target="_blank" rel="noopener">Sublime Text 2</a> + <a href="http://ttscoff.github.com/MarkdownEditing/" target="_blank" rel="noopener">MarkdownEditing</a> / <a href="http://lucifr.com/2012/07/12/markdownediting-for-sublime-text-2/" target="_blank" rel="noopener">教程</a></li>
</ul>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>Markdown教程</tag>
      </tags>
  </entry>
  <entry>
    <title>[安卓开发]最全ADB命令</title>
    <url>/2020/03/27/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-%E6%9C%80%E5%85%A8ADB%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>转载自：<a href="https://github.com/mzlogin/awesome-adb" target="_blank" rel="noopener">https://github.com/mzlogin/awesome-adb</a><br>ADB，即 Android Debug Bridge，它是 Android 开发/测试人员不可替代的强大工具，也是 Android 设备玩家的好玩具。</p>
<p>持续更新中，欢迎提 PR 和 Issue 补充指正，觉得有用的可以将 此 GitHub 仓库 Star 收藏备用。</p>
<a id="more"></a>
<p><strong>注：</strong> 有部分命令的支持情况可能与 Android 系统版本及定制 ROM 的实现有关。</p>
<p>Other languages: <a href="https://blog.uuk4.com/page/3/README.en.md" target="_blank" rel="noopener">:gb: English</a></p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="命令语法"><a href="#命令语法" class="headerlink" title="命令语法"></a>命令语法</h3><p>adb 命令的基本语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb [-d|-e|-s &lt;serialNumber&gt;] &lt;command&gt;</span><br></pre></td></tr></table></figure>
<p>如果只有一个设备/模拟器连接时，可以省略掉 <code>[-d|-e|-s &lt;serialNumber&gt;]</code> 这一部分，直接使用 <code>adb &lt;command&gt;</code>。</p>
<h3 id="为命令指定目标设备"><a href="#为命令指定目标设备" class="headerlink" title="为命令指定目标设备"></a>为命令指定目标设备</h3><p>如果有多个设备/模拟器连接，则需要为命令指定目标设备。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d</td>
<td>指定当前唯一通过 USB 连接的 Android 设备为命令目标</td>
</tr>
<tr>
<td>-e</td>
<td>指定当前唯一运行的模拟器为命令目标</td>
</tr>
<tr>
<td><code>-s &lt;serialNumber&gt;</code></td>
<td>指定相应 serialNumber 号的设备/模拟器为命令目标</td>
</tr>
</tbody>
</table>
</div>
<p>在多个设备/模拟器连接的情况下较常用的是 <code>-s &lt;serialNumber&gt;</code> 参数，serialNumber 可以通过 <code>adb devices</code> 命令获取。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ adb devices</span><br><span class="line"></span><br><span class="line">List of devices attached</span><br><span class="line">cf264b8f	device</span><br><span class="line">emulator-5554	device</span><br><span class="line">10.129.164.6:5555	device</span><br></pre></td></tr></table></figure>
<p>输出里的 <code>cf264b8f</code>、<code>emulator-5554</code> 和 <code>10.129.164.6:5555</code> 即为 serialNumber。</p>
<p>比如这时想指定 <code>cf264b8f</code> 这个设备来运行 adb 命令获取屏幕分辨率：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb -s cf264b8f shell wm size</span><br></pre></td></tr></table></figure>
<p>又如想给 <code>10.129.164.6:5555</code> 这个设备安装应用（<em>这种形式的 serialNumber 格式为 <ip>:<port>，一般为无线连接的设备或 Genymotion 等第三方 Android 模拟器</port></ip></em>）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb -s 10.129.164.6:5555 install test.apk</span><br></pre></td></tr></table></figure>
<p><strong>遇到多设备/模拟器的情况均使用这几个参数为命令指定目标设备，下文中为简化描述，不再重复。</strong></p>
<h3 id="启动-停止"><a href="#启动-停止" class="headerlink" title="启动/停止"></a>启动/停止</h3><p>启动 adb server 命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb start-server</span><br></pre></td></tr></table></figure>
<p>（一般无需手动执行此命令，在运行 adb 命令时若发现 adb server 没有启动会自动调起。）</p>
<p>停止 adb server 命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb kill-server</span><br></pre></td></tr></table></figure>
<h3 id="查看-adb-版本"><a href="#查看-adb-版本" class="headerlink" title="查看 adb 版本"></a>查看 adb 版本</h3><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb version</span><br></pre></td></tr></table></figure>
<p>示例输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Android Debug Bridge version 1.0.36</span><br><span class="line">Revision 8f855a3d9b35-android</span><br></pre></td></tr></table></figure>
<h3 id="以-root-权限运行-adbd"><a href="#以-root-权限运行-adbd" class="headerlink" title="以 root 权限运行 adbd"></a>以 root 权限运行 adbd</h3><p>adb 的运行原理是 PC 端的 adb server 与手机端的守护进程 adbd 建立连接，然后 PC 端的 adb client 通过 adb server 转发命令，adbd 接收命令后解析运行。</p>
<p>所以如果 adbd 以普通权限执行，有些需要 root 权限才能执行的命令无法直接用 <code>adb xxx</code> 执行。这时可以 <code>adb shell</code> 然后 <code>su</code> 后执行命令，也可以让 adbd 以 root 权限执行，这个就能随意执行高权限命令了。</p>
<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb root</span><br></pre></td></tr></table></figure>
<p>正常输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">restarting adbd as root</span><br></pre></td></tr></table></figure>
<p>现在再运行 <code>adb shell</code>，看看命令行提示符是不是变成 <code>#</code> 了？</p>
<p>有些手机 root 后也无法通过 <code>adb root</code> 命令让 adbd 以 root 权限执行，比如三星的部分机型，会提示 <code>adbd cannot run as root in production builds</code>，此时可以先安装 adbd Insecure，然后 <code>adb root</code> 试试。</p>
<p>相应地，如果要恢复 adbd 为非 root 权限的话，可以使用 <code>adb unroot</code> 命令。</p>
<h3 id="指定-adb-server-的网络端口"><a href="#指定-adb-server-的网络端口" class="headerlink" title="指定 adb server 的网络端口"></a>指定 adb server 的网络端口</h3><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb -P &lt;port&gt; start-server</span><br></pre></td></tr></table></figure>
<p>默认端口为 5037。</p>
<h2 id="设备连接管理"><a href="#设备连接管理" class="headerlink" title="设备连接管理"></a>设备连接管理</h2><h3 id="查询已连接设备-模拟器"><a href="#查询已连接设备-模拟器" class="headerlink" title="查询已连接设备/模拟器"></a>查询已连接设备/模拟器</h3><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List of devices attached</span><br><span class="line">cf264b8f	device</span><br><span class="line">emulator-5554	device</span><br><span class="line">10.129.164.6:5555	device</span><br></pre></td></tr></table></figure>
<p>输出格式为 <code>[serialNumber] [state]</code>，serialNumber 即我们常说的 SN，state 有如下几种：</p>
<ul>
<li><code>offline</code> —— 表示设备未连接成功或无响应。</li>
<li><code>device</code> —— 设备已连接。注意这个状态并不能标识 Android 系统已经完全启动和可操作，在设备启动过程中设备实例就可连接到 adb，但启动完毕后系统才处于可操作状态。</li>
<li><code>no device</code> —— 没有设备/模拟器连接。</li>
</ul>
<p>以上输出显示当前已经连接了三台设备/模拟器，<code>cf264b8f</code>、<code>emulator-5554</code> 和 <code>10.129.164.6:5555</code> 分别是它们的 SN。从 <code>emulator-5554</code> 这个名字可以看出它是一个 Android 模拟器，而 <code>10.129.164.6:5555</code> 这种形为 <code>&lt;IP&gt;:&lt;Port&gt;</code> 的 serialNumber 一般是无线连接的设备或 Genymotion 等第三方 Android 模拟器。</p>
<p>常见异常输出：</p>
<ol>
<li><p>没有设备/模拟器连接成功。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List of devices attached</span><br></pre></td></tr></table></figure>
</li>
<li><p>设备/模拟器未连接到 adb 或无响应。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List of devices attached</span><br><span class="line">cf264b8f	offline</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="USB-连接"><a href="#USB-连接" class="headerlink" title="USB 连接"></a>USB 连接</h3><p>通过 USB 连接来正常使用 adb 需要保证几点：</p>
<ol>
<li><p>硬件状态正常。</p>
<p>包括 Android 设备处于正常开机状态，USB 连接线和各种接口完好。</p>
</li>
<li><p>Android 设备的开发者选项和 USB 调试模式已开启。</p>
<p>可以到「设置」-「开发者选项」-「Android 调试」查看。</p>
<p>如果在设置里找不到开发者选项，那需要通过一个彩蛋来让它显示出来：在「设置」-「关于手机」连续点击「版本号」7 次。</p>
</li>
<li><p>设备驱动状态正常。</p>
<p>这一点貌似在 Linux 和 Mac OS X 下不用操心，在 Windows 下有可能遇到需要安装驱动的情况，确认这一点可以右键「计算机」-「属性」，到「设备管理器」里查看相关设备上是否有黄色感叹号或问号，如果没有就说明驱动状态已经好了。否则可以下载一个手机助手类程序来安装驱动先。</p>
</li>
<li><p>通过 USB 线连接好电脑和设备后确认状态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure>
<p>如果能看到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xxxxxx device</span><br></pre></td></tr></table></figure>
<p>说明连接成功。</p>
</li>
</ol>
<h3 id="无线连接（需要借助-USB-线）"><a href="#无线连接（需要借助-USB-线）" class="headerlink" title="无线连接（需要借助 USB 线）"></a>无线连接（需要借助 USB 线）</h3><p>除了可以通过 USB 连接设备与电脑来使用 adb，也可以通过无线连接——虽然连接过程中也有需要使用 USB 的步骤，但是连接成功之后你的设备就可以在一定范围内摆脱 USB 连接线的限制啦！</p>
<p>操作步骤：</p>
<ol>
<li><p>将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。</p>
</li>
<li><p>将设备与电脑通过 USB 线连接。</p>
<p>应确保连接成功（可运行 <code>adb devices</code> 看是否能列出该设备）。</p>
</li>
<li><p>让设备在 5555 端口监听 TCP/IP 连接：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb tcpip 5555</span><br></pre></td></tr></table></figure>
</li>
<li><p>断开 USB 连接。</p>
</li>
<li><p>找到设备的 IP 地址。</p>
<p>一般能在「设置」-「关于手机」-「状态信息」-「IP地址」找到，也可以使用下文里 <a href="https://blog.uuk4.com/page/3/#ip-%E5%9C%B0%E5%9D%80" target="_blank" rel="noopener">查看设备信息 - IP 地址</a> 一节里的方法用 adb 命令来查看。</p>
</li>
<li><p>通过 IP 地址连接设备。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb connect &lt;device-ip-address&gt;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>&lt;device-ip-address&gt;</code> 就是上一步中找到的设备 IP 地址。</p>
</li>
<li><p>确认连接状态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure>
<p>如果能看到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;device-ip-address&gt;:5555 device</span><br></pre></td></tr></table></figure>
<p>说明连接成功。</p>
</li>
</ol>
<p>如果连接不了，请确认 Android 设备与电脑是连接到了同一个 WiFi，然后再次执行 <code>adb connect &lt;device-ip-address&gt;</code> 那一步；</p>
<p>如果还是不行的话，通过 <code>adb kill-server</code> 重新启动 adb 然后从头再来一次试试。</p>
<p><strong>断开无线连接</strong></p>
<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb disconnect &lt;device-ip-address&gt;</span><br></pre></td></tr></table></figure>
<h3 id="无线连接（无需借助-USB-线）"><a href="#无线连接（无需借助-USB-线）" class="headerlink" title="无线连接（无需借助 USB 线）"></a>无线连接（无需借助 USB 线）</h3><p><strong>注：需要 root 权限。</strong></p>
<p>上一节「无线连接（需要借助 USB 线）」是官方文档里介绍的方法，需要借助于 USB 数据线来实现无线连接。</p>
<p>既然我们想要实现无线连接，那能不能所有步骤下来都是无线的呢？答案是能的。</p>
<ol>
<li><p>在 Android 设备上安装一个终端模拟器。</p>
<p>已经安装过的设备可以跳过此步。我使用的终端模拟器下载地址是：Terminal Emulator for Android Downloads</p>
</li>
<li><p>将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。</p>
</li>
<li><p>打开 Android 设备上的终端模拟器，在里面依次运行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su</span><br><span class="line">setprop service.adb.tcp.port 5555</span><br></pre></td></tr></table></figure>
</li>
<li><p>找到 Android 设备的 IP 地址。</p>
<p>一般能在「设置」-「关于手机」-「状态信息」-「IP地址」找到，也可以使用下文里 <a href="https://blog.uuk4.com/page/3/#ip-%E5%9C%B0%E5%9D%80" target="_blank" rel="noopener">查看设备信息 - IP 地址</a> 一节里的方法用 adb 命令来查看。</p>
</li>
<li><p>在电脑上通过 adb 和 IP 地址连接 Android 设备。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb connect &lt;device-ip-address&gt;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>&lt;device-ip-address&gt;</code> 就是上一步中找到的设备 IP 地址。</p>
<p>如果能看到 <code>connected to &lt;device-ip-address&gt;:5555</code> 这样的输出则表示连接成功。</p>
</li>
</ol>
<p><em>节注一：</em></p>
<p>有的设备，比如小米 5S + MIUI 8.0 + Android 6.0.1 MXB48T，可能在第 5 步之前需要重启 adbd 服务，在设备的终端模拟器上运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">restart adbd</span><br></pre></td></tr></table></figure>
<p>如果 restart 无效，尝试以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start adbd</span><br><span class="line">stop adbd</span><br></pre></td></tr></table></figure>
<h2 id="应用管理"><a href="#应用管理" class="headerlink" title="应用管理"></a>应用管理</h2><h3 id="查看应用列表"><a href="#查看应用列表" class="headerlink" title="查看应用列表"></a>查看应用列表</h3><p>查看应用列表的基本命令格式是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell pm list packages [-f] [-d] [-e] [-s] [-3] [-i] [-u] [--user USER_ID] [FILTER]</span><br></pre></td></tr></table></figure>
<p>即在 <code>adb shell pm list packages</code> 的基础上可以加一些参数进行过滤查看不同的列表，支持的过滤参数如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>显示列表</th>
</tr>
</thead>
<tbody>
<tr>
<td>无</td>
<td>所有应用</td>
</tr>
<tr>
<td>-f</td>
<td>显示应用关联的 apk 文件</td>
</tr>
<tr>
<td>-d</td>
<td>只显示 disabled 的应用</td>
</tr>
<tr>
<td>-e</td>
<td>只显示 enabled 的应用</td>
</tr>
<tr>
<td>-s</td>
<td>只显示系统应用</td>
</tr>
<tr>
<td>-3</td>
<td>只显示第三方应用</td>
</tr>
<tr>
<td>-i</td>
<td>显示应用的 installer</td>
</tr>
<tr>
<td>-u</td>
<td>包含已卸载应用</td>
</tr>
<tr>
<td><code>&lt;FILTER&gt;</code></td>
<td>包名包含 <code>&lt;FILTER&gt;</code> 字符串</td>
</tr>
</tbody>
</table>
</div>
<h4 id="所有应用"><a href="#所有应用" class="headerlink" title="所有应用"></a>所有应用</h4><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell pm list packages</span><br></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package:com.android.smoketest</span><br><span class="line">package:com.example.android.livecubes</span><br><span class="line">package:com.android.providers.telephony</span><br><span class="line">package:com.google.android.googlequicksearchbox</span><br><span class="line">package:com.android.providers.calendar</span><br><span class="line">package:com.android.providers.media</span><br><span class="line">package:com.android.protips</span><br><span class="line">package:com.android.documentsui</span><br><span class="line">package:com.android.gallery</span><br><span class="line">package:com.android.externalstorage</span><br><span class="line">...</span><br><span class="line">// other packages here</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="系统应用"><a href="#系统应用" class="headerlink" title="系统应用"></a>系统应用</h4><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell pm list packages -s</span><br></pre></td></tr></table></figure>
<h4 id="第三方应用"><a href="#第三方应用" class="headerlink" title="第三方应用"></a>第三方应用</h4><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell pm list packages -3</span><br></pre></td></tr></table></figure>
<h4 id="包名包含某字符串的应用"><a href="#包名包含某字符串的应用" class="headerlink" title="包名包含某字符串的应用"></a>包名包含某字符串的应用</h4><p>比如要查看包名包含字符串 <code>mazhuang</code> 的应用列表，命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell pm list packages mazhuang</span><br></pre></td></tr></table></figure>
<p>当然也可以使用 grep 来过滤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell pm list packages | grep mazhuang</span><br></pre></td></tr></table></figure>
<h3 id="安装-APK"><a href="#安装-APK" class="headerlink" title="安装 APK"></a>安装 APK</h3><p>命令格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb install [-lrtsdg] &lt;path_to_apk&gt;</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<p><code>adb install</code> 后面可以跟一些可选参数来控制安装 APK 的行为，可用参数及含义如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-l</td>
<td>将应用安装到保护目录 /mnt/asec</td>
</tr>
<tr>
<td>-r</td>
<td>允许覆盖安装</td>
</tr>
<tr>
<td>-t</td>
<td>允许安装 AndroidManifest.xml 里 application 指定 <code>android:testOnly=&quot;true&quot;</code> 的应用</td>
</tr>
<tr>
<td>-s</td>
<td>将应用安装到 sdcard</td>
</tr>
<tr>
<td>-d</td>
<td>允许降级覆盖安装</td>
</tr>
<tr>
<td>-g</td>
<td>授予所有运行时权限</td>
</tr>
</tbody>
</table>
</div>
<p>运行命令后如果见到类似如下输出（状态为 <code>Success</code>）代表安装成功：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[100%] /data/local/tmp/1.apk</span><br><span class="line">truepkg: /data/local/tmp/1.apk</span><br><span class="line">Success</span><br></pre></td></tr></table></figure>
<p>上面是当前最新版 v1.0.36 的 adb 的输出，会显示 push apk 文件到手机的进度百分比。</p>
<p>使用旧版本 adb 的输出则是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12040 KB/s (22205609 bytes in 1.801s)</span><br><span class="line">        pkg: /data/local/tmp/SogouInput_android_v8.3_sweb.apk</span><br><span class="line">Success</span><br></pre></td></tr></table></figure>
<p>而如果状态为 <code>Failure</code> 则表示安装失败，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[100%] /data/local/tmp/map-20160831.apk</span><br><span class="line">        pkg: /data/local/tmp/map-20160831.apk</span><br><span class="line">Failure [INSTALL_FAILED_ALREADY_EXISTS]</span><br></pre></td></tr></table></figure>
<p>常见安装失败输出代码、含义及可能的解决办法如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>输出</th>
<th>含义</th>
<th>解决办法</th>
</tr>
</thead>
<tbody>
<tr>
<td>INSTALL_FAILED_ALREADY_EXISTS</td>
<td>应用已经存在，或卸载了但没卸载干净</td>
<td><code>adb install</code> 时使用 <code>-r</code> 参数，或者先 <code>adb uninstall &lt;packagename&gt;</code> 再安装</td>
</tr>
<tr>
<td>INSTALL_FAILED_INVALID_APK</td>
<td>无效的 APK 文件</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_INVALID_URI</td>
<td>无效的 APK 文件名</td>
<td>确保 APK 文件名里无中文</td>
</tr>
<tr>
<td>INSTALL_FAILED_INSUFFICIENT_STORAGE</td>
<td>空间不足</td>
<td>清理空间</td>
</tr>
<tr>
<td>INSTALL_FAILED_DUPLICATE_PACKAGE</td>
<td>已经存在同名程序</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_NO_SHARED_USER</td>
<td>请求的共享用户不存在</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_UPDATE_INCOMPATIBLE</td>
<td>以前安装过同名应用，但卸载时数据没有移除</td>
<td>先 <code>adb uninstall &lt;packagename&gt;</code> 再安装</td>
</tr>
<tr>
<td>INSTALL_FAILED_SHARED_USER_INCOMPATIBLE</td>
<td>请求的共享用户存在但签名不一致</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_MISSING_SHARED_LIBRARY</td>
<td>安装包使用了设备上不可用的共享库</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_REPLACE_COULDNT_DELETE</td>
<td>替换时无法删除</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_DEXOPT</td>
<td>dex 优化验证失败或空间不足</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_OLDER_SDK</td>
<td>设备系统版本低于应用要求</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_CONFLICTING_PROVIDER</td>
<td>设备里已经存在与应用里同名的 content provider</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_NEWER_SDK</td>
<td>设备系统版本高于应用要求</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_TEST_ONLY</td>
<td>应用是 test-only 的，但安装时没有指定 <code>-t</code> 参数</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_CPU_ABI_INCOMPATIBLE</td>
<td>包含不兼容设备 CPU 应用程序二进制接口的 native code</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_MISSING_FEATURE</td>
<td>应用使用了设备不可用的功能</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_CONTAINER_ERROR</td>
<td>1. sdcard 访问失败; 2. 应用签名与 ROM 签名一致，被当作内置应用</td>
<td>1. 确认 sdcard 可用，或者安装到内置存储; 2. 打包时不与 ROM 使用相同签名</td>
</tr>
<tr>
<td>INSTALL_FAILED_INVALID_INSTALL_LOCATION</td>
<td>1. 不能安装到指定位置; 2. 应用签名与 ROM 签名一致，被当作内置应用</td>
<td>1. 切换安装位置，添加或删除 <code>-s</code> 参数; 2. 打包时不与 ROM 使用相同签名</td>
</tr>
<tr>
<td>INSTALL_FAILED_MEDIA_UNAVAILABLE</td>
<td>安装位置不可用</td>
<td>一般为 sdcard，确认 sdcard 可用或安装到内置存储</td>
</tr>
<tr>
<td>INSTALL_FAILED_VERIFICATION_TIMEOUT</td>
<td>验证安装包超时</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_VERIFICATION_FAILURE</td>
<td>验证安装包失败</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_PACKAGE_CHANGED</td>
<td>应用与调用程序期望的不一致</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_UID_CHANGED</td>
<td>以前安装过该应用，与本次分配的 UID 不一致</td>
<td>清除以前安装过的残留文件</td>
</tr>
<tr>
<td>INSTALL_FAILED_VERSION_DOWNGRADE</td>
<td>已经安装了该应用更高版本</td>
<td>使用 <code>-d</code> 参数</td>
</tr>
<tr>
<td>INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE</td>
<td>已安装 target SDK 支持运行时权限的同名应用，要安装的版本不支持运行时权限</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_NOT_APK</td>
<td>指定路径不是文件，或不是以 <code>.apk</code> 结尾</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_BAD_MANIFEST</td>
<td>无法解析的 AndroidManifest.xml 文件</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION</td>
<td>解析器遇到异常</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_NO_CERTIFICATES</td>
<td>安装包没有签名</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES</td>
<td>已安装该应用，且签名与 APK 文件不一致</td>
<td>先卸载设备上的该应用，再安装</td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING</td>
<td>解析 APK 文件时遇到 <code>CertificateEncodingException</code></td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME</td>
<td>manifest 文件里没有或者使用了无效的包名</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID</td>
<td>manifest 文件里指定了无效的共享用户 ID</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_MANIFEST_MALFORMED</td>
<td>解析 manifest 文件时遇到结构性错误</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_MANIFEST_EMPTY</td>
<td>在 manifest 文件里找不到找可操作标签（instrumentation 或 application）</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_INTERNAL_ERROR</td>
<td>因系统问题安装失败</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_USER_RESTRICTED</td>
<td>用户被限制安装应用</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_DUPLICATE_PERMISSION</td>
<td>应用尝试定义一个已经存在的权限名称</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_NO_MATCHING_ABIS</td>
<td>应用包含设备的应用程序二进制接口不支持的 native code</td>
<td></td>
</tr>
<tr>
<td>INSTALL_CANCELED_BY_USER</td>
<td>应用安装需要在设备上确认，但未操作设备或点了取消</td>
<td>在设备上同意安装</td>
</tr>
<tr>
<td>INSTALL_FAILED_ACWF_INCOMPATIBLE</td>
<td>应用程序与设备不兼容</td>
<td></td>
</tr>
<tr>
<td>does not contain AndroidManifest.xml</td>
<td>无效的 APK 文件</td>
<td></td>
</tr>
<tr>
<td>is not a valid zip file</td>
<td>无效的 APK 文件</td>
<td></td>
</tr>
<tr>
<td>Offline</td>
<td>设备未连接成功</td>
<td>先将设备与 adb 连接成功</td>
</tr>
<tr>
<td>unauthorized</td>
<td>设备未授权允许调试</td>
<td></td>
</tr>
<tr>
<td>error: device not found</td>
<td>没有连接成功的设备</td>
<td>先将设备与 adb 连接成功</td>
</tr>
<tr>
<td>protocol failure</td>
<td>设备已断开连接</td>
<td>先将设备与 adb 连接成功</td>
</tr>
<tr>
<td>Unknown option: -s</td>
<td>Android 2.2 以下不支持安装到 sdcard</td>
<td>不使用 <code>-s</code> 参数</td>
</tr>
<tr>
<td>No space left on devicerm</td>
<td>空间不足</td>
<td>清理空间</td>
</tr>
<tr>
<td>Permission denied … sdcard …</td>
<td>sdcard 不可用</td>
</tr>
</tbody>
</table>
</div>
<p>参考：PackageManager.java</p>
<p><em>adb install 内部原理简介</em></p>
<p><code>adb install</code> 实际是分三步完成：</p>
<ol>
<li>push apk 文件到 /data/local/tmp。</li>
<li>调用 pm install 安装。</li>
<li>删除 /data/local/tmp 下的对应 apk 文件。</li>
</ol>
<p>所以，必要的时候也可以根据这个步骤，手动分步执行安装过程。</p>
<h3 id="卸载应用"><a href="#卸载应用" class="headerlink" title="卸载应用"></a>卸载应用</h3><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb uninstall [-k] &lt;packagename&gt;</span><br></pre></td></tr></table></figure>
<p><code>&lt;packagename&gt;</code> 表示应用的包名，<code>-k</code> 参数可选，表示卸载应用但保留数据和缓存目录。</p>
<p>命令示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb uninstall com.qihoo360.mobilesafe</span><br></pre></td></tr></table></figure>
<p>表示卸载 360 手机卫士。</p>
<h3 id="清除应用数据与缓存"><a href="#清除应用数据与缓存" class="headerlink" title="清除应用数据与缓存"></a>清除应用数据与缓存</h3><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell pm clear &lt;packagename&gt;</span><br></pre></td></tr></table></figure>
<p><code>&lt;packagename&gt;</code> 表示应用名包，这条命令的效果相当于在设置里的应用信息界面点击了「清除缓存」和「清除数据」。</p>
<p>命令示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell pm clear com.qihoo360.mobilesafe</span><br></pre></td></tr></table></figure>
<p>表示清除 360 手机卫士的数据和缓存。</p>
<h3 id="查看前台-Activity"><a href="#查看前台-Activity" class="headerlink" title="查看前台 Activity"></a>查看前台 Activity</h3><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys activity activities | grep mFocusedActivity</span><br></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mFocusedActivity: ActivityRecord&#123;8079d7e u0 com.cyanogenmod.trebuchet/com.android.launcher3.Launcher t42&#125;</span><br></pre></td></tr></table></figure>
<p>其中的 <code>com.cyanogenmod.trebuchet/com.android.launcher3.Launcher</code> 就是当前处于前台的 Activity。</p>
<h3 id="查看正在运行的-Services"><a href="#查看正在运行的-Services" class="headerlink" title="查看正在运行的 Services"></a>查看正在运行的 Services</h3><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys activity services [&lt;packagename&gt;]</span><br></pre></td></tr></table></figure>
<p><code>&lt;packagename&gt;</code> 参数不是必须的，指定 <code>&lt;packagename&gt;</code> 表示查看与某个包名相关的 Services，不指定表示查看所有 Services。</p>
<p><code>&lt;packagename&gt;</code> 不一定要给出完整的包名，比如运行 <code>adb shell dumpsys activity services org.mazhuang</code>，那么包名 <code>org.mazhuang.demo1</code>、<code>org.mazhuang.demo2</code> 和 <code>org.mazhuang123</code> 等相关的 Services 都会列出来。</p>
<h2 id="与应用交互"><a href="#与应用交互" class="headerlink" title="与应用交互"></a>与应用交互</h2><p>主要是使用 <code>am &lt;command&gt;</code> 命令，常用的 <code>&lt;command&gt;</code> 如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>command</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>start [options] &lt;INTENT&gt;</code></td>
<td>启动 <code>&lt;INTENT&gt;</code> 指定的 Activity</td>
</tr>
<tr>
<td><code>startservice [options] &lt;INTENT&gt;</code></td>
<td>启动 <code>&lt;INTENT&gt;</code> 指定的 Service</td>
</tr>
<tr>
<td><code>broadcast [options] &lt;INTENT&gt;</code></td>
<td>发送 <code>&lt;INTENT&gt;</code> 指定的广播</td>
</tr>
<tr>
<td><code>force-stop &lt;packagename&gt;</code></td>
<td>停止 <code>&lt;packagename&gt;</code> 相关的进程</td>
</tr>
</tbody>
</table>
</div>
<p><code>&lt;INTENT&gt;</code> 参数很灵活，和写 Android 程序时代码里的 Intent 相对应。</p>
<p>用于决定 intent 对象的选项如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-a &lt;ACTION&gt;</code></td>
<td>指定 action，比如 <code>android.intent.action.VIEW</code></td>
</tr>
<tr>
<td><code>-c &lt;CATEGORY&gt;</code></td>
<td>指定 category，比如 <code>android.intent.category.APP_CONTACTS</code></td>
</tr>
<tr>
<td><code>-n &lt;COMPONENT&gt;</code></td>
<td>指定完整 component 名，用于明确指定启动哪个 Activity，如 <code>com.example.app/.ExampleActivity</code></td>
</tr>
</tbody>
</table>
</div>
<p><code>&lt;INTENT&gt;</code> 里还能带数据，就像写代码时的 Bundle 一样：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>--esn &lt;EXTRA_KEY&gt;</code></td>
<td>null 值（只有 key 名）</td>
<td></td>
</tr>
<tr>
<td>`-e</td>
<td>–es <extra_key> <extra_string_value>`</extra_string_value></extra_key></td>
<td>string 值</td>
</tr>
<tr>
<td><code>--ez &lt;EXTRA_KEY&gt; &lt;EXTRA_BOOLEAN_VALUE&gt;</code></td>
<td>boolean 值</td>
<td></td>
</tr>
<tr>
<td><code>--ei &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt;</code></td>
<td>integer 值</td>
<td></td>
</tr>
<tr>
<td><code>--el &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt;</code></td>
<td>long 值</td>
<td></td>
</tr>
<tr>
<td><code>--ef &lt;EXTRA_KEY&gt; &lt;EXTRA_FLOAT_VALUE&gt;</code></td>
<td>float 值</td>
<td></td>
</tr>
<tr>
<td><code>--eu &lt;EXTRA_KEY&gt; &lt;EXTRA_URI_VALUE&gt;</code></td>
<td>URI</td>
<td></td>
</tr>
<tr>
<td><code>--ecn &lt;EXTRA_KEY&gt; &lt;EXTRA_COMPONENT_NAME_VALUE&gt;</code></td>
<td>component name</td>
<td></td>
</tr>
<tr>
<td><code>--eia &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt;[,&lt;EXTRA_INT_VALUE...]</code></td>
<td>integer 数组</td>
<td></td>
</tr>
<tr>
<td><code>--ela &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt;[,&lt;EXTRA_LONG_VALUE...]</code></td>
<td>long 数组</td>
</tr>
</tbody>
</table>
</div>
<h3 id="调起-Activity"><a href="#调起-Activity" class="headerlink" title="调起 Activity"></a>调起 Activity</h3><p>命令格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell am start [options] &lt;INTENT&gt;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell am start -n com.tencent.mm/.ui.LauncherUI</span><br></pre></td></tr></table></figure>
<p>表示调起微信主界面。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell am start -n org.mazhuang.boottimemeasure/.MainActivity --es &quot;toast&quot; &quot;hello, world&quot;</span><br></pre></td></tr></table></figure>
<p>表示调起 <code>org.mazhuang.boottimemeasure/.MainActivity</code> 并传给它 string 数据键值对 <code>toast - hello, world</code>。</p>
<h3 id="调起-Service"><a href="#调起-Service" class="headerlink" title="调起 Service"></a>调起 Service</h3><p>命令格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell am startservice [options] &lt;INTENT&gt;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell am startservice -n com.tencent.mm/.plugin.accountsync.model.AccountAuthenticatorService</span><br></pre></td></tr></table></figure>
<p>表示调起微信的某 Service。</p>
<h3 id="发送广播"><a href="#发送广播" class="headerlink" title="发送广播"></a>发送广播</h3><p>命令格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell am broadcast [options] &lt;INTENT&gt;</span><br></pre></td></tr></table></figure>
<p>可以向所有组件广播，也可以只向指定组件广播。</p>
<p>例如，向所有组件广播 <code>BOOT_COMPLETED</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell am broadcast -a android.intent.action.BOOT_COMPLETED</span><br></pre></td></tr></table></figure>
<p>又例如，只向 <code>org.mazhuang.boottimemeasure/.BootCompletedReceiver</code> 广播 <code>BOOT_COMPLETED</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell am broadcast -a android.intent.action.BOOT_COMPLETED -n org.mazhuang.boottimemeasure/.BootCompletedReceiver</span><br></pre></td></tr></table></figure>
<p>这类用法在测试的时候很实用，比如某个广播的场景很难制造，可以考虑通过这种方式来发送广播。</p>
<p>既能发送系统预定义的广播，也能发送自定义广播。如下是部分系统预定义广播及正常触发时机：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>action</th>
<th>触发时机</th>
</tr>
</thead>
<tbody>
<tr>
<td>android.net.conn.CONNECTIVITY_CHANGE</td>
<td>网络连接发生变化</td>
</tr>
<tr>
<td>android.intent.action.SCREEN_ON</td>
<td>屏幕点亮</td>
</tr>
<tr>
<td>android.intent.action.SCREEN_OFF</td>
<td>屏幕熄灭</td>
</tr>
<tr>
<td>android.intent.action.BATTERY_LOW</td>
<td>电量低，会弹出电量低提示框</td>
</tr>
<tr>
<td>android.intent.action.BATTERY_OKAY</td>
<td>电量恢复了</td>
</tr>
<tr>
<td>android.intent.action.BOOT_COMPLETED</td>
<td>设备启动完毕</td>
</tr>
<tr>
<td>android.intent.action.DEVICE_STORAGE_LOW</td>
<td>存储空间过低</td>
</tr>
<tr>
<td>android.intent.action.DEVICE_STORAGE_OK</td>
<td>存储空间恢复</td>
</tr>
<tr>
<td>android.intent.action.PACKAGE_ADDED</td>
<td>安装了新的应用</td>
</tr>
<tr>
<td>android.net.wifi.STATE_CHANGE</td>
<td>WiFi 连接状态发生变化</td>
</tr>
<tr>
<td>android.net.wifi.WIFI_STATE_CHANGED</td>
<td>WiFi 状态变为启用/关闭/正在启动/正在关闭/未知</td>
</tr>
<tr>
<td>android.intent.action.BATTERY_CHANGED</td>
<td>电池电量发生变化</td>
</tr>
<tr>
<td>android.intent.action.INPUT_METHOD_CHANGED</td>
<td>系统输入法发生变化</td>
</tr>
<tr>
<td>android.intent.action.ACTION_POWER_CONNECTED</td>
<td>外部电源连接</td>
</tr>
<tr>
<td>android.intent.action.ACTION_POWER_DISCONNECTED</td>
<td>外部电源断开连接</td>
</tr>
<tr>
<td>android.intent.action.DREAMING_STARTED</td>
<td>系统开始休眠</td>
</tr>
<tr>
<td>android.intent.action.DREAMING_STOPPED</td>
<td>系统停止休眠</td>
</tr>
<tr>
<td>android.intent.action.WALLPAPER_CHANGED</td>
<td>壁纸发生变化</td>
</tr>
<tr>
<td>android.intent.action.HEADSET_PLUG</td>
<td>插入耳机</td>
</tr>
<tr>
<td>android.intent.action.MEDIA_UNMOUNTED</td>
<td>卸载外部介质</td>
</tr>
<tr>
<td>android.intent.action.MEDIA_MOUNTED</td>
<td>挂载外部介质</td>
</tr>
<tr>
<td>android.os.action.POWER_SAVE_MODE_CHANGED</td>
<td>省电模式开启</td>
</tr>
</tbody>
</table>
</div>
<p><em>（以上广播均可使用 adb 触发）</em></p>
<h3 id="强制停止应用"><a href="#强制停止应用" class="headerlink" title="强制停止应用"></a>强制停止应用</h3><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell am force-stop &lt;packagename&gt;</span><br></pre></td></tr></table></figure>
<p>命令示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell am force-stop com.qihoo360.mobilesafe</span><br></pre></td></tr></table></figure>
<p>表示停止 360 安全卫士的一切进程与服务。</p>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h3 id="复制设备里的文件到电脑"><a href="#复制设备里的文件到电脑" class="headerlink" title="复制设备里的文件到电脑"></a>复制设备里的文件到电脑</h3><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb pull &lt;设备里的文件路径&gt; [电脑上的目录]</span><br></pre></td></tr></table></figure>
<p>其中 <code>电脑上的目录</code> 参数可以省略，默认复制到当前目录。</p>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb pull /sdcard/sr.mp4 ~/tmp/</span><br></pre></td></tr></table></figure>
<p><em>小技巧：</em>设备上的文件路径可能需要 root 权限才能访问，如果你的设备已经 root 过，可以先使用 <code>adb shell</code> 和 <code>su</code> 命令在 adb shell 里获取 root 权限后，先 <code>cp /path/on/device /sdcard/filename</code> 将文件复制到 sdcard，然后 <code>adb pull /sdcard/filename /path/on/pc</code>。</p>
<h3 id="复制电脑里的文件到设备"><a href="#复制电脑里的文件到设备" class="headerlink" title="复制电脑里的文件到设备"></a>复制电脑里的文件到设备</h3><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb push &lt;电脑上的文件路径&gt; &lt;设备里的目录&gt;</span><br></pre></td></tr></table></figure>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb push ~/sr.mp4 /sdcard/</span><br></pre></td></tr></table></figure>
<p><em>小技巧：</em>设备上的文件路径普通权限可能无法直接写入，如果你的设备已经 root 过，可以先 <code>adb push /path/on/pc /sdcard/filename</code>，然后 <code>adb shell</code> 和 <code>su</code> 在 adb shell 里获取 root 权限后，<code>cp /sdcard/filename /path/on/device</code>。</p>
<h2 id="模拟按键-输入"><a href="#模拟按键-输入" class="headerlink" title="模拟按键/输入"></a>模拟按键/输入</h2><p>在 <code>adb shell</code> 里有个很实用的命令叫 <code>input</code>，通过它可以做一些有趣的事情。</p>
<p><code>input</code> 命令的完整 help 信息如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage: input [&lt;source&gt;] &lt;command&gt; [&lt;arg&gt;...]</span><br><span class="line"></span><br><span class="line">The sources are:</span><br><span class="line">      mouse</span><br><span class="line">      keyboard</span><br><span class="line">      joystick</span><br><span class="line">      touchnavigation</span><br><span class="line">      touchpad</span><br><span class="line">      trackball</span><br><span class="line">      stylus</span><br><span class="line">      dpad</span><br><span class="line">      gesture</span><br><span class="line">      touchscreen</span><br><span class="line">      gamepad</span><br><span class="line"></span><br><span class="line">The commands and default sources are:</span><br><span class="line">      text &lt;string&gt; (Default: touchscreen)</span><br><span class="line">      keyevent [--longpress] &lt;key code number or name&gt; ... (Default: keyboard)</span><br><span class="line">      tap &lt;x&gt; &lt;y&gt; (Default: touchscreen)</span><br><span class="line">      swipe &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt; [duration(ms)] (Default: touchscreen)</span><br><span class="line">      press (Default: trackball)</span><br><span class="line">      roll &lt;dx&gt; &lt;dy&gt; (Default: trackball)</span><br></pre></td></tr></table></figure>
<p>比如使用 <code>adb shell input keyevent &lt;keycode&gt;</code> 命令，不同的 keycode 能实现不同的功能，完整的 keycode 列表详见 KeyEvent，摘引部分我觉得有意思的如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>keycode</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>3</td>
<td>HOME 键</td>
</tr>
<tr>
<td>4</td>
<td>返回键</td>
</tr>
<tr>
<td>5</td>
<td>打开拨号应用</td>
</tr>
<tr>
<td>6</td>
<td>挂断电话</td>
</tr>
<tr>
<td>24</td>
<td>增加音量</td>
</tr>
<tr>
<td>25</td>
<td>降低音量</td>
</tr>
<tr>
<td>26</td>
<td>电源键</td>
</tr>
<tr>
<td>27</td>
<td>拍照（需要在相机应用里）</td>
</tr>
<tr>
<td>64</td>
<td>打开浏览器</td>
</tr>
<tr>
<td>82</td>
<td>菜单键</td>
</tr>
<tr>
<td>85</td>
<td>播放/暂停</td>
</tr>
<tr>
<td>86</td>
<td>停止播放</td>
</tr>
<tr>
<td>87</td>
<td>播放下一首</td>
</tr>
<tr>
<td>88</td>
<td>播放上一首</td>
</tr>
<tr>
<td>122</td>
<td>移动光标到行首或列表顶部</td>
</tr>
<tr>
<td>123</td>
<td>移动光标到行末或列表底部</td>
</tr>
<tr>
<td>126</td>
<td>恢复播放</td>
</tr>
<tr>
<td>127</td>
<td>暂停播放</td>
</tr>
<tr>
<td>164</td>
<td>静音</td>
</tr>
<tr>
<td>176</td>
<td>打开系统设置</td>
</tr>
<tr>
<td>187</td>
<td>切换应用</td>
</tr>
<tr>
<td>207</td>
<td>打开联系人</td>
</tr>
<tr>
<td>208</td>
<td>打开日历</td>
</tr>
<tr>
<td>209</td>
<td>打开音乐</td>
</tr>
<tr>
<td>210</td>
<td>打开计算器</td>
</tr>
<tr>
<td>220</td>
<td>降低屏幕亮度</td>
</tr>
<tr>
<td>221</td>
<td>提高屏幕亮度</td>
</tr>
<tr>
<td>223</td>
<td>系统休眠</td>
</tr>
<tr>
<td>224</td>
<td>点亮屏幕</td>
</tr>
<tr>
<td>231</td>
<td>打开语音助手</td>
</tr>
<tr>
<td>276</td>
<td>如果没有 wakelock 则让系统休眠</td>
</tr>
</tbody>
</table>
</div>
<p>下面是 <code>input</code> 命令的一些用法举例。</p>
<h3 id="电源键"><a href="#电源键" class="headerlink" title="电源键"></a>电源键</h3><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 26</span><br></pre></td></tr></table></figure>
<p>执行效果相当于按电源键。</p>
<h3 id="菜单键"><a href="#菜单键" class="headerlink" title="菜单键"></a>菜单键</h3><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 82</span><br></pre></td></tr></table></figure>
<h3 id="HOME-键"><a href="#HOME-键" class="headerlink" title="HOME 键"></a>HOME 键</h3><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 3</span><br></pre></td></tr></table></figure>
<h3 id="返回键"><a href="#返回键" class="headerlink" title="返回键"></a>返回键</h3><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 4</span><br></pre></td></tr></table></figure>
<h3 id="音量控制"><a href="#音量控制" class="headerlink" title="音量控制"></a>音量控制</h3><p>增加音量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 24</span><br></pre></td></tr></table></figure>
<p>降低音量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 25</span><br></pre></td></tr></table></figure>
<p>静音：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 164</span><br></pre></td></tr></table></figure>
<h3 id="媒体控制"><a href="#媒体控制" class="headerlink" title="媒体控制"></a>媒体控制</h3><p>播放/暂停：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 85</span><br></pre></td></tr></table></figure>
<p>停止播放：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 86</span><br></pre></td></tr></table></figure>
<p>播放下一首：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 87</span><br></pre></td></tr></table></figure>
<p>播放上一首：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 88</span><br></pre></td></tr></table></figure>
<p>恢复播放：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 126</span><br></pre></td></tr></table></figure>
<p>暂停播放：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 127</span><br></pre></td></tr></table></figure>
<h3 id="点亮-熄灭屏幕"><a href="#点亮-熄灭屏幕" class="headerlink" title="点亮/熄灭屏幕"></a>点亮/熄灭屏幕</h3><p>可以通过上文讲述过的模拟电源键来切换点亮和熄灭屏幕，但如果明确地想要点亮或者熄灭屏幕，那可以使用如下方法。</p>
<p>点亮屏幕：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 224</span><br></pre></td></tr></table></figure>
<p>熄灭屏幕：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 223</span><br></pre></td></tr></table></figure>
<h3 id="滑动解锁"><a href="#滑动解锁" class="headerlink" title="滑动解锁"></a>滑动解锁</h3><p>如果锁屏没有密码，是通过滑动手势解锁，那么可以通过 <code>input swipe</code> 来解锁。</p>
<p>命令（参数以机型 Nexus 5，向上滑动手势解锁举例）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell input swipe 300 1000 300 500</span><br></pre></td></tr></table></figure>
<p>参数 <code>300 1000 300 500</code> 分别表示<code>起始点x坐标 起始点y坐标 结束点x坐标 结束点y坐标</code>。</p>
<h3 id="输入文本"><a href="#输入文本" class="headerlink" title="输入文本"></a>输入文本</h3><p>在焦点处于某文本框时，可以通过 <code>input</code> 命令来输入文本。</p>
<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell input text hello</span><br></pre></td></tr></table></figure>
<p>现在 <code>hello</code> 出现在文本框了。</p>
<h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><p>Android 系统的日志分为两部分，底层的 Linux 内核日志输出到 /proc/kmsg，Android 的日志输出到 /dev/log。</p>
<h3 id="Android-日志"><a href="#Android-日志" class="headerlink" title="Android 日志"></a>Android 日志</h3><p>命令格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[adb] logcat [&lt;option&gt;] ... [&lt;filter-spec&gt;] ...</span><br></pre></td></tr></table></figure>
<p>常用用法列举如下：</p>
<h4 id="按级别过滤日志"><a href="#按级别过滤日志" class="headerlink" title="按级别过滤日志"></a>按级别过滤日志</h4><p>Android 的日志分为如下几个优先级（priority）：</p>
<ul>
<li>V —— Verbose（最低，输出得最多）</li>
<li>D —— Debug</li>
<li>I —— Info</li>
<li>W —— Warning</li>
<li>E —— Error</li>
<li>F —— Fatal</li>
<li>S —— Silent（最高，啥也不输出）</li>
</ul>
<p>按某级别过滤日志则会将该级别及以上的日志输出。</p>
<p>比如，命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb logcat *:W</span><br></pre></td></tr></table></figure>
<p>会将 Warning、Error、Fatal 和 Silent 日志输出。</p>
<p>（<strong>注：</strong> 在 macOS 下需要给 <code>*:W</code> 这样以 <code>*</code> 作为 tag 的参数加双引号，如 <code>adb logcat &quot;*:W&quot;</code>，不然会报错 <code>no matches found: *:W</code>。）</p>
<h4 id="按-tag-和级别过滤日志"><a href="#按-tag-和级别过滤日志" class="headerlink" title="按 tag 和级别过滤日志"></a>按 tag 和级别过滤日志</h4><p><code>&lt;filter-spec&gt;</code> 可以由多个 <code>&lt;tag&gt;[:priority]</code> 组成。</p>
<p>比如，命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb logcat ActivityManager:I MyApp:D *:S</span><br></pre></td></tr></table></figure>
<p>表示输出 tag <code>ActivityManager</code> 的 Info 以上级别日志，输出 tag <code>MyApp</code> 的 Debug 以上级别日志，及其它 tag 的 Silent 级别日志（即屏蔽其它 tag 日志）。</p>
<h4 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a>日志格式</h4><p>可以用 <code>adb logcat -v &lt;format&gt;</code> 选项指定日志输出格式。</p>
<p>日志支持按以下几种 <code>&lt;format&gt;</code>：</p>
<ul>
<li><p>brief</p>
<p>默认格式。格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D/HeadsetStateMachine( 1785): Disconnected process message: 10, size: 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>process</p>
<p>格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;priority&gt;(&lt;pid&gt;) &lt;message&gt;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D( 1785) Disconnected process message: 10, size: 0  (HeadsetStateMachine)</span><br></pre></td></tr></table></figure>
</li>
<li><p>tag</p>
<p>格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;priority&gt;/&lt;tag&gt;: &lt;message&gt;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D/HeadsetStateMachine: Disconnected process message: 10, size: 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>raw</p>
<p>格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;message&gt;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Disconnected process message: 10, size: 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>time</p>
<p>格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;datetime&gt; &lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">08-28 22:39:39.974 D/HeadsetStateMachine( 1785): Disconnected process message: 10, size: 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>threadtime</p>
<p>格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;datetime&gt; &lt;pid&gt; &lt;tid&gt; &lt;priority&gt; &lt;tag&gt;: &lt;message&gt;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">08-28 22:39:39.974  1785  1832 D HeadsetStateMachine: Disconnected process message: 10, size: 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>long</p>
<p>格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ &lt;datetime&gt; &lt;pid&gt;:&lt;tid&gt; &lt;priority&gt;/&lt;tag&gt; ]</span><br><span class="line">&lt;message&gt;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ 08-28 22:39:39.974  1785: 1832 D/HeadsetStateMachine ]</span><br><span class="line">Disconnected process message: 10, size: 0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>指定格式可与上面的过滤同时使用。比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb logcat -v long ActivityManager:I *:S</span><br></pre></td></tr></table></figure>
<h4 id="清空日志"><a href="#清空日志" class="headerlink" title="清空日志"></a>清空日志</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb logcat -c</span><br></pre></td></tr></table></figure>
<h3 id="内核日志"><a href="#内核日志" class="headerlink" title="内核日志"></a>内核日志</h3><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell dmesg</span><br></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;6&gt;[14201.684016] PM: noirq resume of devices complete after 0.982 msecs</span><br><span class="line">&lt;6&gt;[14201.685525] PM: early resume of devices complete after 0.838 msecs</span><br><span class="line">&lt;6&gt;[14201.753642] PM: resume of devices complete after 68.106 msecs</span><br><span class="line">&lt;4&gt;[14201.755954] Restarting tasks ... done.</span><br><span class="line">&lt;6&gt;[14201.771229] PM: suspend exit 2016-08-28 13:31:32.679217193 UTC</span><br><span class="line">&lt;6&gt;[14201.872373] PM: suspend entry 2016-08-28 13:31:32.780363596 UTC</span><br><span class="line">&lt;6&gt;[14201.872498] PM: Syncing filesystems ... done.</span><br></pre></td></tr></table></figure>
<p>中括号里的 <code>[14201.684016]</code> 代表内核开始启动后的时间，单位为秒。</p>
<p>通过内核日志我们可以做一些事情，比如衡量内核启动时间，在系统启动完毕后的内核日志里找到 <code>Freeing init memory</code> 那一行前面的时间就是。</p>
<h2 id="查看设备信息"><a href="#查看设备信息" class="headerlink" title="查看设备信息"></a>查看设备信息</h2><h3 id="型号"><a href="#型号" class="headerlink" title="型号"></a>型号</h3><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell getprop ro.product.model</span><br></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Nexus 5</span><br></pre></td></tr></table></figure>
<h3 id="电池状况"><a href="#电池状况" class="headerlink" title="电池状况"></a>电池状况</h3><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys battery</span><br></pre></td></tr></table></figure>
<p>输入示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Current Battery Service state:</span><br><span class="line">  AC powered: false</span><br><span class="line">  USB powered: true</span><br><span class="line">  Wireless powered: false</span><br><span class="line">  status: 2</span><br><span class="line">  health: 2</span><br><span class="line">  present: true</span><br><span class="line">  level: 44</span><br><span class="line">  scale: 100</span><br><span class="line">  voltage: 3872</span><br><span class="line">  temperature: 280</span><br><span class="line">  technology: Li-poly</span><br></pre></td></tr></table></figure>
<p>其中 <code>scale</code> 代表最大电量，<code>level</code> 代表当前电量。上面的输出表示还剩下 44% 的电量。</p>
<h3 id="屏幕分辨率"><a href="#屏幕分辨率" class="headerlink" title="屏幕分辨率"></a>屏幕分辨率</h3><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell wm size</span><br></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Physical size: 1080x1920</span><br></pre></td></tr></table></figure>
<p>该设备屏幕分辨率为 1080px * 1920px。</p>
<p>如果使用命令修改过，那输出可能是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Physical size: 1080x1920</span><br><span class="line">Override size: 480x1024</span><br></pre></td></tr></table></figure>
<p>表明设备的屏幕分辨率原本是 1080px <em>1920px，当前被修改为 480px</em> 1024px。</p>
<h3 id="屏幕密度"><a href="#屏幕密度" class="headerlink" title="屏幕密度"></a>屏幕密度</h3><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell wm density</span><br></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Physical density: 420</span><br></pre></td></tr></table></figure>
<p>该设备屏幕密度为 420dpi。</p>
<p>如果使用命令修改过，那输出可能是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Physical density: 480</span><br><span class="line">Override density: 160</span><br></pre></td></tr></table></figure>
<p>表明设备的屏幕密度原来是 480dpi，当前被修改为 160dpi。</p>
<h3 id="显示屏参数"><a href="#显示屏参数" class="headerlink" title="显示屏参数"></a>显示屏参数</h3><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys window displays</span><br></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WINDOW MANAGER DISPLAY CONTENTS (dumpsys window displays)</span><br><span class="line">  Display: mDisplayId=0</span><br><span class="line">    init=1080x1920 420dpi cur=1080x1920 app=1080x1794 rng=1080x1017-1810x1731</span><br><span class="line">    deferred=false layoutNeeded=false</span><br></pre></td></tr></table></figure>
<p>其中 <code>mDisplayId</code> 为 显示屏编号，<code>init</code> 是初始分辨率和屏幕密度，<code>app</code> 的高度比 <code>init</code> 里的要小，表示屏幕底部有虚拟按键，高度为 1920 - 1794 = 126px 合 42dp。</p>
<h3 id="android-id"><a href="#android-id" class="headerlink" title="android_id"></a>android_id</h3><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell settings get secure android_id</span><br></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">51b6be48bac8c569</span><br></pre></td></tr></table></figure>
<h3 id="IMEI"><a href="#IMEI" class="headerlink" title="IMEI"></a>IMEI</h3><p>在 Android 4.4 及以下版本可通过如下命令获取 IMEI：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys iphonesubinfo</span><br></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Phone Subscriber Info:</span><br><span class="line">  Phone Type = GSM</span><br><span class="line">  Device ID = 860955027785041</span><br></pre></td></tr></table></figure>
<p>其中的 <code>Device ID</code> 就是 IMEI。</p>
<p>而在 Android 5.0 及以上版本里这个命令输出为空，得通过其它方式获取了（需要 root 权限）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br><span class="line">service call iphonesubinfo 1</span><br></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Result: Parcel(</span><br><span class="line">  0x00000000: 00000000 0000000f 00360038 00390030 &apos;........8.6.0.9.&apos;</span><br><span class="line">  0x00000010: 00350035 00320030 00370037 00350038 &apos;5.5.0.2.7.7.8.5.&apos;</span><br><span class="line">  0x00000020: 00340030 00000031                   &apos;0.4.1...        &apos;)</span><br></pre></td></tr></table></figure>
<p>把里面的有效内容提取出来就是 IMEI 了，比如这里的是 <code>860955027785041</code>。</p>
<p>参考：adb shell dumpsys iphonesubinfo not working since Android 5.0 Lollipop</p>
<h3 id="Android-系统版本"><a href="#Android-系统版本" class="headerlink" title="Android 系统版本"></a>Android 系统版本</h3><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell getprop ro.build.version.release</span><br></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5.0.2</span><br></pre></td></tr></table></figure>
<h3 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h3><p>每次想知道设备的 IP 地址的时候都得「设置」-「关于手机」-「状态信息」-「IP地址」很烦对不对？通过 adb 可以方便地查看。</p>
<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell ifconfig | grep Mask</span><br></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inet addr:10.130.245.230  Mask:255.255.255.252</span><br><span class="line">inet addr:127.0.0.1  Mask:255.0.0.0</span><br></pre></td></tr></table></figure>
<p>那么 <code>10.130.245.230</code> 就是设备 IP 地址。</p>
<p>在有的设备上这个命令没有输出，如果设备连着 WiFi，可以使用如下命令来查看局域网 IP：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell ifconfig wlan0</span><br></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wlan0: ip 10.129.160.99 mask 255.255.240.0 flags [up broadcast running multicast]</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wlan0     Link encap:UNSPEC</span><br><span class="line">          inet addr:10.129.168.57  Bcast:10.129.175.255  Mask:255.255.240.0</span><br><span class="line">          inet6 addr: fe80::66cc:2eff:fe68:b6b6/64 Scope: Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:496520 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:68215 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:3000</span><br><span class="line">          RX bytes:116266821 TX bytes:8311736</span><br></pre></td></tr></table></figure>
<p>如果以上命令仍然不能得到期望的信息，那可以试试以下命令（部分系统版本里可用）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell netcfg</span><br></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wlan0    UP                               10.129.160.99/20  0x00001043 f8:a9:d0:17:42:4d</span><br><span class="line">lo       UP                                   127.0.0.1/8   0x00000049 00:00:00:00:00:00</span><br><span class="line">p2p0     UP                                     0.0.0.0/0   0x00001003 fa:a9:d0:17:42:4d</span><br><span class="line">sit0     DOWN                                   0.0.0.0/0   0x00000080 00:00:00:00:00:00</span><br><span class="line">rmnet0   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00</span><br><span class="line">rmnet1   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00</span><br><span class="line">rmnet3   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00</span><br><span class="line">rmnet2   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00</span><br><span class="line">rmnet4   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00</span><br><span class="line">rmnet6   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00</span><br><span class="line">rmnet5   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00</span><br><span class="line">rmnet7   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00</span><br><span class="line">rev_rmnet3 DOWN                                   0.0.0.0/0   0x00001002 4e:b7:e4:2e:17:58</span><br><span class="line">rev_rmnet2 DOWN                                   0.0.0.0/0   0x00001002 4e:f0:c8:bf:7a:cf</span><br><span class="line">rev_rmnet4 DOWN                                   0.0.0.0/0   0x00001002 a6:c0:3b:6b:c4:1f</span><br><span class="line">rev_rmnet6 DOWN                                   0.0.0.0/0   0x00001002 66:bb:5d:64:2e:e9</span><br><span class="line">rev_rmnet5 DOWN                                   0.0.0.0/0   0x00001002 0e:1b:eb:b9:23:a0</span><br><span class="line">rev_rmnet7 DOWN                                   0.0.0.0/0   0x00001002 7a:d9:f6:81:40:5a</span><br><span class="line">rev_rmnet8 DOWN                                   0.0.0.0/0   0x00001002 4e:e2:a9:bb:d0:1b</span><br><span class="line">rev_rmnet0 DOWN                                   0.0.0.0/0   0x00001002 fe:65:d0:ca:82:a9</span><br><span class="line">rev_rmnet1 DOWN                                   0.0.0.0/0   0x00001002 da:d8:e8:4f:2e:fe</span><br></pre></td></tr></table></figure>
<p>可以看到网络连接名称、启用状态、IP 地址和 Mac 地址等信息。</p>
<h3 id="Mac-地址"><a href="#Mac-地址" class="headerlink" title="Mac 地址"></a>Mac 地址</h3><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell cat /sys/class/net/wlan0/address</span><br></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f8:a9:d0:17:42:4d</span><br></pre></td></tr></table></figure>
<p>这查看的是局域网 Mac 地址，移动网络或其它连接的信息可以通过前面的小节「IP 地址」里提到的 <code>adb shell netcfg</code> 命令来查看。</p>
<h3 id="CPU-信息"><a href="#CPU-信息" class="headerlink" title="CPU 信息"></a>CPU 信息</h3><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell cat /proc/cpuinfo</span><br></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Processor       : ARMv7 Processor rev 0 (v7l)</span><br><span class="line">processor       : 0</span><br><span class="line">BogoMIPS        : 38.40</span><br><span class="line"></span><br><span class="line">processor       : 1</span><br><span class="line">BogoMIPS        : 38.40</span><br><span class="line"></span><br><span class="line">processor       : 2</span><br><span class="line">BogoMIPS        : 38.40</span><br><span class="line"></span><br><span class="line">processor       : 3</span><br><span class="line">BogoMIPS        : 38.40</span><br><span class="line"></span><br><span class="line">Features        : swp half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt</span><br><span class="line">CPU implementer : 0x51</span><br><span class="line">CPU architecture: 7</span><br><span class="line">CPU variant     : 0x2</span><br><span class="line">CPU part        : 0x06f</span><br><span class="line">CPU revision    : 0</span><br><span class="line"></span><br><span class="line">Hardware        : Qualcomm MSM 8974 HAMMERHEAD (Flattened Device Tree)</span><br><span class="line">Revision        : 000b</span><br><span class="line">Serial          : 0000000000000000</span><br></pre></td></tr></table></figure>
<p>这是 Nexus 5 的 CPU 信息，我们从输出里可以看到使用的硬件是 <code>Qualcomm MSM 8974</code>，processor 的编号是 0 到 3，所以它是四核的，采用的架构是 <code>ARMv7 Processor rev 0 (v71)</code>。</p>
<h3 id="内存信息"><a href="#内存信息" class="headerlink" title="内存信息"></a>内存信息</h3><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell cat /proc/meminfo</span><br></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MemTotal:        1027424 kB</span><br><span class="line">MemFree:          486564 kB</span><br><span class="line">Buffers:           15224 kB</span><br><span class="line">Cached:            72464 kB</span><br><span class="line">SwapCached:        24152 kB</span><br><span class="line">Active:           110572 kB</span><br><span class="line">Inactive:         259060 kB</span><br><span class="line">Active(anon):      79176 kB</span><br><span class="line">Inactive(anon):   207736 kB</span><br><span class="line">Active(file):      31396 kB</span><br><span class="line">Inactive(file):    51324 kB</span><br><span class="line">Unevictable:        3948 kB</span><br><span class="line">Mlocked:               0 kB</span><br><span class="line">HighTotal:        409600 kB</span><br><span class="line">HighFree:         132612 kB</span><br><span class="line">LowTotal:         617824 kB</span><br><span class="line">LowFree:          353952 kB</span><br><span class="line">SwapTotal:        262140 kB</span><br><span class="line">SwapFree:         207572 kB</span><br><span class="line">Dirty:                 0 kB</span><br><span class="line">Writeback:             0 kB</span><br><span class="line">AnonPages:        265324 kB</span><br><span class="line">Mapped:            47072 kB</span><br><span class="line">Shmem:              1020 kB</span><br><span class="line">Slab:              57372 kB</span><br><span class="line">SReclaimable:       7692 kB</span><br><span class="line">SUnreclaim:        49680 kB</span><br><span class="line">KernelStack:        4512 kB</span><br><span class="line">PageTables:         5912 kB</span><br><span class="line">NFS_Unstable:          0 kB</span><br><span class="line">Bounce:                0 kB</span><br><span class="line">WritebackTmp:          0 kB</span><br><span class="line">CommitLimit:      775852 kB</span><br><span class="line">Committed_AS:   13520632 kB</span><br><span class="line">VmallocTotal:     385024 kB</span><br><span class="line">VmallocUsed:       61004 kB</span><br><span class="line">VmallocChunk:     209668 kB</span><br></pre></td></tr></table></figure>
<p>其中，<code>MemTotal</code> 就是设备的总内存，<code>MemFree</code> 是当前空闲内存。</p>
<h3 id="更多硬件与系统属性"><a href="#更多硬件与系统属性" class="headerlink" title="更多硬件与系统属性"></a>更多硬件与系统属性</h3><p>设备的更多硬件与系统属性可以通过如下命令查看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell cat /system/build.prop</span><br></pre></td></tr></table></figure>
<p>这会输出很多信息，包括前面几个小节提到的「型号」和「Android 系统版本」等。</p>
<p>输出里还包括一些其它有用的信息，它们也可通过 <code>adb shell getprop &lt;属性名&gt;</code> 命令单独查看，列举一部分属性如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ro.build.version.sdk</td>
<td>SDK 版本</td>
</tr>
<tr>
<td>ro.build.version.release</td>
<td>Android 系统版本</td>
</tr>
<tr>
<td>ro.build.version.security_patch</td>
<td>Android 安全补丁程序级别</td>
</tr>
<tr>
<td>ro.product.model</td>
<td>型号</td>
</tr>
<tr>
<td>ro.product.brand</td>
<td>品牌</td>
</tr>
<tr>
<td>ro.product.name</td>
<td>设备名</td>
</tr>
<tr>
<td>ro.product.board</td>
<td>处理器型号</td>
</tr>
<tr>
<td>ro.product.cpu.abilist</td>
<td>CPU 支持的 abi 列表[<em>节注一</em>]</td>
</tr>
<tr>
<td>persist.sys.isUsbOtgEnabled</td>
<td>是否支持 OTG</td>
</tr>
<tr>
<td>dalvik.vm.heapsize</td>
<td>每个应用程序的内存上限</td>
</tr>
<tr>
<td>ro.sf.lcd_density</td>
<td>屏幕密度</td>
</tr>
</tbody>
</table>
</div>
<p><em>节注一：</em></p>
<p>一些小厂定制的 ROM 可能修改过 CPU 支持的 abi 列表的属性名，如果用 <code>ro.product.cpu.abilist</code> 属性名查找不到，可以这样试试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell cat /system/build.prop | grep ro.product.cpu.abi</span><br></pre></td></tr></table></figure>
<p>示例输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ro.product.cpu.abi=armeabi-v7a</span><br><span class="line">ro.product.cpu.abi2=armeabi</span><br></pre></td></tr></table></figure>
<h2 id="修改设置"><a href="#修改设置" class="headerlink" title="修改设置"></a>修改设置</h2><p><strong>注：</strong> 修改设置之后，运行恢复命令有可能显示仍然不太正常，可以运行 <code>adb reboot</code> 重启设备，或手动重启。</p>
<p>修改设置的原理主要是通过 settings 命令修改 /data/data/com.android.providers.settings/databases/settings.db 里存放的设置值。</p>
<h3 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h3><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell wm size 480x1024</span><br></pre></td></tr></table></figure>
<p>表示将分辨率修改为 480px * 1024px。</p>
<p>恢复原分辨率命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell wm size reset</span><br></pre></td></tr></table></figure>
<h3 id="屏幕密度-1"><a href="#屏幕密度-1" class="headerlink" title="屏幕密度"></a>屏幕密度</h3><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell wm density 160</span><br></pre></td></tr></table></figure>
<p>表示将屏幕密度修改为 160dpi。</p>
<p>恢复原屏幕密度命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell wm density reset</span><br></pre></td></tr></table></figure>
<h3 id="显示区域"><a href="#显示区域" class="headerlink" title="显示区域"></a>显示区域</h3><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell wm overscan 0,0,0,200</span><br></pre></td></tr></table></figure>
<p>四个数字分别表示距离左、上、右、下边缘的留白像素，以上命令表示将屏幕底部 200px 留白。</p>
<p>恢复原显示区域命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell wm overscan reset</span><br></pre></td></tr></table></figure>
<h3 id="关闭-USB-调试模式"><a href="#关闭-USB-调试模式" class="headerlink" title="关闭 USB 调试模式"></a>关闭 USB 调试模式</h3><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell settings put global adb_enabled 0</span><br></pre></td></tr></table></figure>
<p>恢复：</p>
<p>用命令恢复不了了，毕竟关闭了 USB 调试 adb 就连接不上 Android 设备了。</p>
<p>去设备上手动恢复吧：「设置」-「开发者选项」-「Android 调试」。</p>
<h3 id="状态栏和导航栏的显示隐藏"><a href="#状态栏和导航栏的显示隐藏" class="headerlink" title="状态栏和导航栏的显示隐藏"></a>状态栏和导航栏的显示隐藏</h3><p>本节所说的相关设置对应 Cyanogenmod 里的「扩展桌面」。</p>
<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell settings put global policy_control &lt;key-values&gt;</span><br></pre></td></tr></table></figure>
<p><code>&lt;key-values&gt;</code> 可由如下几种键及其对应的值组成，格式为 <code>&lt;key1&gt;=&lt;value1&gt;:&lt;key2&gt;=&lt;value2&gt;</code>。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>key</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>immersive.full</td>
<td>同时隐藏</td>
</tr>
<tr>
<td>immersive.status</td>
<td>隐藏状态栏</td>
</tr>
<tr>
<td>immersive.navigation</td>
<td>隐藏导航栏</td>
</tr>
<tr>
<td>immersive.preconfirms</td>
<td>?</td>
</tr>
</tbody>
</table>
</div>
<p>这些键对应的值可则如下值用逗号组合：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>value</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>apps</code></td>
<td>所有应用</td>
</tr>
<tr>
<td><code>*</code></td>
<td>所有界面</td>
</tr>
<tr>
<td><code>packagename</code></td>
<td>指定应用</td>
</tr>
<tr>
<td><code>-packagename</code></td>
<td>排除指定应用</td>
</tr>
</tbody>
</table>
</div>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell settings put global policy_control immersive.full=*</span><br></pre></td></tr></table></figure>
<p>表示设置在所有界面下都同时隐藏状态栏和导航栏。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell settings put global policy_control immersive.status=com.package1,com.package2:immersive.navigation=apps,-com.package3</span><br></pre></td></tr></table></figure>
<p>表示设置在包名为 <code>com.package1</code> 和 <code>com.package2</code> 的应用里隐藏状态栏，在除了包名为 <code>com.package3</code> 的所有应用里隐藏导航栏。</p>
<h2 id="实用功能"><a href="#实用功能" class="headerlink" title="实用功能"></a>实用功能</h2><h3 id="屏幕截图"><a href="#屏幕截图" class="headerlink" title="屏幕截图"></a>屏幕截图</h3><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell screencap -p /sdcard/sc.png</span><br></pre></td></tr></table></figure>
<p>然后将 png 文件导出到电脑：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb pull /sdcard/sc.png</span><br></pre></td></tr></table></figure>
<p>可以使用 <code>adb shell screencap -h</code> 查看 <code>screencap</code> 命令的帮助信息，下面是两个有意义的参数及含义：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-p</td>
<td>指定保存文件为 png 格式</td>
</tr>
<tr>
<td>-d display-id</td>
<td>指定截图的显示屏编号（有多显示屏的情况下）</td>
</tr>
</tbody>
</table>
</div>
<p>实测如果指定文件名以 <code>.png</code> 结尾时可以省略 -p 参数；否则需要使用 -p 参数。如果不指定文件名，截图文件的内容将直接输出到 stdout。</p>
<p>直接一行命令截图并保存到电脑的方法：</p>
<p><em>Linux 和 Windows</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell screencap -p | sed &quot;s/\r$//&quot; &gt; sc.png</span><br></pre></td></tr></table></figure>
<p><em>Mac OS X</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell screencap -p | gsed &quot;s/\r$//&quot; &gt; sc.png</span><br></pre></td></tr></table></figure>
<p>这个方法需要用到 gnu sed 命令，在 Linux 下直接就有，在 Windows 下 Git 安装目录的 bin 文件夹下也有。如果确实找不到该命令，可以下载 sed for Windows 并将 sed.exe 所在文件夹添加到 PATH 环境变量里。</p>
<p>而在 Mac 下使用系统自带的 sed 命令会报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed: RE error: illegal byte sequence</span><br></pre></td></tr></table></figure>
<p>需要安装 gnu-sed，然后使用 gsed 命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install gnu-sed</span><br></pre></td></tr></table></figure>
<h3 id="录制屏幕"><a href="#录制屏幕" class="headerlink" title="录制屏幕"></a>录制屏幕</h3><p>录制屏幕以 mp4 格式保存到 /sdcard：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell screenrecord /sdcard/filename.mp4</span><br></pre></td></tr></table></figure>
<p>需要停止时按 Ctrl-C，默认录制时间和最长录制时间都是 180 秒。</p>
<p>如果需要导出到电脑：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb pull /sdcard/filename.mp4</span><br></pre></td></tr></table></figure>
<p>可以使用 <code>adb shell screenrecord --help</code> 查看 <code>screenrecord</code> 命令的帮助信息，下面是常见参数及含义：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>–size WIDTHxHEIGHT</td>
<td>视频的尺寸，比如 <code>1280x720</code>，默认是屏幕分辨率。</td>
</tr>
<tr>
<td>–bit-rate RATE</td>
<td>视频的比特率，默认是 4Mbps。</td>
</tr>
<tr>
<td>–time-limit TIME</td>
<td>录制时长，单位秒。</td>
</tr>
<tr>
<td>–verbose</td>
<td>输出更多信息。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="重新挂载-system-分区为可写"><a href="#重新挂载-system-分区为可写" class="headerlink" title="重新挂载 system 分区为可写"></a>重新挂载 system 分区为可写</h3><p><strong>注：需要 root 权限。</strong></p>
<p>/system 分区默认挂载为只读，但有些操作比如给 Android 系统添加命令、删除自带应用等需要对 /system 进行写操作，所以需要重新挂载它为可读写。</p>
<p>步骤：</p>
<ol>
<li><p>进入 shell 并切换到 root 用户权限。</p>
<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看当前分区挂载情况。</p>
<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount</span><br></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rootfs / rootfs ro,relatime 0 0</span><br><span class="line">tmpfs /dev tmpfs rw,seclabel,nosuid,relatime,mode=755 0 0</span><br><span class="line">devpts /dev/pts devpts rw,seclabel,relatime,mode=600 0 0</span><br><span class="line">proc /proc proc rw,relatime 0 0</span><br><span class="line">sysfs /sys sysfs rw,seclabel,relatime 0 0</span><br><span class="line">selinuxfs /sys/fs/selinux selinuxfs rw,relatime 0 0</span><br><span class="line">debugfs /sys/kernel/debug debugfs rw,relatime 0 0</span><br><span class="line">none /var tmpfs rw,seclabel,relatime,mode=770,gid=1000 0 0</span><br><span class="line">none /acct cgroup rw,relatime,cpuacct 0 0</span><br><span class="line">none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0</span><br><span class="line">none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0</span><br><span class="line">tmpfs /mnt/asec tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0</span><br><span class="line">tmpfs /mnt/obb tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0</span><br><span class="line">none /dev/memcg cgroup rw,relatime,memory 0 0</span><br><span class="line">none /dev/cpuctl cgroup rw,relatime,cpu 0 0</span><br><span class="line">none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0</span><br><span class="line">none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0</span><br><span class="line">none /sys/fs/cgroup/freezer cgroup rw,relatime,freezer 0 0</span><br><span class="line">/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0</span><br><span class="line">/dev/block/platform/msm_sdcc.1/by-name/userdata /data ext4 rw,seclabel,nosuid,nodev,relatime,noauto_da_alloc,data=ordered 0 0</span><br><span class="line">/dev/block/platform/msm_sdcc.1/by-name/cache /cache ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0</span><br><span class="line">/dev/block/platform/msm_sdcc.1/by-name/persist /persist ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0</span><br><span class="line">/dev/block/platform/msm_sdcc.1/by-name/modem /firmware vfat ro,context=u:object_r:firmware_file:s0,relatime,uid=1000,gid=1000,fmask=0337,dmask=0227,codepage=cp437,iocharset=iso8859-1,shortname=lower,errors=remount-ro 0 0</span><br><span class="line">/dev/fuse /mnt/shell/emulated fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0</span><br><span class="line">/dev/fuse /mnt/shell/emulated/0 fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0</span><br></pre></td></tr></table></figure>
<p>找到其中我们关注的带 /system 的那一行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新挂载。</p>
<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount -o remount,rw -t yaffs2 /dev/block/platform/msm_sdcc.1/by-name/system /system</span><br></pre></td></tr></table></figure>
<p>这里的 <code>/dev/block/platform/msm_sdcc.1/by-name/system</code> 就是我们从上一步的输出里得到的文件路径。</p>
</li>
</ol>
<p>如果输出没有提示错误的话，操作就成功了，可以对 /system 下的文件为所欲为了。</p>
<h3 id="查看连接过的-WiFi-密码"><a href="#查看连接过的-WiFi-密码" class="headerlink" title="查看连接过的 WiFi 密码"></a>查看连接过的 WiFi 密码</h3><p><strong>注：需要 root 权限。</strong></p>
<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br><span class="line">cat /data/misc/wifi/*.conf</span><br></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">network=&#123;</span><br><span class="line">truessid=&quot;TP-LINK_9DFC&quot;</span><br><span class="line">truescan_ssid=1</span><br><span class="line">truepsk=&quot;123456789&quot;</span><br><span class="line">truekey_mgmt=WPA-PSK</span><br><span class="line">truegroup=CCMP TKIP</span><br><span class="line">trueauth_alg=OPEN</span><br><span class="line">truesim_num=1</span><br><span class="line">truepriority=13893</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">network=&#123;</span><br><span class="line">truessid=&quot;TP-LINK_F11E&quot;</span><br><span class="line">truepsk=&quot;987654321&quot;</span><br><span class="line">truekey_mgmt=WPA-PSK</span><br><span class="line">truesim_num=1</span><br><span class="line">truepriority=17293</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ssid</code> 即为我们在 WLAN 设置里看到的名称，<code>psk</code> 为密码，<code>key_mgmt</code> 为安全加密方式。</p>
<h3 id="设置系统日期和时间"><a href="#设置系统日期和时间" class="headerlink" title="设置系统日期和时间"></a>设置系统日期和时间</h3><p><strong>注：需要 root 权限。</strong></p>
<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br><span class="line">date -s 20160823.131500</span><br></pre></td></tr></table></figure>
<p>表示将系统日期和时间更改为 2016 年 08 月 23 日 13 点 15 分 00 秒。</p>
<h3 id="重启手机"><a href="#重启手机" class="headerlink" title="重启手机"></a>重启手机</h3><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb reboot</span><br></pre></td></tr></table></figure>
<h3 id="检测设备是否已-root"><a href="#检测设备是否已-root" class="headerlink" title="检测设备是否已 root"></a>检测设备是否已 root</h3><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br></pre></td></tr></table></figure>
<p>此时命令行提示符是 <code>$</code> 则表示没有 root 权限，是 <code>#</code> 则表示已 root。</p>
<h3 id="使用-Monkey-进行压力测试"><a href="#使用-Monkey-进行压力测试" class="headerlink" title="使用 Monkey 进行压力测试"></a>使用 Monkey 进行压力测试</h3><p>Monkey 可以生成伪随机用户事件来模拟单击、触摸、手势等操作，可以对正在开发中的程序进行随机压力测试。</p>
<p>简单用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell monkey -p &lt;packagename&gt; -v 500</span><br></pre></td></tr></table></figure>
<p>表示向 <code>&lt;packagename&gt;</code> 指定的应用程序发送 500 个伪随机事件。</p>
<p>Monkey 的详细用法参考 官方文档。</p>
<h3 id="开启-关闭-WiFi"><a href="#开启-关闭-WiFi" class="headerlink" title="开启/关闭 WiFi"></a>开启/关闭 WiFi</h3><p><strong>注：需要 root 权限。</strong></p>
<p>有时需要控制设备的 WiFi 状态，可以用以下指令完成。</p>
<p>开启 WiFi：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb shell svc wifi enable</span><br></pre></td></tr></table></figure>
<p>关闭 WiFi：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb shell svc wifi disable</span><br></pre></td></tr></table></figure>
<p>若执行成功，输出为空；若未取得 root 权限执行此命令，将执行失败，输出 <code>Killed</code>。</p>
<h2 id="刷机相关命令"><a href="#刷机相关命令" class="headerlink" title="刷机相关命令"></a>刷机相关命令</h2><h3 id="重启到-Recovery-模式"><a href="#重启到-Recovery-模式" class="headerlink" title="重启到 Recovery 模式"></a>重启到 Recovery 模式</h3><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb reboot recovery</span><br></pre></td></tr></table></figure>
<h3 id="从-Recovery-重启到-Android"><a href="#从-Recovery-重启到-Android" class="headerlink" title="从 Recovery 重启到 Android"></a>从 Recovery 重启到 Android</h3><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb reboot</span><br></pre></td></tr></table></figure>
<h3 id="重启到-Fastboot-模式"><a href="#重启到-Fastboot-模式" class="headerlink" title="重启到 Fastboot 模式"></a>重启到 Fastboot 模式</h3><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb reboot bootloader</span><br></pre></td></tr></table></figure>
<h3 id="通过-sideload-更新系统"><a href="#通过-sideload-更新系统" class="headerlink" title="通过 sideload 更新系统"></a>通过 sideload 更新系统</h3><p>如果我们下载了 Android 设备对应的系统更新包到电脑上，那么也可以通过 adb 来完成更新。</p>
<p>以 Recovery 模式下更新为例：</p>
<ol>
<li><p>重启到 Recovery 模式。</p>
<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb reboot recovery</span><br></pre></td></tr></table></figure>
</li>
<li><p>在设备的 Recovery 界面上操作进入 <code>Apply update</code>-<code>Apply from ADB</code>。</p>
<p>注：不同的 Recovery 菜单可能与此有差异，有的是一级菜单就有 <code>Apply update from ADB</code>。</p>
</li>
<li><p>通过 adb 上传和更新系统。</p>
<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb sideload &lt;path-to-update.zip&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="更多-adb-shell-命令"><a href="#更多-adb-shell-命令" class="headerlink" title="更多 adb shell 命令"></a>更多 adb shell 命令</h2><p>Android 系统是基于 Linux 内核的，所以 Linux 里的很多命令在 Android 里也有相同或类似的实现，在 <code>adb shell</code> 里可以调用。本文档前面的部分内容已经用到了 <code>adb shell</code> 命令。</p>
<h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell ps</span><br></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USER     PID   PPID  VSIZE  RSS     WCHAN    PC        NAME</span><br><span class="line">root      1     0     8904   788   ffffffff 00000000 S /init</span><br><span class="line">root      2     0     0      0     ffffffff 00000000 S kthreadd</span><br><span class="line">...</span><br><span class="line">u0_a71    7779  5926  1538748 48896 ffffffff 00000000 S com.sohu.inputmethod.sogou:classic</span><br><span class="line">u0_a58    7963  5926  1561916 59568 ffffffff 00000000 S org.mazhuang.boottimemeasure</span><br><span class="line">...</span><br><span class="line">shell     8750  217   10640  740   00000000 b6f28340 R ps</span><br></pre></td></tr></table></figure>
<p>各列含义：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>列名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>USER</td>
<td>所属用户</td>
</tr>
<tr>
<td>PID</td>
<td>进程 ID</td>
</tr>
<tr>
<td>PPID</td>
<td>父进程 ID</td>
</tr>
<tr>
<td>NAME</td>
<td>进程名</td>
</tr>
</tbody>
</table>
</div>
<h3 id="查看实时资源占用情况"><a href="#查看实时资源占用情况" class="headerlink" title="查看实时资源占用情况"></a>查看实时资源占用情况</h3><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell top</span><br></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User 0%, System 6%, IOW 0%, IRQ 0%</span><br><span class="line">User 3 + Nice 0 + Sys 21 + Idle 280 + IOW 0 + IRQ 0 + SIRQ 3 = 307</span><br><span class="line"></span><br><span class="line">  PID PR CPU% S  #THR     VSS     RSS PCY UID      Name</span><br><span class="line"> 8763  0   3% R     1  10640K   1064K  fg shell    top</span><br><span class="line">  131  0   3% S     1      0K      0K  fg root     dhd_dpc</span><br><span class="line"> 6144  0   0% S   115 1682004K 115916K  fg system   system_server</span><br><span class="line">  132  0   0% S     1      0K      0K  fg root     dhd_rxf</span><br><span class="line"> 1731  0   0% S     6  20288K    788K  fg root     /system/bin/mpdecision</span><br><span class="line">  217  0   0% S     6  18008K    356K  fg shell    /sbin/adbd</span><br><span class="line"> ...</span><br><span class="line"> 7779  2   0% S    19 1538748K  48896K  bg u0_a71   com.sohu.inputmethod.sogou:classic</span><br><span class="line"> 7963  0   0% S    18 1561916K  59568K  fg u0_a58   org.mazhuang.boottimemeasure</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>
<p>各列含义：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>列名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>PID</td>
<td>进程 ID</td>
</tr>
<tr>
<td>PR</td>
<td>优先级</td>
</tr>
<tr>
<td>CPU%</td>
<td>当前瞬间占用 CPU 百分比</td>
</tr>
<tr>
<td>S</td>
<td>进程状态（R=运行，S=睡眠，T=跟踪/停止，Z=僵尸进程）</td>
</tr>
<tr>
<td>#THR</td>
<td>线程数</td>
</tr>
<tr>
<td>VSS</td>
<td>Virtual Set Size 虚拟耗用内存（包含共享库占用的内存）</td>
</tr>
<tr>
<td>RSS</td>
<td>Resident Set Size 实际使用物理内存（包含共享库占用的内存）</td>
</tr>
<tr>
<td>PCY</td>
<td>调度策略优先级，SP_BACKGROUND/SPFOREGROUND</td>
</tr>
<tr>
<td>UID</td>
<td>进程所有者的用户 ID</td>
</tr>
<tr>
<td>NAME</td>
<td>进程名</td>
</tr>
</tbody>
</table>
</div>
<p><code>top</code> 命令还支持一些命令行参数，详细用法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage: top [ -m max_procs ] [ -n iterations ] [ -d delay ] [ -s sort_column ] [ -t ] [ -h ]</span><br><span class="line">    -m num  最多显示多少个进程</span><br><span class="line">    -n num  刷新多少次后退出</span><br><span class="line">    -d num  刷新时间间隔（单位秒，默认值 5）</span><br><span class="line">    -s col  按某列排序（可用 col 值：cpu, vss, rss, thr）</span><br><span class="line">    -t      显示线程信息</span><br><span class="line">    -h      显示帮助文档</span><br></pre></td></tr></table></figure>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>如下是其它常用命令的简单描述，前文已经专门讲过的命令不再额外说明：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>cat</td>
<td>显示文件内容</td>
</tr>
<tr>
<td>cd</td>
<td>切换目录</td>
</tr>
<tr>
<td>chmod</td>
<td>改变文件的存取模式/访问权限</td>
</tr>
<tr>
<td>df</td>
<td>查看磁盘空间使用情况</td>
</tr>
<tr>
<td>grep</td>
<td>过滤输出</td>
</tr>
<tr>
<td>kill</td>
<td>杀死指定 PID 的进程</td>
</tr>
<tr>
<td>ls</td>
<td>列举目录内容</td>
</tr>
<tr>
<td>mount</td>
<td>挂载目录的查看和管理</td>
</tr>
<tr>
<td>mv</td>
<td>移动或重命名文件</td>
</tr>
<tr>
<td>ps</td>
<td>查看正在运行的进程</td>
</tr>
<tr>
<td>rm</td>
<td>删除文件</td>
</tr>
<tr>
<td>top</td>
<td>查看进程的资源占用情况</td>
</tr>
</tbody>
</table>
</div>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="启动-adb-server-失败"><a href="#启动-adb-server-失败" class="headerlink" title="启动 adb server 失败"></a>启动 adb server 失败</h3><p><strong>出错提示</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error: protocol fault (couldn&apos;t read status): No error</span><br></pre></td></tr></table></figure>
<p><strong>可能原因</strong></p>
<p>adb server 进程想使用的 5037 端口被占用。</p>
<p><strong>解决方案</strong></p>
<p>找到占用 5037 端口的进程，然后终止它。以 Windows 下为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -ano | findstr LISTENING</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">TCP    0.0.0.0:5037           0.0.0.0:0              LISTENING       1548</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这里 1548 即为进程 ID，用命令结束该进程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">taskkill /PID 1548</span><br></pre></td></tr></table></figure>
<p>然后再启动 adb 就没问题了。</p>
<h2 id="adb-的非官方实现"><a href="#adb-的非官方实现" class="headerlink" title="adb 的非官方实现"></a>adb 的非官方实现</h2><ul>
<li>fb-adb - A better shell for Android devices (for Mac).</li>
</ul>
<h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>感谢朋友们无私的分享与补充（排名不分先后）。</p>
<p>zxning，linhua55，codeskyblue，seasonyuu，fan123199，zhEdward，0x8BADFOOD，keith666666。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li>Android Debug Bridge</li>
<li>ADB Shell Commands</li>
<li>logcat Command-line Tool</li>
<li>Android ADB命令大全</li>
<li>adb 命令行的使用记录</li>
<li>Android ADB命令大全(通过ADB命令查看wifi密码、MAC地址、设备信息、操作文件、查看文件、日志信息、卸载、启动和安装APK等)</li>
<li>那些做Android开发必须知道的ADB命令</li>
<li>adb shell top</li>
<li>像高手一样使用ADB命令行（2）</li>
</ul>
]]></content>
      <categories>
        <category>android</category>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
</search>
